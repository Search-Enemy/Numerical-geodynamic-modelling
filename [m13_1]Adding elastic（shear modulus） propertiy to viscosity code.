%This program complished the process of 2D Eulerian advection with method
%of MIC(allocating memory temporarily) in vistoelatoplastic material.
% "NOTE" line 23,line 107 !!!
clear all;clf;
% Set parameters
% Length of model
Lx = 500000; 
Ly = 500000;
xmid = Lx/2;
ymid = Ly/2;
% Sum of point number of model
Nx = 51; 
Ny = 51; 
Nx1 = Nx+1;
Ny1 = Ny+1;
% Interval of E-staggered-nodes
dx = Lx / (Nx-1);
dy = Ly / (Ny-1);
% Basic nodes.
x = 0:dx:Lx;
y = 0:dy:Ly;
% Vx staggered nodes.(Nx_node * Ny_node+1)
xvx = 0:dx:Lx+dx;
yvx = -dy/2 : dy : Ly+dy/2;
% Vy staggered nodes.(Nx_node+1 * Ny_node)
xvy = -dx/2 : dx : Lx+dx/2;
yvy = 0:dy:Ly+dy;
% P staggered nodes.(Nx_node+1 * Ny_node+1)
xp = -dx/2 : dx : Lx+dx/2;
yp = -dy/2 : dy : Ly+dy/2;

% Velocity and Pressure matrix
% Vx NODE
vx = zeros(Ny1,Nx1);
RHOVX=zeros(Ny1,Nx1); 
KVX=zeros(Ny1,Nx1); 
% Vy NODE
vy = zeros(Ny1,Nx1);
RHOVY=zeros(Ny1,Nx1); 
KVY=zeros(Ny1,Nx1); 
% P NODE
p = zeros(Ny1,Nx1);
ETAP = zeros(Ny1,Nx1);
MIUP = zeros(Ny1,Nx1);
RHOP = zeros(Ny1,Nx1);
RHOPCP = zeros(Ny1,Nx1); %Den*Cp(hct)
Hrij = zeros(Ny1,Nx1);
Haij = zeros(Ny1,Nx1);
Hsij = zeros(Ny1,Nx1);
Aefij = zeros(Ny1,Nx1);
EXX=zeros(Ny1,Nx1); % EPSILONxx, 1/s
SXX=zeros(Ny1,Nx1); % SIGMA'xx, 1/s
SXX0 = zeros(Ny1,Nx1);
T0 = zeros(Ny1,Nx1); %Told
T1 = zeros(Ny1,Nx1); %Tnew
    % vx/vy at pnodes
pvx = zeros(Ny1,Nx1);
pvy = zeros(Ny1,Nx1);
% Gravity acceleration
gy = 10;
gx = 0;
% Basic node
ETA = zeros(Ny,Nx);
MIU = zeros(Ny,Nx);
EXY = zeros(Ny,Nx);
SXY = zeros(Ny,Nx);
sxy0 = zeros(Ny,Nx);
wyx = zeros(Ny,Nx);

% Stokes-equ and continuity-equ
% Temperature-equ
% Amount of markers.
Nxm = 4*(Nx-1);
Nym = 4*(Ny-1);
marknum=Nxm*Nym;
% Step-length among L-marker points
dxm = Lx/Nxm;
dym = Ly/Nym;
% Marker points.
% Stokes-equ and continuity-equ
xm=zeros(1,marknum); % Horizontal coordinates, m
ym=zeros(1,marknum);
sxxm = zeros(1,marknum);
sxym = zeros(1,marknum);
tkm = zeros(1,marknum); % temperature
tm = zeros(1,marknum);

% Properities
rhom   = [3300   3200   1     ]; % Density, kg/m^3
etam   = [1e+21  1e+20  1e+17 ]; % Viscosity, Pa s
rhocpm = [3.3e+6 3.2e+6 3.3e+6]; % Volumetric heat capacity, kg/m^3
alpham = [3e-5   2e-5   0     ]; % Thermal expansion, 1/K
km     = [3      2      3000  ]; % Thermal conductivity, W/m/K
hrm    = [2e-8   3e-8   0     ]; % Radiogenic heat production, W/m^3
gggm   = [5e+10  3e+10  2e+10 ]; % Shear Modulus, Pa
frictm = [0.6    0      0     ]; % Friction coefficient
coshesm = [1e+8   1e+7   1e+7  ]; % Cohesion, Pa

rp=100000; % Plume radius, m
m=1; % Marker counter
for jm=1:1:Nxm
    for im=1:1:Nym
        % Define marker coordinates
        xm(m)=dxm/2+(jm-1)*dxm+(rand-0.5)*dxm;
        ym(m)=dym/2+(im-1)*dym+(rand-0.5)*dym;
        % Marker properties
        rmark=((xm(m)-xmid)^2+(ym(m)-ymid)^2)^0.5;
        if(rmark>rp)
            % Mantle
            tm(m)=1; % Material type
            tkm(m)=1500; % Temperature
        else
            % Plume
            tm(m)=2; % Material type
            tkm(m)=1800; % Temperature
        end
        % Sticky air (to have internal free surface)
        if(ym(m)<0.2*Ly)
            tm(m)=3; % Material type
            tkm(m)=273; % Temperature
%             tkm(m)=273+(1500-273)*ym(m)/ysize/0.2; % Temperature
        end
        % Update marker counter
        m=m+1;
    end
end

%WHY???
Kcont = 1e+21/dx;

% Define matrix for Stokes
unknowns = Nx1*Ny1*3;
R  =   zeros(unknowns, 1);
coe = sparse(unknowns,unknowns);
% Define matrix for T
unknowns = Nx1*Ny1;
bt = zeros(unknowns,1);
coet = sparse(unknowns, unknowns);
 
% Boundary condition : free slip = -1 ; no slip = 1
bc_left   = -1;
bc_right  = -1;
bc_top    = -1;
bc_bottom = -1;

% Define dt for stokes equation.
dt = 1e10; % initial timestep
dxymax   = 0.5;   
timesum = 0;
Nt = 400;
dtkoef = 1.2;
YIELDERR=zeros(1,Nt); % Yielding error of markers
minetavpm = 1e+17;
maxetavpm = 1e+23;
DTmax=20; % max temperature change per time step, K
subgrdifcoes = 1;
subgrdifcoet = 1;
t = 1;
figure(1);
for t = t:1:Nt     
    
% Save old stresses
sxxm00=sxxm; 
sxym00=sxym;
    
    % BASCI NODE
    WTSUM = zeros(Ny,Nx);
    ETASUM = zeros(Ny,Nx);
    MIUSUM = zeros(Ny,Nx);
    SXYSUM = zeros(Ny,Nx);
    % Vx nodes    
    RHOXSUM=zeros(Ny1,Nx1);
    WTXSUM=zeros(Ny1,Nx1);
    KXSUM=zeros(Ny1,Nx1);
    % Vy nodes    
    RHOYSUM=zeros(Ny1,Nx1);
    WTYSUM=zeros(Ny1,Nx1);
    KYSUM=zeros(Ny1,Nx1);
    %Pnodes
    WTPSUM = zeros(Ny1,Nx1);% weights except T
    ETAPSUM = zeros(Ny1,Nx1);% Viscosity at P node
    SXXSUM = zeros(Ny1,Nx1);
    MIUPSUM = zeros(Ny1,Nx1);% miu at P node
    RHOSUM = zeros(Ny1,Nx1);% Density at P node
    HRSUM = zeros(Ny1,Nx1);  % Hr at P node
    ALPHASUM = zeros(Ny1,Nx1); % Aef at P node
    RHOCPSUM = zeros(Ny1,Nx1);% Den*Cp at P node
    TKSUM = zeros(Ny1,Nx1); % T at P node
    
    % Interpolate viscosity from markers to BASIC NODES.
    % Searching the coordinate of upper-left node of every L-marker.
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            ETASUM(i,j)=ETASUM(i,j)+etam(tm(m))*wtmij;
            MIUSUM(i,j)=MIUSUM(i,j)+1/gggm(tm(m))*wtmij;
            SXYSUM(i,j)=SXYSUM(i,j)+sxym(m)*wtmij;
            WTSUM(i,j)=WTSUM(i,j)+wtmij;
        end
        % i+1,j Node
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            ETASUM(i+1,j)=ETASUM(i+1,j)+etam(tm(m))*wtmi1j;
            MIUSUM(i+1,j)=MIUSUM(i+1,j)+1/gggm(tm(m))*wtmi1j;
            SXYSUM(i+1,j)=SXYSUM(i+1,j)+sxym(m)*wtmi1j;
            WTSUM(i+1,j)=WTSUM(i+1,j)+wtmi1j;
        end
        % i,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            ETASUM(i,j+1)=ETASUM(i,j+1)+etam(tm(m))*wtmij1;
            MIUSUM(i,j+1)=MIUSUM(i,j+1)+1/gggm(tm(m))*wtmij1;
            SXYSUM(i,j+1)=SXYSUM(i,j+1)+sxym(m)*wtmij1;
            WTSUM(i,j+1)=WTSUM(i,j+1)+wtmij1;
        end
        % i+1,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            ETASUM(i+1,j+1)=ETASUM(i+1,j+1)+etam(tm(m))*wtmi1j1;
            MIUSUM(i+1,j+1)=MIUSUM(i+1,j+1)+1/gggm(tm(m))*wtmi1j1;
            SXYSUM(i+1,j+1)=SXYSUM(i+1,j+1)+sxym(m)*wtmi1j1;
            WTSUM(i+1,j+1)=WTSUM(i+1,j+1)+wtmi1j1;
        end   
        % Interpolation to vx-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xvx(j);
        dis_y=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        RHOXSUM(i,j)=RHOXSUM(i,j)+rhom(tm(m))*wtmij;
        KXSUM(i,j)=KXSUM(i,j)+km(tm(m))*wtmij;
        WTXSUM(i,j)=WTXSUM(i,j)+wtmij;
        % i+1,j Node
        RHOXSUM(i+1,j)=RHOXSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        KXSUM(i+1,j)=KXSUM(i+1,j)+km(tm(m))*wtmi1j;
        WTXSUM(i+1,j)=WTXSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        RHOXSUM(i,j+1)=RHOXSUM(i,j+1)+rhom(tm(m))*wtmij1;
        KXSUM(i,j+1)=KXSUM(i,j+1)+km(tm(m))*wtmij1;
        WTXSUM(i,j+1)=WTXSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        RHOXSUM(i+1,j+1)=RHOXSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        KXSUM(i+1,j+1)=KXSUM(i+1,j+1)+km(tm(m))*wtmi1j1;
        WTXSUM(i+1,j+1)=WTXSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation to vy-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xvy(j);
        dis_y=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        RHOYSUM(i,j)=RHOYSUM(i,j)+rhom(tm(m))*wtmij;
        KYSUM(i,j)=KYSUM(i,j)+km(tm(m))*wtmij;
        WTYSUM(i,j)=WTYSUM(i,j)+wtmij;
        % i+1,j Node
        RHOYSUM(i+1,j)=RHOYSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        KYSUM(i+1,j)=KYSUM(i+1,j)+km(tm(m))*wtmi1j;
        WTYSUM(i+1,j)=WTYSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        RHOYSUM(i,j+1)=RHOYSUM(i,j+1)+rhom(tm(m))*wtmij1;
        KYSUM(i,j+1)=KYSUM(i,j+1)+km(tm(m))*wtmij1;
        WTYSUM(i,j+1)=WTYSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        RHOYSUM(i+1,j+1)=RHOYSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        KYSUM(i+1,j+1)=KYSUM(i+1,j+1)+km(tm(m))*wtmi1j1;
        WTYSUM(i+1,j+1)=WTYSUM(i+1,j+1)+wtmi1j1;
        % Interpolation to P-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            ETAPSUM(i,j)=ETAPSUM(i,j)+etam(tm(m))*wtmij;
            MIUPSUM(i,j)=MIUPSUM(i,j)+1/gggm(tm(m))*wtmij;
            SXXSUM(i,j)=SXXSUM(i,j)+sxxm(m)*wtmij;
            RHOSUM(i,j)=RHOSUM(i,j)+rhom(tm(m))*wtmij;
            RHOCPSUM(i,j)=RHOCPSUM(i,j)+rhocpm(tm(m))*wtmij;
            ALPHASUM(i,j)=ALPHASUM(i,j)+alpham(tm(m))*wtmij;
            HRSUM(i,j)=HRSUM(i,j)+hrm(tm(m))*wtmij;
            TKSUM(i,j)=TKSUM(i,j)+tkm(m)*rhocpm(tm(m))*wtmij;
            WTPSUM(i,j)=WTPSUM(i,j)+wtmij;
        end
        % i+1,j Node
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            ETAPSUM(i+1,j)=ETAPSUM(i+1,j)+etam(tm(m))*wtmi1j;
            MIUPSUM(i+1,j)=MIUPSUM(i+1,j)+1/gggm(tm(m))*wtmi1j;
            SXXSUM(i+1,j)=SXXSUM(i+1,j)+sxxm(m)*wtmi1j;
            RHOSUM(i+1,j)=RHOSUM(i+1,j)+rhom(tm(m))*wtmi1j;
            RHOCPSUM(i+1,j)=RHOCPSUM(i+1,j)+rhocpm(tm(m))*wtmi1j;
            ALPHASUM(i+1,j)=ALPHASUM(i+1,j)+alpham(tm(m))*wtmi1j;
            HRSUM(i+1,j)=HRSUM(i+1,j)+hrm(tm(m))*wtmi1j;
            TKSUM(i+1,j)=TKSUM(i+1,j)+tkm(m)*rhocpm(tm(m))*wtmi1j;
            WTPSUM(i+1,j)=WTPSUM(i+1,j)+wtmi1j;
        end
        % i,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            ETAPSUM(i,j+1)=ETAPSUM(i,j+1)+etam(tm(m))*wtmij1;
            MIUPSUM(i,j+1)=MIUPSUM(i,j+1)+1/gggm(tm(m))*wtmij1;
            SXXSUM(i,j+1)=SXXSUM(i,j+1)+sxxm(m)*wtmij1;
            RHOSUM(i,j+1)=RHOSUM(i,j+1)+rhom(tm(m))*wtmij1;
            RHOCPSUM(i,j+1)=RHOCPSUM(i,j+1)+rhocpm(tm(m))*wtmij1;
            ALPHASUM(i,j+1)=ALPHASUM(i,j+1)+alpham(tm(m))*wtmij1;
            HRSUM(i,j+1)=HRSUM(i,j+1)+hrm(tm(m))*wtmij1;
            TKSUM(i,j+1)=TKSUM(i,j+1)+tkm(m)*rhocpm(tm(m))*wtmij1;
            WTPSUM(i,j+1)=WTPSUM(i,j+1)+wtmij1;
        end
        % i+1,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            ETAPSUM(i+1,j+1)=ETAPSUM(i+1,j+1)+etam(tm(m))*wtmi1j1;
            MIUPSUM(i+1,j+1)=MIUPSUM(i+1,j+1)+1/gggm(tm(m))*wtmi1j1;
            SXXSUM(i+1,j+1)=SXXSUM(i+1,j+1)+sxxm(m)*wtmi1j1;
            RHOSUM(i+1,j+1)=RHOSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
            RHOCPSUM(i+1,j+1)=RHOCPSUM(i+1,j+1)+rhocpm(tm(m))*wtmi1j1;
            ALPHASUM(i+1,j+1)=ALPHASUM(i+1,j+1)+alpham(tm(m))*wtmi1j1;
            HRSUM(i+1,j+1)=HRSUM(i+1,j+1)+hrm(tm(m))*wtmi1j1;
            TKSUM(i+1,j+1)=TKSUM(i+1,j+1)+tkm(m)*rhocpm(tm(m))*wtmi1j1;
            WTPSUM(i+1,j+1)=WTPSUM(i+1,j+1)+wtmi1j1;
        end
    end
    % Computing the value of density and viscosity of BASIC-NODE. 
    for j = 1:1:Nx
        for i = 1:1:Ny
            if(WTSUM(i,j)>0)
                % Not need RHO on the basic nodes.Just Y nodes.
                ETA(i,j) = ETASUM(i,j)/WTSUM(i,j);%etaVp = eta in viscosity-elastic matreials.
                MIU(i,j) = WTSUM(i,j)/MIUSUM(i,j);
                sxy0(i,j) = SXYSUM(i,j)/WTSUM(i,j);
            end
        end
    end
    % Computing Density and K value at the VY and VX-nodes.
    for j=1:1:Nx1
        for i=1:1:Ny1
            % VY-nodes:(Nx1 * Ny) absent Ny1=0 !!!
            if(WTYSUM(i,j)>0)
                % rou_v
                RHOVY(i,j)=RHOYSUM(i,j)/WTYSUM(i,j);
                % K_v
                KVY(i,j)=KYSUM(i,j)/WTYSUM(i,j);
            end
            % VX-nodes:(Nx * Ny1)absent Nx1=0 !!!
            if(WTXSUM(i,j)>0)
                % rou_h
                RHOVX(i,j)=RHOXSUM(i,j)/WTXSUM(i,j);
                % K_h
                KVX(i,j) = KXSUM(i,j)/WTXSUM(i,j);
            end
        end
    end
    % Computing properities at P-node
    for j = 1:1:Nx1
        for i = 1:1:Ny1
            if(WTPSUM(i,j)>0)
                ETAP(i,j) = ETAPSUM(i,j)/WTPSUM(i,j);%etaVP = eta in viscosity-elastic materials.
                MIUP(i,j) = WTPSUM(i,j)/MIUPSUM(i,j);
                SXX0(i,j) = SXXSUM(i,j)/WTPSUM(i,j);
                RHOP(i,j) = RHOSUM(i,j)/WTPSUM(i,j);
                Hrij(i,j) = HRSUM(i,j)/WTPSUM(i,j);
                Aefij(i,j) = ALPHASUM(i,j)/WTPSUM(i,j);
                RHOPCP(i,j) = RHOCPSUM(i,j)/WTPSUM(i,j);%Den*Cp
                T0(i,j)  = TKSUM(i,j)/RHOCPSUM(i,j);%T
            end
        end
    end
    % Why??
    % Apply boundary condition after interpolate T0 from markers(any t).
    % Upper boundary
    T0(1,2:Nx)=2*273-T0(2,2:Nx); % Constant temperature
    % Lower boundary
    T0(Ny1,2:Nx)=2*1500-T0(Ny,2:Nx); % Constant temperature
    % Left boundary
    T0(:,1)=T0(:,2); % Insulating boundary
    % Right boundary
    T0(:,Nx1)=T0(:,Nx); % Insulating boundary
    % Mechanical Solution
    for i=2:1:Ny
        for j=2:1:Nx
            ETAP(i,j)=1/((1/ETA(i-1,j-1)+1/ETA(i,j-1)+1/ETA(i-1,j)+1/ETA(i,j))/4);
        end
    end
    % Solve Stokes-equ and Continuity-equ.
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global indexes in algebraic space
            kvx=((j-1)*Ny1+i-1)*3+1; % Vx
            kvy=kvx+1; % Vy
            kpm=kvx+2; % P
            
            % Vx equation External points
            if(i==1 || i==Ny1 || j==1 || j==Nx || j==Nx1)
                % Boundary Condition
                % 1*Vx=0
                coe(kvx,kvx)=1; % Left part
                R(kvx)=0; % Right part
                % Top boundary
                if(i==1 && j>1 && j<Nx)
                    coe(kvx,kvx+3)=bc_top; % Left part
                end
                % Bottom boundary
                if(i==Ny1 && j>1 && j<Nx)
                    coe(kvx,kvx-3)=bc_bottom; % Left part
                end
            else
                % Internal points: x-Stokes eq.
                % ETA*(d2Vx/dx^2+d2Vx/dy^2)-dP/dx=0
                %            Vx2
                %             |
                %        Vy1  |  Vy3
                %             |
                %     Vx1-P1-Vx3-P2-Vx5
                %             |
                %        Vy2  |  Vy4
                %             |
                %            Vx4
                %
                % Density gradients
                dRHOdx=(RHOVX(i,j+1)-RHOVX(i,j-1))/2/dx;
                dRHOdy=(RHOVX(i+1,j)-RHOVX(i-1,j))/2/dy;
                % Modify parameters
                ETAPMIU2 = dt*MIUP(i,j+1)*ETAP(i,j+1)/(MIUP(i,j+1)*dt+ETAP(i,j+1));
                ETAPMIU1 = dt*MIUP(i,j)*ETAP(i,j)/(MIUP(i,j)*dt+ETAP(i,j));                
                ETAMIU1 =  dt*MIU(i-1,j)*ETA(i-1,j)/(MIU(i-1,j)*dt+ETA(i-1,j));
                ETAMIU2 =  dt*MIU(i,j)*ETA(i,j)/(MIU(i,j)*dt+ETA(i,j));
                % Stress
                SXX2 = SXX0(i,j+1)*ETAP(i,j+1)/(MIUP(i,j+1)*dt+ETAP(i,j+1));
                SXX1 = SXX0(i,j)*ETAP(i,j)/(MIUP(i,j)*dt+ETAP(i,j));      
                SXY2 = sxy0(i,j)*ETA(i,j)/(MIU(i,j)*dt+ETA(i,j));
                SXY1 = sxy0(i-1,j)*ETA(i-1,j)/(MIU(i-1,j)*dt+ETA(i-1,j));
                % Left part
                coe(kvx,kvx-Ny1*3)=2*ETAPMIU1/dx^2  ; % Vx1(i,j-1)
                coe(kvx,kvx-3)=ETAMIU1/dy^2          ; % Vx2(i-1,j)
                coe(kvx,kvx)=-2*(ETAPMIU2+ETAPMIU1)/dx^2 ...
                               -(ETAMIU2+ ETAMIU1) /dy^2 - gx*dt*dRHOdx; % Vx3(i,j)
                coe(kvx,kvx+3)=ETAMIU2/dy^2      ; % Vx4(i+1,j)
                coe(kvx,kvx+Ny1*3)=2*ETAPMIU2/dx^2    ; % Vx5(i,j+1)
                coe(kvx,kvy)      = -ETAMIU2/dy/dx -dRHOdy*gx*dt/4  ;  % Vy2(i,j)
                coe(kvx,kvy+Ny1*3)= ETAMIU2/dy/dx  -dRHOdy*gx*dt/4   ;  % Vy4(i,j+1)
                coe(kvx,kvy-3)    = ETAMIU1/dx/dy -dRHOdy*gx*dt/4  ;  % Vy1(i-1,j)
                coe(kvx,kvy+Ny1*3-3)= -ETAMIU1/dx/dy -dRHOdy*gx*dt/4  ;  % Vy3(i-1,j+1)
                coe(kvx,kpm)=Kcont/dx; % P1(i,j)
                coe(kvx,kpm+Ny1*3)=-Kcont/dx; % P2(i,j+1)

                % Right part !!!
                R(kvx)=-RHOVX(i,j)*gx -(SXX2-SXX1) /dx...
                                       -(SXY2-SXY1)/dy ;
            end
            
            % Vy equation External points
            if(j==1 || j==Nx1 || i==1 || i==Ny || i==Ny1)
                % Boundary Condition
                % 1*Vy=0
                coe(kvy,kvy)=1; % Left part
                R(kvy)=0; % Right part
                % Left boundary
                if(j==1 && i>1 && i<Ny)
                    coe(kvy,kvy+3*Ny1)=bc_left; % Left part
                end
                % Right boundary
                if(j==Nx1 && i>1 && i<Ny)
                    coe(kvy,kvy-3*Ny1)=bc_right; % Left part
                end
            else
                % Internal points: y-Stokes eq.
                % ETA*(d2Vy/dx^2+d2Vy/dy^2)-dP/dy=-RHO*gy
                %            Vy2
                %             |
                %         Vx1 P1 Vx3
                %             |
                %     Vy1----Vy3----Vy5
                %             |
                %         Vx2 P2 Vx4
                %             |
                %            Vy4
                %
                % Viscosity points
                dRHOdx=(RHOVY(i,j+1)-RHOVY(i,j-1))/2/dx;
                dRHOdy=(RHOVY(i+1,j)-RHOVY(i-1,j))/2/dy;
                ETAPMIU2 = 2*dt*MIUP(i+1,j)*ETAP(i+1,j)/(MIUP(i+1,j)*dt+ETAP(i+1,j));
                ETAPMIU1 = 2*dt*MIUP(i,j)*ETAP(i,j)/(MIUP(i,j)*dt+ETAP(i,j));
                ETAMIU1  = 2*dt*MIU(i,j-1)*ETA(i,j-1)/(MIU(i,j-1)*dt+ETA(i,j-1));
                ETAMIU2  = 2*dt*MIU(i,j)*ETA(i,j)/(MIU(i,j)*dt+ETA(i,j));        
                SYY2 = -SXX0(i+1,j)*ETAP(i+1,j)/(MIUP(i+1,j)*dt+ETAP(i+1,j));
                SYY1 = -SXX0(i,j)*ETAP(i,j)/(MIUP(i,j)*dt+ETAP(i,j));      
                SYX2 = sxy0(i,j)*ETA(i,j)/(MIU(i,j)*dt+ETA(i,j));
                SYX1 = sxy0(i,j-1)*ETA(i,j-1)/(MIU(i,j-1)*dt+ETA(i,j-1));
                % Left part
                coe(kvy,kvy-Ny1*3)=ETAMIU1/2/dx^2    ; % Vy1(i,j-1)
                coe(kvy,kvy-3)=ETAPMIU1/dy^2    ; % Vy2(i-1,j)
                coe(kvy,kvy)=-ETAPMIU1/dy^2-ETAPMIU2/dy^2 ...
                             -ETAMIU2/2/dx^2-ETAMIU1/2/dx^2 - dRHOdy*gy*dt; % Vy3(i,j)
                coe(kvy,kvy+3)=ETAPMIU2/dy^2   ; % Vy4(i+1,j)
                coe(kvy,kvy+Ny1*3)=ETAMIU2/2/dx^2   ; % Vy5(i,j+1)
                coe(kvy,kvx)= - ETAMIU2/2/dx/dy    -dRHOdx*gy*dt/4; %Vx3(i,j)
                coe(kvy,kvx+3)=  ETAMIU2/2/dx/dy   -dRHOdx*gy*dt/4; %Vx4(i+1,j)
                coe(kvy,kvx-Ny1*3)= ETAMIU1/2/dx/dy    -dRHOdx*gy*dt/4; %Vx1(i,j-1)
                coe(kvy,kvx+3-Ny1*3)= - ETAMIU1/2/dx/dy     -dRHOdx*gy*dt/4; %Vx2(i+1,j-1)
                coe(kvy,kpm)=Kcont/dy; % P1
                coe(kvy,kpm+3)=-Kcont/dy; % P2
                
                % Right part
                R(kvy)=-RHOVY(i,j)*gy - (SYY2-SYY1)/dy...
                                      - (SYX2-SYX1)/dx;
            end
            
            % P equation External points
            if(i==1 || j==1 || i==Ny1 || j==Nx1 ||...
                    (i==2 && j==2))
                % Boundary Condition
                % 1*P=0
                coe(kpm,kpm)=1; % Left part
                % Apply 108 Pa as the boundary condition for pressure.
                R(kpm)=0; % Right part  !!!
                % Real BC
                if(i==2 && j==2)
                    coe(kpm,kpm)=1*Kcont; %Left part
                    R(kpm)=1e9; % Right part !!!
                end
            else
                % Internal points: continuity eq.
                % dVx/dx+dVy/dy=0
                %            Vy1
                %             |
                %        Vx1--P--Vx2
                %             |
                %            Vy2
                %
                % Left part
                coe(kpm,kvx-Ny1*3)=-1/dx; % Vx1
                coe(kpm,kvx)=1/dx; % Vx2
                coe(kpm,kvy-3)=-1/dy; % Vy1
                coe(kpm,kvy)=1/dy; % Vy2
                % Right part
                R(kpm)=0;
            end
        end
    end
    % Computing the solution U:include vx,vy and p
     U = coe \ R;
    % Decompose the solution of global matrix. 
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global indexes in algebraic space
            kvx=((j-1)*Ny1+i-1)*3+1; % Vx
            kvy=kvx+1; % Vy
            kpm=kvx+2; % P
            % Reload solution
            vx(i,j)=U(kvx);
            vy(i,j)=U(kvy);
            p(i,j)=U(kpm)*Kcont;
        end
    end
    % Restrict the time step limiting max_marker_disp by 0.5 grid step
    % Define dtm for transport of markers.
    % Why dt*1.2??
    % Define displacement timestep dtm
    dt=dt*dtkoef;
    maxvx=max(max(abs(vx)));
    maxvy=max(max(abs(vy)));
    if(dt*maxvx>dxymax*dx)
        dt=dxymax*dx/maxvx;
    end
    if(dt*maxvy>dxymax*dy)
        dt=dxymax*dy/maxvy;
    end
    
    EXY = zeros(Ny,Nx);
    SXY = zeros(Ny,Nx);
    DSXY = zeros(Ny,Nx);
    % Computing strain rate(xy) and deviatoric(xy) stress components.
    for j = 1:1:Nx
        for i = 1:1:Ny
            %ETAVP = ETA,which plastic is absent.
            EXY(i,j) = (1/2)*( (vx(i+1,j)-vx(i,j))/dy ...
                             + (vy(i,j+1)-vy(i,j))/dx ) ;
            % srxy is strain rate,sxy is stressxy
            SXY(i,j) = 2*ETA(i,j)*EXY(i,j)  * (MIU(i,j)*dt/(MIU(i,j)*dt+ETA(i,j))) ...
                                  + sxy0(i,j) * (  ETA(i,j)/(MIU(i,j)*dt+ETA(i,j)));
            DSXY(i,j) = SXY(i,j) - sxy0(i,j);
        end
    end
    % Define second invariant value of stress and strain rate.
    EXX = zeros(Ny1,Nx1);
    SXX = zeros(Ny1,Nx1);
    EII = zeros(Ny1,Nx1);
    SII = zeros(Ny1,Nx1);
    DSXX = zeros(Ny1,Nx1);
    % Computing strain rate(xx) and deviatoric(xx) stress components.
    for j = 2:1:Nx
        for i = 2:1:Ny        
            % Note that exx is not the 1/2 item in the book.
            EXX(i,j) =  (vx(i,j)-vx(i,j-1))/dx;
            % srxx is strain rate,sxx is stressxx
            SXX(i,j) = 2*ETAP(i,j)*EXX(i,j) * (MIUP(i,j)*dt/(MIUP(i,j)*dt+ETAP(i,j))) ...
                                  + SXX0(i,j) * (  ETAP(i,j)/(MIUP(i,j)*dt+ETAP(i,j)));
            DSXX(i,j) = SXX(i,j) - SXX0(i,j);
            % The second invariant value.
            EII(i,j) = ( EXX(i,j)^2 + ((EXY(i-1,j)   + EXY(i,j-1) ...
                                  + EXY(i-1,j-1) + EXY(i,j))/4)^2 )^0.5;
            SII(i,j) = ( SXX(i,j)^2 + ((SXY(i-1,j)   + SXY(i,j-1) ...
                                  + SXY(i-1,j-1) + SXY(i,j))/4)^2 )^0.5;
        end
    end

    % Computing "STRESS" subgrid diffusion for markers
    if (subgrdifcoes>0)
        % Existence of subgrid diffusion.
        % Page162 How to correct the problem ?
        % operating  consistent subgrid diffusion .
        % Clear subgrid temperature changes(dTijsub) for nodes
        % P-NODES
        WPNODES = zeros(Ny1,Nx1);
        SXXSUM = zeros(Ny1,Nx1);
        % Basic-NODES        
        WNODES = zeros(Ny,Nx);
        SXYSUM = zeros(Ny,Nx);
        % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
        for m = 1:marknum
            % Interpolate T to P-NODES(Nx*Ny)
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            sxxm0nodal= SXX0(i,j)*wtmij + SXX0(i+1,j)*wtmi1j  ...
                +SXX0(i,j+1)*wtmij1 + SXX0(i+1,j+1)*wtmi1j1;
            j=fix((xm(m)-x(1))/dx)+1;
            i=fix((ym(m)-y(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-x(j);
            dis_y=ym(m)-y(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            sxym0nodal= sxy0(i,j)*wtmij + sxy0(i+1,j)*wtmi1j  ...
                +sxy0(i,j+1)*wtmij1 + sxy0(i+1,j+1)*wtmi1j1;
            % NOTE THAT the answer is sxxm(m)-sxxm0nodal.
            % Eq.10.14
            dsxxm0 = sxxm0nodal - sxxm(m);
            dsxym0 = sxym0nodal - sxym(m);
            % Page209
            tdiff = etam(tm(m))/gggm(tm(m));
            % Computing subgrid diffusion
            % Why??
            % dve = 0;%209,0<dve<1
            sdif=-0.5*dt/tdiff;
            if(sdif<-30)
                sdif=-30;
            end
            % Page162 Eq.10.16
            dsxxmsub=dsxxm0*(1-exp(sdif));
            dsxymsub=dsxym0*(1-exp(sdif));

            % Eq.10.19
            % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
            sxxm(m) = sxxm(m) + dsxxmsub;
            sxym(m) = sxym(m) + dsxymsub;
            % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
            % Eq.10.17
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                SXXSUM(i,j) = SXXSUM(i,j) + dsxxmsub*wtmij;
                WPNODES(i,j) = WPNODES(i,j) + wtmij;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                SXXSUM(i+1,j) = SXXSUM(i+1,j) + dsxxmsub*wtmi1j;
                WPNODES(i+1,j) = WPNODES(i+1,j) + wtmi1j;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                SXXSUM(i,j+1) = SXXSUM(i,j+1) + dsxxmsub*wtmij1;
                WPNODES(i,j+1) = WPNODES(i,j+1) + wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                SXXSUM(i+1,j+1) = SXXSUM(i+1,j+1) + dsxxmsub*wtmi1j1;
                WPNODES(i+1,j+1) = WPNODES(i+1,j+1) + wtmi1j1;
            end
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-x(1))/dx)+1;
            i=fix((ym(m)-y(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-x(j);
            dis_y=ym(m)-y(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                SXYSUM(i,j) = SXYSUM(i,j) + dsxymsub*wtmij;
                WNODES(i,j) = WNODES(i,j) + wtmij;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                SXYSUM(i+1,j) = SXYSUM(i+1,j) + dsxymsub*wtmi1j;
                WNODES(i+1,j) = WNODES(i+1,j) + wtmi1j;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                SXYSUM(i,j+1) = SXYSUM(i,j+1) + dsxymsub*wtmij1;
                WNODES(i,j+1) = WNODES(i,j+1) + wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                SXYSUM(i+1,j+1) = SXYSUM(i+1,j+1) + dsxymsub*wtmi1j1;
                WNODES(i+1,j+1) = WNODES(i+1,j+1) + wtmi1j1;
            end
        end
        dsxxijsub = zeros(Ny1,Nx1);
        dsxyijsub = zeros(Ny,Nx);
        % P-NODES
        for j=2:1:Nx
            for i=2:1:Ny
                if(WPNODES(i,j)>0)
                    dsxxijsub(i,j)=SXXSUM(i,j)/WPNODES(i,j);
                end
            end
        end
        % Basic nodes
        for j=1:1:Nx
            for i=1:1:Ny
                if(WNODES(i,j)>0)
                    dsxyijsub(i,j) = SXYSUM(i,j)/WNODES(i,j);
                end
            end
        end
        % Eq.10.18
        % Update dTij(dTij(remain) = dTij - dTij(sub)  )
        DSXX = DSXX - dsxxijsub;
        DSXY = DSXY - dsxyijsub;
    end
    % Interpolate L-markers(dTremain) from P-node(dsxxijremain)
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<2)
            j=2;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<2)
            i=2;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dsxxmremain= DSXX(i,j)  *wtmij  + DSXX(i+1,j)   *wtmi1j  ...
                   + DSXX(i,j+1)*wtmij1 + DSXX(i+1,j+1) *wtmi1j1;
        % "NOTE THAT" this discard interpolation of new stress SXX. 
        sxxm(m) = sxxm(m) + dsxxmremain;
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dsxymremain=DSXY(i,j)  *wtmij  + DSXY(i+1,j)  *wtmi1j  ...
                   +DSXY(i,j+1)*wtmij1 + DSXY(i+1,j+1)*wtmi1j1;
        % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
        % Eq.10.19
        sxym(m) = sxym(m) + dsxymremain;
    end
    
    Hsij = zeros(Ny1,Nx1);
    for j = 2:1:Nx
        for i = 2:1:Ny   
            pxyxy = (1/4)*( SXY(i,j)^2/ETA(i,j)   + SXY(i-1,j)^2/ETA(i-1,j)...
                          + SXY(i,j-1)/ETA(i,j-1) + SXY(i-1,j-1)/ETA(i-1,j-1));
            % Shear heating Hs
            Hsij(i,j) = SXX(i,j)^2/ETAP(i,j)+ pxyxy;
        end
    end
    Haij = zeros(Ny1,Nx1);
    % Adiabatic heating Ha
    for j = 2:1:Nx
        for i = 2:1:Ny
            kvy = ( vy(i,j)+vy(i-1,j) )/2;
            kvx = ( vx(i,j)+vx(i,j-1) )/2;
            Haij(i,j) = T0(i,j)*Aefij(i,j)*RHOP(i,j)*(gy*kvy+gx*kvx);
        end
    end

    % Solve temperature equation.
    % Preliminary dtm to define possible temperature changes.3
    for titer = 1:1:4
        % Insulating boundary condition.
        % Up and down
        for j=1:1:Nx1
            for i=1:1:Ny1
                % Define global index in algebraic space
                kt=(j-1)*Ny1+i;
                % External points
                if(i==1 || i==Ny1 || j==1 || j==Nx1)
                    % Boundary Condition
                    % Top BC: T=273
                    if(i==1 && j>1 && j<Nx1)
                        coet(kt,kt)=1; % Left part
                        coet(kt,kt+1)=1; % Left part
                        bt(kt)=273*2; % Right part
                    end
                    % Bottom BC: T=1500
                    if(i==Ny1 && j>1 && j<Nx1)
                        coet(kt,kt)=1; % Left part
                        coet(kt,kt-1)=1; % Left part
                        bt(kt)=1500*2; % Right part
                    end
                    % Left BC: dT/dx=0
                    if(j==1)
                        coet(kt,kt)=1; % Left part
                        coet(kt,kt+Ny1)=-1; % Left part
                        bt(kt)=0; % Right part
                    end
                    % Right BC: dT/dx=0
                    if(j==Nx1)
                        coet(kt,kt)=1; % Left part
                        coet(kt,kt-Ny1)=-1; % Left part
                        bt(kt)=0; % Right part
                    end
                else
                    % Internal points: Temperature eq.
                    % Left part
                    % KVX == Kh;KVY == Kv
                    khij  = KVX(i,j);
                    khij1 = KVX(i,j-1);
                    kvij  = KVY(i,j);
                    kvi1j = KVY(i-1,j);
                    % Not 2* why?? page177
                    coet(kt, kt) = (khij+khij1)/dx^2+RHOPCP(i,j)/dt...
                                  +(kvij+kvi1j)/dy^2;% middle T3 i,j
                    coet(kt, kt-1) = -(kvi1j)/(2.*dy.^2); % up T2 i-1,j
                    coet(kt, kt+1) = -(kvij)/(2.*dy.^2); % down T4 i+1,j
                    coet(kt, kt-Ny1) = -(khij1)/(dx.^2); % left T1 i,j-1
                    coet(kt, kt+Ny1) = -(khij)/(dx.^2); % right T5 i,j+1
                    % !!!Note that there are not advection term because MIC have
                    % marker transport.!!!
                    % Adding H(P-nodes)
                    bt(kt, 1) = T0(i,j)*RHOPCP(i,j)/dt + Hrij(i,j) + Haij(i,j) + Hsij(i,j);
                end
            end
        end

        %direct method:right martix is divided by coe martix on the left
        u = coet \ bt;
        % transform vector to grids
        % U has Ny1 rows and Nx1 columns
        U = reshape(u, Ny1, Nx1);
        T1 = U;
        % Computing dTi,j = dTi,j(subgrid) + dTi,j(remaining)
        % Eq10.13
        dTij = T1-T0;
        % Adjust dt for must condition:DTmax,and max number of iteration 
        % is 2  
        % Define dtT for temperature equation.
        % dtT <= dtm(markers_t instead of stokes_t, visible in LINE-727)
        maxDTcurrent = max(max(abs(dTij)));
        if(titer<4 && maxDTcurrent>DTmax)
            dt=dt/maxDTcurrent*DTmax;
        else
            break;
        end
    end
    % "NOTE" that tk0==tk1 in the answer.
    dTij = T1-T0;
    % Computing subgrid diffusion for markers
    if (subgrdifcoet>0)
        % Existence of subgrid diffusion.
        % Page162 How to correct the problem ?
        % operating  consistent subgrid diffusion .
        % Clear subgrid temperature changes(dTijsub) for nodes
        % From marker to P-NODES
        WPNODES = zeros(Ny1,Nx1);
        WDTM = zeros(Ny1,Nx1);
        % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
        for m = 1:marknum
            % Interpolate T to P-NODES(Nx*Ny)
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            Tm0nodal= T0(i,j)*wtmij + T0(i+1,j)*wtmi1j  ...
                +T0(i,j+1)*wtmij1 + T0(i+1,j+1)*wtmi1j1;
            % Eq.10.14
            dTm = Tm0nodal - tkm(m);
            % Page163
            tdiff = rhocpm(tm(m))/(km(tm(m))*(2/dx^2+2/dy^2));
            % Computing subgrid diffusion
            % Why??
            sdif=-1*dt/tdiff;
            % That's discard below code.
            if(sdif<-30)
                sdif=-30;
            end
            % Page162 Eq.10.16
            dTmsub=dTm*(1-exp(sdif));
            % Eq.10.19
            % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
            tkm(m) = tkm(m) + dTmsub;
            % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
            % Eq.10.17
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                WDTM(i,j) = WDTM(i,j) + dTmsub*rhocpm(tm(m))*wtmij;
                WPNODES(i,j) = WPNODES(i,j) + rhocpm(tm(m))*wtmij;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                WDTM(i+1,j) = WDTM(i+1,j) + dTmsub*rhocpm(tm(m))*wtmi1j;
                WPNODES(i+1,j) = WPNODES(i+1,j) + rhocpm(tm(m))*wtmi1j;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                WDTM(i,j+1) = WDTM(i,j+1) + dTmsub*rhocpm(tm(m))*wtmij1;
                WPNODES(i,j+1) = WPNODES(i,j+1) + rhocpm(tm(m))*wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                WDTM(i+1,j+1) = WDTM(i+1,j+1) + dTmsub*rhocpm(tm(m))*wtmi1j1;
                WPNODES(i+1,j+1) = WPNODES(i+1,j+1) + rhocpm(tm(m))*wtmi1j1;
            end
        end
        dTijsub = zeros(Ny1,Nx1);
        for j = 1:Nx1
            for i = 1:Ny1
                if(WPNODES(i,j)>0)
                    % Compting dTijsub
                    % Eq.10.17
                    dTijsub(i,j) = WDTM(i,j)/WPNODES(i,j);
                end
            end
        end
        % Eq.10.18
        % Update dTij(dTij(remain) = dTij - dTijsub)
        dTij = dTij - dTijsub;
    end
    % Interpolate L-markers(dTremain) from P-node(dTijremain)
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dTmremain=dTij(i,j)  *wtmij  + dTij(i+1,j)  *wtmi1j  ...
                 +dTij(i,j+1)*wtmij1 + dTij(i+1,j+1)*wtmi1j1;
        % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
        % Eq.10.19            
        tkm(m) = tkm(m) + dTmremain;
        if(t==1)
            % Interpolate new temperature for the 1st timestep
            tkm(m) = T1(i,j)*wtmij + T1(i+1,j)*wtmi1j  ...
                    +T1(i,j+1)*wtmij1 + T1(i+1,j+1)*wtmi1j1;
        end
    end
    
    % Computing Vx/Vy at the P-nodes
    for j = 2:1:Nx
        for i = 2:1:Ny
            %  Computing internal Vx and Vy at the P nodes.
            % Vx at internal(P) nodes.
            pvx(i,j) = ( vx(i,j) + vx(i,j-1) )./2;
            % Vy at internal nodes.
            pvy(i,j) = ( vy(i,j) + vy(i-1,j) )./2;
        end
    end
    % Vx
    % Top
    pvx(1,2:Nx-1)=-bc_top*pvx(2,2:Nx-1);
    % Bottom
    pvx(Ny1,2:Nx-1)=-bc_bottom*pvx(Ny,2:Nx-1);
    % Left
    pvx(:,1)=-pvx(:,2);
    % Right
    pvx(:,Nx1)=-pvx(:,Nx);
    % Vy
    % Left
    pvy(2:Ny-1,1)=-bc_left*pvy(2:Ny-1,2);
    % Right
    pvy(2:Ny-1,Nx1)=-bc_right*pvy(2:Ny-1,Nx); % Free slip
    % Top
    pvy(1,:)=-pvy(2,:);
    % Bottom
    pvy(Ny1,:)=-pvy(Ny,:);

    % Rotate stress by Analytical formulas.
    for j = 1:1:Nx
        for i = 1:1:Ny
            % Computing rotation value.
            wyx(i,j) = (1/2)*( (vy(i,j+1)-vy(i,j))/dx ...
                             - (vx(i+1,j)-vx(i,j))/dy ) ;
        end
    end

    % The classical Runge-Kutta scheme,Fourth-order in sapce First-order in time
    % Define Vxa(Vya)1,Vxb(Vyb)2,Vxc(Vyc)3,Vxd(Vyd)4.
    vxm=zeros(4,1);
    vym=zeros(4,1);
    % Interpolate vx and vy components from E-nodes to L-markers.
    for m=1:1:marknum
        % Computing wm and rotate stress.
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Compute vxm and vym velocity
        wm = wyx(i,j)*wtmij+wyx(i+1,j)*wtmi1j...
           + wyx(i,j+1)*wtmij1+wyx(i+1,j+1)*wtmi1j1;
        angleAB = wm*dt;
        sxymnew = sxxm(m)*sin(2*angleAB)+sxym(m)*cos(2*angleAB);
        sxxmnew = sxxm(m)*cos(angleAB)^2 - sxxm(m)*sin(angleAB)^2-sxym(m)*sin(2*angleAB) ;
        sxym(m) = sxymnew;
        sxxm(m) = sxxmnew;
        % Reserve original coordinate.
        xa = xm(m);
        ya = ym(m);
        for rk = 1:1:4
            % Interpolate vx-p and vy-p from P-staggered nodes to L-markers.
            % P staggered nodes.(Nx1 * Ny1)
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vxm and vym velocity
            vxm(rk) = pvx(i,j)*wtmij    + pvx(i+1,j)*wtmi1j...
                     +pvx(i,j+1)*wtmij1 + pvx(i+1,j+1)*wtmi1j1;
            vym(rk) = pvy(i,j)*wtmij    + pvy(i+1,j)*wtmi1j...
                     +pvy(i,j+1)*wtmij1 + pvy(i+1,j+1)*wtmi1j1;
            % Interpolate vx from Vx-staggered nodes to L-markers.
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvx(1))/dx)+1;
            i=fix((ym(m)-yvx(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            % Vx staggered nodes.(Nx * Ny+1)
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xvx(j);
            dis_y=ym(m)-yvx(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vx velocity
            vxm(rk) = (1/3)*vxm(rk) + (2/3)*(vx(i,j)*wtmij+vx(i+1,j)*wtmi1j...
                                           + vx(i,j+1)*wtmij1+vx(i+1,j+1)*wtmi1j1);
            % Interpolate vy
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvy(1))/dx)+1;
            i=fix((ym(m)-yvy(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-xvy(j);
            dis_y=ym(m)-yvy(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vx velocity
            vym(rk) = (1/3)*vym(rk) + (2/3)*(vy(i,j)*wtmij+vy(i+1,j)*wtmi1j...
                     +vy(i,j+1)*wtmij1+vy(i+1,j+1)*wtmi1j1); 
                 
            if(rk == 1 || rk == 2)
                xm(m) = vxm(rk)*dt/2 + xa;
                ym(m) = vym(rk)*dt/2 + ya;
            elseif(rk == 3)
                xm(m) = vxm(rk)*dt + xa;
                ym(m) = vym(rk)*dt + ya;
            end
        end
        % Return original coordinate.
        xm(m) = xa;
        ym(m) = ya;
        % Move markers with effective velocity field.
        vxefft = (1/6)*(vxm(1)+2*vxm(2)+2*vxm(3)+vxm(4));
        vyefft = (1/6)*(vym(1)+2*vym(2)+2*vym(3)+vym(4));        
        xm(m)=xm(m)+dt*vxefft;
        ym(m)=ym(m)+dt*vyefft;
    end
    % Sum of time.
    timesum=timesum+dt;
    % Figure at every 20 timesteps.
    % Figure
    subplot(1,3,1);
    colormap('Jet');
    pcolor(x,y,log10(ETA));
    hold on;
    %P nodes:(Nx1 * Ny1).
    quiver(xp(1:2:Nx1),yp(1:2:Ny1),pvx(1:2:Ny1,1:2:Nx1),pvy(1:2:Ny1,1:2:Nx1),'w')
    xlabel('Horizontal(m)')
    ylabel('Vertical(m)')
    caxis([17 21]);
    set(gca,'xaxislocation','top');
    set (gca,'YDir','reverse')
    shading interp;
    axis ij image;
    colorbar
    title(['log10(ETA) after ',num2str(t),' deltat'])
    % Ha
    subplot(1,3,2);
    colormap('Jet');
    pcolor(xp,yp,Hrij);
    xlabel('Horizontal(m)')
    ylabel('Vertical(m)')
    set(gca,'xaxislocation','top');
    set (gca,'YDir','reverse')
    shading interp;
    colorbar;
    axis ij image;
    title(['Ha after ',num2str(t),' deltat'])
    subplot(1,3,3);
    pcolor(xp,yp,T1);colorbar;
    xlabel('Horizontal(Km)');
    ylabel('Vertical(Km)');
    zlabel('Gravitational potential');
    title(['(Ibc)(MIC) Temperature after',num2str(t),' deltat'])
    set(gca,'xaxislocation','top');
    set (gca,'YDir','reverse')
    axis ij image;
    shading interp;
    pause(0.01);
end
