% Global visco-elasto-plastic iterations on "Eulerian-NODE".
% THE KEY OF PROGRAM：
% LINE166,LINE488,LINE152-LINE160,LINE482-487,LINE753-LINE860
% LOOPSTART491,LOOPEND862
% 无论对欧拉点还是拉格朗日标记进行全局循环都会再次解stokes equation
% 但前者不需要在每次迭代重新更新标记特性，除非进入了下一个timestep。
clear all;clf;
aaaa = 0;
% Set parameters
% Length of model
Lx = 100000; 
Ly = 100000;
x_mid = Lx/2;
y_mid = Ly/2;
% Sum of point number of model
Nx = 101; 
Ny = 101; 
Nx1 = Nx+1;
Ny1 = Ny+1;
% Interval of E-staggered-nodes
dx = Lx / (Nx-1);
dy = Ly / (Ny-1);
% Basic nodes.
x = 0:dx:Lx;
y = 0:dy:Ly;
% Vx staggered nodes.(Nx_node * Ny_node+1)
xvx = 0:dx:Lx+dx;
yvx = -dy/2 : dy : Ly+dy/2;
% Vy staggered nodes.(Nx_node+1 * Ny_node)
xvy = -dx/2 : dx : Lx+dx/2;
yvy = 0:dy:Ly+dy;
% P staggered nodes.(Nx_node+1 * Ny_node+1)
xp = -dx/2 : dx : Lx+dx/2;
yp = -dy/2 : dy : Ly+dy/2;

% Velocity and Pressure matrix
% Vx NODE
vx = zeros(Ny1,Nx1);
RHOVX=zeros(Ny1,Nx1); 
KVX=zeros(Ny1,Nx1); 
% Vy NODE
vy = zeros(Ny1,Nx1);
RHOVY=zeros(Ny1,Nx1); 
KVY=zeros(Ny1,Nx1); 
% P NODE
p = zeros(Ny1,Nx1);
ETAPVP = zeros(Ny1,Nx1);
GGGP = zeros(Ny1,Nx1);
RHOP = zeros(Ny1,Nx1);
RHOPCP = zeros(Ny1,Nx1); %Den*Cp(hct)
Hrij = zeros(Ny1,Nx1);
Haij = zeros(Ny1,Nx1);
Hsij = zeros(Ny1,Nx1);
Aefij = zeros(Ny1,Nx1);
EXX=zeros(Ny1,Nx1); % EPSILONxx, 1/s
SXX=zeros(Ny1,Nx1); % SIGMA'xx, 1/s
SXX0 = zeros(Ny1,Nx1);
T0 = zeros(Ny1,Nx1); %Told
T1 = zeros(Ny1,Nx1); %Tnew
    % vx/vy at pnodes
pvx = zeros(Ny1,Nx1);
pvy = zeros(Ny1,Nx1);
% Gravity acceleration
gy = 0;
gx = 0;
% Basic node
ETAVP = zeros(Ny,Nx);
GGG = zeros(Ny,Nx);
EXY = zeros(Ny,Nx);
SXY = zeros(Ny,Nx);
sxy0 = zeros(Ny,Nx);
wyx = zeros(Ny,Nx);
ETA = zeros(Ny,Nx);
FRICT = zeros(Ny,Nx);
COSHE = zeros(Ny,Nx);
% Stokes-equ and continuity-equ
% Temperature-equ
% Amount of markers.
Nxm = 4*(Nx-1);
Nym = 4*(Ny-1);
marknum=Nxm*Nym;
% Step-length among L-marker points
dxm = Lx/Nxm;
dym = Ly/Nym;
% Marker points.
% Stokes-equ and continuity-equ
xm=zeros(1,marknum); % Horizontal coordinates, m
ym=zeros(1,marknum);
sxxm = zeros(1,marknum);
sxym = zeros(1,marknum);
etavpm = zeros(1,marknum);
tkm = zeros(1,marknum); % temperature
tm = zeros(1,marknum);

% Parameters
rhom   = [3300   3200   1     ]; % Density, kg/m^3
etam   = [1e+23  1e+17  1e+17 ]; % Viscosity, Pa s
rhocpm = [3.3e+6 3.2e+6 3.3e+6]; % Volumetric heat capacity, kg/m^3
alpham = [3e-5   2e-5   0     ]; % Thermal expansion, 1/K
km     = [3      2      3000  ]; % Thermal conductivity, W/m/K
hrm    = [2e-8   3e-8   0     ]; % Radiogenic heat production, W/m^3
gggm   = [1e+11  1e+11  1e+11 ]; % Shear Modulus, Pa
frictm = [0.6    0      0     ]; % Friction coefficient
coshesm = [1e+8   1e+7   1e+7  ]; % Cohesion, Pa (SeiGeMa_c)
m = 1;
for jm=1:1:Nxm
    for im=1:1:Nym
        % Define marker coordinates
        xm(m)=dxm/2+(jm-1)*dxm+(rand-0.5)*dxm;
        ym(m)=dym/2+(im-1)*dym+(rand-0.5)*dym;
        % Marker properties
        % "Strong Block(Mantle)" 
        tm(m) = 1;
        % "Squared inclusion(plume)"
        if(abs(xm(m)-x_mid)<5000 && abs(ym(m)-y_mid)<5000)
            tm(m) = 2;
        end
        % "Weak medium(striky)"
        if(ym(m)<0.2*Ly || ym(m)>0.8*Ly)
            tm(m) = 3;
        end
        tkm(m) = 273;
        etavpm(m) = etam(tm(m));
        % Update marker counter
        m=m+1;
    end
end

%WHY???
Kcont = 1e+21/dx;

% Define matrix for Stokes
unknowns = Nx1*Ny1*3;
R  =   zeros(unknowns, 1);
coe = sparse(unknowns,unknowns);
% Define matrix for T
unknowns = Nx1*Ny1;
bt = zeros(unknowns,1);
coet = sparse(unknowns, unknowns);
 
% Boundary condition : free slip = -1 ; no slip = 1
bc_left   = -1;
bc_right  = -1;
bc_top    = -1;
bc_bottom = -1;
vxleft   = 5e-9;
vxright  = -5e-9;
vytop    = -5e-9;
vybottom = 5e-9;
YYN = zeros(Ny,Nx);
 
% Define dt for stokes equation.
dtelastic = 0.5e+8; % initial timestep
dt = dtelastic;
dxymax   = 0.001;   
timesum = 0;
Nt = 400;
nloop=100000;
yerrmax =  3e+5;
dtstep = 200;
YIELDERRNODAL=zeros(1,nloop);
AAAAA=zeros(1,Nt);
minetavpm = 1e+17;
maxetavpm = 1e+23;
DTmax=20; % max temperature change per time step, K
subgrdifcoes = 0;
subgrdifcoet = 0;
t = 1;
for t = t:1:Nt     
    
% Save old stresses
sxxm00=sxxm; 
sxym00=sxym;


    % BASCI NODE
    WTSUM = zeros(Ny,Nx);
    ETAVPSUM = zeros(Ny,Nx);
    GGGSUM = zeros(Ny,Nx);
    SXYSUM = zeros(Ny,Nx);
    ETASUM = zeros(Ny,Nx);
    FRICTSUM = zeros(Ny,Nx);
    COSHESUM = zeros(Ny,Nx);
    % Vx nodes    
    RHOXSUM=zeros(Ny1,Nx1);
    WTXSUM=zeros(Ny1,Nx1);
    KXSUM=zeros(Ny1,Nx1);
    % Vy nodes    
    RHOYSUM=zeros(Ny1,Nx1);
    WTYSUM=zeros(Ny1,Nx1);
    KYSUM=zeros(Ny1,Nx1);
    %Pnodes
    WTPSUM = zeros(Ny1,Nx1);% weights except T
    ETAPVPSUM = zeros(Ny1,Nx1);% Viscosity at P node
    SXXSUM = zeros(Ny1,Nx1);
    GGGPSUM = zeros(Ny1,Nx1);% miu at P node
    RHOSUM = zeros(Ny1,Nx1);% Density at P node
    HRSUM = zeros(Ny1,Nx1);  % Hr at P node
    ALPHASUM = zeros(Ny1,Nx1); % Aef at P node
    RHOCPSUM = zeros(Ny1,Nx1);% Den*Cp at P node
    TKSUM = zeros(Ny1,Nx1); % T at P node
    
    % Interpolate viscosity from markers to BASIC NODES.
    % Searching the coordinate of upper-left node of every L-marker.
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            ETAVPSUM(i,j)=ETAVPSUM(i,j)+etavpm(m)*wtmij;
            ETASUM(i,j)=ETASUM(i,j)+etam(tm(m))*wtmij;
            FRICTSUM(i,j)=FRICTSUM(i,j)+frictm(tm(m))*wtmij;
            COSHESUM(i,j)=COSHESUM(i,j)+coshesm(tm(m))*wtmij;
            GGGSUM(i,j)=GGGSUM(i,j)+1/gggm(tm(m))*wtmij;
            SXYSUM(i,j)=SXYSUM(i,j)+sxym(m)*wtmij;
            WTSUM(i,j)=WTSUM(i,j)+wtmij;
        end
        % i+1,j Node
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            ETAVPSUM(i+1,j)=ETAVPSUM(i+1,j)+etavpm(m)*wtmi1j;
            ETASUM(i+1,j)=ETASUM(i+1,j)+etam(tm(m))*wtmi1j;
            FRICTSUM(i+1,j)=FRICTSUM(i+1,j)+frictm(tm(m))*wtmi1j;
            COSHESUM(i+1,j)=COSHESUM(i+1,j)+coshesm(tm(m))*wtmi1j;
            GGGSUM(i+1,j)=GGGSUM(i+1,j)+1/gggm(tm(m))*wtmi1j;
            SXYSUM(i+1,j)=SXYSUM(i+1,j)+sxym(m)*wtmi1j;
            WTSUM(i+1,j)=WTSUM(i+1,j)+wtmi1j;
        end
        % i,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            ETAVPSUM(i,j+1)=ETAVPSUM(i,j+1)+etavpm(m)*wtmij1;
            ETASUM(i,j+1)=ETASUM(i,j+1)+etam(tm(m))*wtmij1;
            FRICTSUM(i,j+1)=FRICTSUM(i,j+1)+frictm(tm(m))*wtmij1;
            COSHESUM(i,j+1)=COSHESUM(i,j+1)+coshesm(tm(m))*wtmij1;
            GGGSUM(i,j+1)=GGGSUM(i,j+1)+1/gggm(tm(m))*wtmij1;
            SXYSUM(i,j+1)=SXYSUM(i,j+1)+sxym(m)*wtmij1;
            WTSUM(i,j+1)=WTSUM(i,j+1)+wtmij1;
        end
        % i+1,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            ETAVPSUM(i+1,j+1)=ETAVPSUM(i+1,j+1)+etavpm(m)*wtmi1j1;
            ETASUM(i+1,j+1)=ETASUM(i+1,j+1)+etam(tm(m))*wtmi1j1;
            FRICTSUM(i+1,j+1)=FRICTSUM(i+1,j+1)+frictm(tm(m))*wtmi1j1;
            COSHESUM(i+1,j+1)=COSHESUM(i+1,j+1)+coshesm(tm(m))*wtmi1j1;
            GGGSUM(i+1,j+1)=GGGSUM(i+1,j+1)+1/gggm(tm(m))*wtmi1j1;
            SXYSUM(i+1,j+1)=SXYSUM(i+1,j+1)+sxym(m)*wtmi1j1;
            WTSUM(i+1,j+1)=WTSUM(i+1,j+1)+wtmi1j1;
        end   
        % Interpolation to vx-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xvx(j);
        dis_y=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        RHOXSUM(i,j)=RHOXSUM(i,j)+rhom(tm(m))*wtmij;
        KXSUM(i,j)=KXSUM(i,j)+km(tm(m))*wtmij;
        WTXSUM(i,j)=WTXSUM(i,j)+wtmij;
        % i+1,j Node
        RHOXSUM(i+1,j)=RHOXSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        KXSUM(i+1,j)=KXSUM(i+1,j)+km(tm(m))*wtmi1j;
        WTXSUM(i+1,j)=WTXSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        RHOXSUM(i,j+1)=RHOXSUM(i,j+1)+rhom(tm(m))*wtmij1;
        KXSUM(i,j+1)=KXSUM(i,j+1)+km(tm(m))*wtmij1;
        WTXSUM(i,j+1)=WTXSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        RHOXSUM(i+1,j+1)=RHOXSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        KXSUM(i+1,j+1)=KXSUM(i+1,j+1)+km(tm(m))*wtmi1j1;
        WTXSUM(i+1,j+1)=WTXSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation to vy-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xvy(j);
        dis_y=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        RHOYSUM(i,j)=RHOYSUM(i,j)+rhom(tm(m))*wtmij;
        KYSUM(i,j)=KYSUM(i,j)+km(tm(m))*wtmij;
        WTYSUM(i,j)=WTYSUM(i,j)+wtmij;
        % i+1,j Node
        RHOYSUM(i+1,j)=RHOYSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        KYSUM(i+1,j)=KYSUM(i+1,j)+km(tm(m))*wtmi1j;
        WTYSUM(i+1,j)=WTYSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        RHOYSUM(i,j+1)=RHOYSUM(i,j+1)+rhom(tm(m))*wtmij1;
        KYSUM(i,j+1)=KYSUM(i,j+1)+km(tm(m))*wtmij1;
        WTYSUM(i,j+1)=WTYSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        RHOYSUM(i+1,j+1)=RHOYSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        KYSUM(i+1,j+1)=KYSUM(i+1,j+1)+km(tm(m))*wtmi1j1;
        WTYSUM(i+1,j+1)=WTYSUM(i+1,j+1)+wtmi1j1;
        % Interpolation to P-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            ETAPVPSUM(i,j)=ETAPVPSUM(i,j)+etavpm(m)*wtmij;
            GGGPSUM(i,j)=GGGPSUM(i,j)+1/gggm(tm(m))*wtmij;
            SXXSUM(i,j)=SXXSUM(i,j)+sxxm(m)*wtmij;
            RHOSUM(i,j)=RHOSUM(i,j)+rhom(tm(m))*wtmij;
            RHOCPSUM(i,j)=RHOCPSUM(i,j)+rhocpm(tm(m))*wtmij;
            ALPHASUM(i,j)=ALPHASUM(i,j)+alpham(tm(m))*wtmij;
            HRSUM(i,j)=HRSUM(i,j)+hrm(tm(m))*wtmij;
            TKSUM(i,j)=TKSUM(i,j)+tkm(m)*rhocpm(tm(m))*wtmij;
            WTPSUM(i,j)=WTPSUM(i,j)+wtmij;
        end
        % i+1,j Node
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            ETAPVPSUM(i+1,j)=ETAPVPSUM(i+1,j)+etavpm(m)*wtmi1j;
            GGGPSUM(i+1,j)=GGGPSUM(i+1,j)+1/gggm(tm(m))*wtmi1j;
            SXXSUM(i+1,j)=SXXSUM(i+1,j)+sxxm(m)*wtmi1j;
            RHOSUM(i+1,j)=RHOSUM(i+1,j)+rhom(tm(m))*wtmi1j;
            RHOCPSUM(i+1,j)=RHOCPSUM(i+1,j)+rhocpm(tm(m))*wtmi1j;
            ALPHASUM(i+1,j)=ALPHASUM(i+1,j)+alpham(tm(m))*wtmi1j;
            HRSUM(i+1,j)=HRSUM(i+1,j)+hrm(tm(m))*wtmi1j;
            TKSUM(i+1,j)=TKSUM(i+1,j)+tkm(m)*rhocpm(tm(m))*wtmi1j;
            WTPSUM(i+1,j)=WTPSUM(i+1,j)+wtmi1j;
        end
        % i,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            ETAPVPSUM(i,j+1)=ETAPVPSUM(i,j+1)+etavpm(m)*wtmij1;
            GGGPSUM(i,j+1)=GGGPSUM(i,j+1)+1/gggm(tm(m))*wtmij1;
            SXXSUM(i,j+1)=SXXSUM(i,j+1)+sxxm(m)*wtmij1;
            RHOSUM(i,j+1)=RHOSUM(i,j+1)+rhom(tm(m))*wtmij1;
            RHOCPSUM(i,j+1)=RHOCPSUM(i,j+1)+rhocpm(tm(m))*wtmij1;
            ALPHASUM(i,j+1)=ALPHASUM(i,j+1)+alpham(tm(m))*wtmij1;
            HRSUM(i,j+1)=HRSUM(i,j+1)+hrm(tm(m))*wtmij1;
            TKSUM(i,j+1)=TKSUM(i,j+1)+tkm(m)*rhocpm(tm(m))*wtmij1;
            WTPSUM(i,j+1)=WTPSUM(i,j+1)+wtmij1;
        end
        % i+1,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            ETAPVPSUM(i+1,j+1)=ETAPVPSUM(i+1,j+1)+etavpm(m)*wtmi1j1;
            GGGPSUM(i+1,j+1)=GGGPSUM(i+1,j+1)+1/gggm(tm(m))*wtmi1j1;
            SXXSUM(i+1,j+1)=SXXSUM(i+1,j+1)+sxxm(m)*wtmi1j1;
            RHOSUM(i+1,j+1)=RHOSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
            RHOCPSUM(i+1,j+1)=RHOCPSUM(i+1,j+1)+rhocpm(tm(m))*wtmi1j1;
            ALPHASUM(i+1,j+1)=ALPHASUM(i+1,j+1)+alpham(tm(m))*wtmi1j1;
            HRSUM(i+1,j+1)=HRSUM(i+1,j+1)+hrm(tm(m))*wtmi1j1;
            TKSUM(i+1,j+1)=TKSUM(i+1,j+1)+tkm(m)*rhocpm(tm(m))*wtmi1j1;
            WTPSUM(i+1,j+1)=WTPSUM(i+1,j+1)+wtmi1j1;
        end
    end
    YYN=zeros(Ny,Nx);
    % Computing the value of density and viscosity of BASIC-NODE. 
    for j = 1:1:Nx
        for i = 1:1:Ny
            if(WTSUM(i,j)>0)
                % Not need RHO on the basic nodes.Just Y nodes.
                ETAVP(i,j) = ETAVPSUM(i,j)/WTSUM(i,j);%etaVp = eta in viscosity-elastic matreials.
                ETA(i,j) = ETASUM(i,j)/WTSUM(i,j);
                % 只有经过修正后的ETAVP才会小于ETA
                % 又因为修正代表该欧拉点满足应力屈服条件
                % 所以同时满足这两个条件的欧拉点需要标记为1（屈服）
                if(ETAVP(i,j)<ETA(i,j))
                    YYN(i,j) = 1;
                end
                FRICT(i,j) = FRICTSUM(i,j)/WTSUM(i,j);
                COSHE(i,j) = COSHESUM(i,j)/WTSUM(i,j);
                GGG(i,j) = WTSUM(i,j)/GGGSUM(i,j);
                sxy0(i,j) = SXYSUM(i,j)/WTSUM(i,j);
            end
        end
    end
    % Computing Density and K value at the VY and VX-nodes.
    for j=1:1:Nx1
        for i=1:1:Ny1
            % VY-nodes:(Nx1 * Ny) absent Ny1=0 !!!
            if(WTYSUM(i,j)>0)
                % rou_v
                RHOVY(i,j)=RHOYSUM(i,j)/WTYSUM(i,j);
                % K_v
                KVY(i,j)=KYSUM(i,j)/WTYSUM(i,j);
            end
            % VX-nodes:(Nx * Ny1)absent Nx1=0 !!!
            if(WTXSUM(i,j)>0)
                % rou_h
                RHOVX(i,j)=RHOXSUM(i,j)/WTXSUM(i,j);
                % K_h
                KVX(i,j) = KXSUM(i,j)/WTXSUM(i,j);
            end
        end
    end
    % Computing properities at P-node
    for j = 1:1:Nx1
        for i = 1:1:Ny1
            if(WTPSUM(i,j)>0)
                ETAPVP(i,j) = ETAPVPSUM(i,j)/WTPSUM(i,j);%etaVP = eta in viscosity-elastic materials.
                GGGP(i,j) = WTPSUM(i,j)/GGGPSUM(i,j);
                SXX0(i,j) = SXXSUM(i,j)/WTPSUM(i,j);
                RHOP(i,j) = RHOSUM(i,j)/WTPSUM(i,j);
                Hrij(i,j) = HRSUM(i,j)/WTPSUM(i,j);
                Aefij(i,j) = ALPHASUM(i,j)/WTPSUM(i,j);
                RHOPCP(i,j) = RHOCPSUM(i,j)/WTPSUM(i,j);%Den*Cp
                T0(i,j)  = TKSUM(i,j)/RHOCPSUM(i,j);%T
            end
        end
    end
    % Why??
    % Apply boundary condition after interpolate T0 from markers(any t).
    % top and left Ctbc
    T0(1,2:Nx) = T0(2,2:Nx);
    T0(Ny1,2:Nx) = T0(Ny,2:Nx);
    % left and right Ibc
    T0(:,1) = T0(:,2);
    T0(:,Nx1) = T0(:,Nx);
    
    % 假设第一次循环时，必定不会满足容许误差限，所以dt/2
    % 然后在之后的每一个timestep 都要逐渐增加dt,但不会超过5e7.
    dt = min(1.1*dt,dtelastic);
    AAAAA(t) = dt;
    % 传递（old）YNN（屈服标记）与ETAVP（miusvp）
    YYN00 = YYN;
    ETAVP00 = ETAVP;% ETAVP at "every timestep" instead of "every loop(200)"
    % Mechanical Solution
for iloop=1:1:nloop
        
    for i=2:1:Ny
        for j=2:1:Nx
            ETAPVP(i,j)=1/((1/ETAVP(i-1,j-1)+1/ETAVP(i,j-1)+1/ETAVP(i-1,j)+1/ETAVP(i,j))/4);
        end
    end
    % Solve Stokes-equ and Continuity-equ.
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global indexes in algebraic space
            kvx=((j-1)*Ny1+i-1)*3+1; % Vx
            kvy=kvx+1; % Vy
            kpm=kvx+2; % P
            
            % Vx equation External points
            if(i==1 || i==Ny1 || j==1 || j==Nx || j==Nx1)
                % Boundary Condition
                % Ghost points.
                % 1*Vx=0
                if (j==Nx1)
                    coe(kvx,kvx)=1; % Left part
                    R(kvx)=0; % Right part
                end
                % Left boundary(prescribe vx)
                if (j==1 )
                    coe(kvx,kvx)=1; % Left part
                    R(kvx)=vxleft; % Right part
                end
                % Right boundary(prescribe vx)
                if (j==Nx)
                    coe(kvx,kvx)=1; % Left part
                    R(kvx)=vxright; % Right part
                end
                % Top boundary(free slip)
                if(i==1 && j>1 && j<Nx)
                    coe(kvx,kvx)=1; % Left part
                    coe(kvx,kvx+3)=bc_top; % Left part
                    R(kvx)=0; % Right part
                end
                % Bottom boundary(free slip)
                if(i==Ny1 && j>1 && j<Nx)
                    coe(kvx,kvx)=1; % Left part
                    coe(kvx,kvx-3)=bc_bottom; % Left part
                    R(kvx)=0; % Right part
                end
            else
                % Internal points: x-Stokes eq.
                % ETA*(d2Vx/dx^2+d2Vx/dy^2)-dP/dx=0
                %            Vx2
                %             |
                %        Vy1  |  Vy3
                %             |
                %     Vx1-P1-Vx3-P2-Vx5
                %             |
                %        Vy2  |  Vy4
                %             |
                %            Vx4
                %
                % Density gradients
                dRHOdx=(RHOVX(i,j+1)-RHOVX(i,j-1))/2/dx;
                dRHOdy=(RHOVX(i+1,j)-RHOVX(i-1,j))/2/dy;
                % Modify parameters
                ETAPMIU2 = dt*GGGP(i,j+1)*ETAPVP(i,j+1)/(GGGP(i,j+1)*dt+ETAPVP(i,j+1));
                ETAPMIU1 = dt*GGGP(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));                
                ETAMIU1 =  dt*GGG(i-1,j)*ETAVP(i-1,j)/(GGG(i-1,j)*dt+ETAVP(i-1,j));
                ETAMIU2 =  dt*GGG(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
                % Stress
                SXX2 = SXX0(i,j+1)*ETAPVP(i,j+1)/(GGGP(i,j+1)*dt+ETAPVP(i,j+1));
                SXX1 = SXX0(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));      
                SXY2 = sxy0(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
                SXY1 = sxy0(i-1,j)*ETAVP(i-1,j)/(GGG(i-1,j)*dt+ETAVP(i-1,j));
                % Left part
                coe(kvx,kvx-Ny1*3)=2*ETAPMIU1/dx^2  ; % Vx1(i,j-1)
                coe(kvx,kvx-3)=ETAMIU1/dy^2          ; % Vx2(i-1,j)
                coe(kvx,kvx)=-2*(ETAPMIU2+ETAPMIU1)/dx^2 ...
                               -(ETAMIU2+ ETAMIU1) /dy^2 - gx*dt*dRHOdx; % Vx3(i,j)
                coe(kvx,kvx+3)=ETAMIU2/dy^2      ; % Vx4(i+1,j)
                coe(kvx,kvx+Ny1*3)=2*ETAPMIU2/dx^2    ; % Vx5(i,j+1)
                coe(kvx,kvy)      = -ETAMIU2/dy/dx -dRHOdy*gx*dt/4  ;  % Vy2(i,j)
                coe(kvx,kvy+Ny1*3)= ETAMIU2/dy/dx  -dRHOdy*gx*dt/4   ;  % Vy4(i,j+1)
                coe(kvx,kvy-3)    = ETAMIU1/dx/dy -dRHOdy*gx*dt/4  ;  % Vy1(i-1,j)
                coe(kvx,kvy+Ny1*3-3)= -ETAMIU1/dx/dy -dRHOdy*gx*dt/4  ;  % Vy3(i-1,j+1)
                coe(kvx,kpm)=Kcont/dx; % P1(i,j)
                coe(kvx,kpm+Ny1*3)=-Kcont/dx; % P2(i,j+1)

                % Right part !!!
                R(kvx)=-RHOVX(i,j)*gx -(SXX2-SXX1) /dx...
                                       -(SXY2-SXY1)/dy ;
            end
            
            % Vy equation External points
            if(j==1 || j==Nx1 || i==1 || i==Ny || i==Ny1)
                % Boundary Condition
                % Ghost points.
                % 1*Vy=0
                if (i == Ny1)
                    coe(kvy,kvy)=1; % Left part
                    R(kvy)=0; % Right part
                end
                % Up boundary(prescribe v)
                if (i == 1)
                    coe(kvy,kvy)=1; % Left part
                    R(kvy)=vytop; % Right part
                end
                % Down boundary(prescribe v)
                if (i == Ny)
                    coe(kvy,kvy)=1; % Left part
                    R(kvy)=vybottom; % Right part
                end
                % Left boundary(free slip)
                if(j==1 && i>1 && i<Ny)
                    coe(kvy,kvy)=1; % Left part
                    coe(kvy,kvy+3*Ny1)=bc_left; % Left part
                    R(kvy)=0; % Right part
                end
                % Right boundary(free slip)
                if(j==Nx1 && i>1 && i<Ny)
                    coe(kvy,kvy)=1; % Left part
                    coe(kvy,kvy-3*Ny1)=bc_right; % Left part
                    R(kvy)=0; % Right part
                end
            else
                % Internal points: y-Stokes eq.
                % ETA*(d2Vy/dx^2+d2Vy/dy^2)-dP/dy=-RHO*gy
                %            Vy2
                %             |
                %         Vx1 P1 Vx3
                %             |
                %     Vy1----Vy3----Vy5
                %             |
                %         Vx2 P2 Vx4
                %             |
                %            Vy4
                %
                % Viscosity points
                dRHOdx=(RHOVY(i,j+1)-RHOVY(i,j-1))/2/dx;
                dRHOdy=(RHOVY(i+1,j)-RHOVY(i-1,j))/2/dy;
                ETAPMIU2 = 2*dt*GGGP(i+1,j)*ETAPVP(i+1,j)/(GGGP(i+1,j)*dt+ETAPVP(i+1,j));
                ETAPMIU1 = 2*dt*GGGP(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));
                ETAMIU1  = 2*dt*GGG(i,j-1)*ETAVP(i,j-1)/(GGG(i,j-1)*dt+ETAVP(i,j-1));
                ETAMIU2  = 2*dt*GGG(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));        
                SYY2 = -SXX0(i+1,j)*ETAPVP(i+1,j)/(GGGP(i+1,j)*dt+ETAPVP(i+1,j));
                SYY1 = -SXX0(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));      
                SYX2 = sxy0(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
                SYX1 = sxy0(i,j-1)*ETAVP(i,j-1)/(GGG(i,j-1)*dt+ETAVP(i,j-1));
                % Left part
                coe(kvy,kvy-Ny1*3)=ETAMIU1/2/dx^2    ; % Vy1(i,j-1)
                coe(kvy,kvy-3)=ETAPMIU1/dy^2    ; % Vy2(i-1,j)
                coe(kvy,kvy)=-ETAPMIU1/dy^2-ETAPMIU2/dy^2 ...
                             -ETAMIU2/2/dx^2-ETAMIU1/2/dx^2 - dRHOdy*gy*dt; % Vy3(i,j)
                coe(kvy,kvy+3)=ETAPMIU2/dy^2   ; % Vy4(i+1,j)
                coe(kvy,kvy+Ny1*3)=ETAMIU2/2/dx^2   ; % Vy5(i,j+1)
                coe(kvy,kvx)= - ETAMIU2/2/dx/dy    -dRHOdx*gy*dt/4; %Vx3(i,j)
                coe(kvy,kvx+3)=  ETAMIU2/2/dx/dy   -dRHOdx*gy*dt/4; %Vx4(i+1,j)
                coe(kvy,kvx-Ny1*3)= ETAMIU1/2/dx/dy    -dRHOdx*gy*dt/4; %Vx1(i,j-1)
                coe(kvy,kvx+3-Ny1*3)= - ETAMIU1/2/dx/dy     -dRHOdx*gy*dt/4; %Vx2(i+1,j-1)
                coe(kvy,kpm)=Kcont/dy; % P1
                coe(kvy,kpm+3)=-Kcont/dy; % P2
                
                % Right part
                R(kvy)=-RHOVY(i,j)*gy - (SYY2-SYY1)/dy...
                                      - (SYX2-SYX1)/dx;
            end
            
            % P equation External points
            if(i==1 || j==1 || i==Ny1 || j==Nx1 ||...
                    (i==2 && j==2))
                % Boundary Condition
                % 1*P=0
                coe(kpm,kpm)=1; % Left part
                % Apply 108 Pa as the boundary condition for pressure.
                R(kpm)=0; % Right part  !!!
                % Real BC
                if(i==2 && j==2)
                    coe(kpm,kpm)=1*Kcont; %Left part
                    R(kpm)=1e8; % Right part !!!
                end
            else
                % Internal points: continuity eq.
                % dVx/dx+dVy/dy=0
                %            Vy1
                %             |
                %        Vx1--P--Vx2
                %             |
                %            Vy2
                %
                % Left part
                coe(kpm,kvx-Ny1*3)=-1/dx; % Vx1
                coe(kpm,kvx)=1/dx; % Vx2
                coe(kpm,kvy-3)=-1/dy; % Vy1
                coe(kpm,kvy)=1/dy; % Vy2
                % Right part
                R(kpm)=0;
            end
        end
    end
    % Computing the solution U:include vx,vy and p
     U = coe \ R;
    % Decompose the solution of global matrix. 
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global indexes in algebraic space
            kvx=((j-1)*Ny1+i-1)*3+1; % Vx
            kvy=kvx+1; % Vy
            kpm=kvx+2; % P
            % Reload solution
            vx(i,j)=U(kvx);
            vy(i,j)=U(kvy);
            p(i,j)=U(kpm)*Kcont;
        end
    end
    % Restrict the time step limiting max_marker_disp by 0.5 grid step
    % Define dtm for transport of markers.
    % Why dt*1.2??
    % Define displacement timestep dtm
    dtm=dt;
    maxvx=max(max(abs(vx)));
    maxvy=max(max(abs(vy)));
    if(dtm*maxvx>dxymax*dx)
        dtm=dxymax*dx/maxvx;
    end
    if(dtm*maxvy>dxymax*dy)
        dtm=dxymax*dy/maxvy;
    end
    
    EXY = zeros(Ny,Nx);
    SXY = zeros(Ny,Nx);
    DSXY = zeros(Ny,Nx);
    % Computing strain rate(xy) and deviatoric(xy) stress components.
    for j = 1:1:Nx
        for i = 1:1:Ny
            %ETAVP = ETA,which plastic is absent.
            EXY(i,j) = (1/2)*( (vx(i+1,j)-vx(i,j))/dy ...
                             + (vy(i,j+1)-vy(i,j))/dx ) ;
            % srxy is strain rate,sxy is stressxy
            SXY(i,j) = 2*ETAVP(i,j)*EXY(i,j)  * (GGG(i,j)*dtm/(GGG(i,j)*dtm+ETAVP(i,j))) ...
                                  + sxy0(i,j) * (  ETAVP(i,j)/(GGG(i,j)*dtm+ETAVP(i,j)));
            DSXY(i,j) = SXY(i,j) - sxy0(i,j);
        end
    end
    % Define second invariant value of stress and strain rate.
    EXX = zeros(Ny1,Nx1);
    SXX = zeros(Ny1,Nx1);
    EII = zeros(Ny1,Nx1);
    SII = zeros(Ny1,Nx1);
    DSXX = zeros(Ny1,Nx1);
    % Computing strain rate(xx) and deviatoric(xx) stress components.
    for j = 2:1:Nx
        for i = 2:1:Ny        
            % Note that exx is not the 1/2 item in the book.
            EXX(i,j) =  (vx(i,j)-vx(i,j-1))/dx;
            % srxx is strain rate,sxx is stressxx
            SXX(i,j) = 2*ETAPVP(i,j)*EXX(i,j) * (GGGP(i,j)*dtm/(GGGP(i,j)*dtm+ETAPVP(i,j))) ...
                                  + SXX0(i,j) * (  ETAPVP(i,j)/(GGGP(i,j)*dtm+ETAPVP(i,j)));
            DSXX(i,j) = SXX(i,j) - SXX0(i,j);
            % The second invariant value.
            EII(i,j) = ( EXX(i,j)^2 + ((EXY(i-1,j)   + EXY(i,j-1) ...
                       + EXY(i-1,j-1) + EXY(i,j))/4)^2 )^0.5;
            SII(i,j) = ( SXX(i,j)^2 + ((SXY(i-1,j)   + SXY(i,j-1) ...
                       + SXY(i-1,j-1) + SXY(i,j))/4)^2 )^0.5;
        end
    end
    
    p(:,1)  = p(:,2);
    p(:,Nx1)= p(:,Nx);
    p(1,:)  = p(2,:);
    p(Ny1,:)= p(Ny,:);
    SXX(:,1)=SXX(:,2);
    SXX(:,Nx1)=SXX(:,Nx);
    SXX(1,:)=SXX(2,:);
    SXX(Ny1,:)=SXX(Ny,:);
    ETA5=ETA; % 传递老mius 而不是miusvp ，在每一次timestep
    YYN5=zeros(Ny,Nx);% 设置一个中间变量来传递“屈服标记矩阵”
    % "Update ETAVP(i,j)"
    DIJYIELD = 0;
    NIJPLAST = 0;
    % Iterate over BASIC-NODE.
    for j = 1:Nx
        for i = 1:Ny
            syieldij = COSHE(i,j)+FRICT(i,j)*(p(i,j)+p(i+1,j)+p(i,j+1)+p(i+1,j+1))/4;
            syieldij = max(syieldij,0);
            siiij = (SXY(i,j)^2 + (1/16)*(SXX(i,j)+SXX(i+1,j)+SXX(i,j+1)+SXX(i+1,j+1))^2)^0.5;
            % "NOTE THAT" 13.50 is different with below line.
            siielaij = siiij*(GGG(i,j)*dt+ETAVP(i,j))/ETAVP(i,j);
            % Check whather each marker has been checked.0 is no,1 is yes.
            ynij = 0;%首先假定每一个欧拉点都不屈服
            % By default, each marker is subject to stress conditions???
            if(YYN(i,j) > 0)
                ynij = 1;%如果老欧拉点屈服，表明满足应力与粘度条件ynij=1
                NIJPLAST = NIJPLAST + 1;
                DIJYIELD = DIJYIELD + (siiij-syieldij)^2;
            end
            % ETAVP(i,j) = ETA(i,j);
            if(syieldij<siielaij)
                % 满足应力屈服条件则更新粘度miuvp
                ETAVPij = GGG(i,j)*dt*syieldij/(siielaij-syieldij);
                if(ETAVPij < ETA(i,j))                
                    % 满足应力与粘度条件则应用于下一次循环，否则该欧拉点保持原来粘度。
                    % 并且标记屈服1于此欧拉点
                    ETA5(i,j) = ETAVPij; 
                    YYN5(i,j) = 1;
                    % 要注意在m13_2中的更新粘度有上下界
                    if(ETA5(i,j)<minetavpm)
                        ETA5(i,j)=minetavpm;
                    elseif(ETA5(i,j)>maxetavpm)
                        ETA5(i,j)=maxetavpm;
                    end
                    if(ynij ==0 )
                        % 如果该欧拉点是之前不屈服，经过修正后屈服的                        
                        NIJPLAST = NIJPLAST + 1;
                        DIJYIELD = DIJYIELD + (siiij-syieldij)^2;
                        % 如果欧拉点之前屈服，经过修正后仍然屈服的
                        % 不进行累计 
                        % 或者说：
                        %ynn = 1的即已经计算误差并累计的此处不再计算
                        %并且以前不屈服的，现在屈服了进行累计。
                        %排除掉以前屈服的现在也屈服的，也就是说不对其进行累计。
                    end
                else
                    % 如果满足应力条件但不满足粘度条件则不更新粘度
                    % 使用老粘度mius以及屈服标记0
                    ETA5(i,j) =ETA(i,j);
                    YYN5(i,j) = 0;
                end
                % Setoff tolerance level.
            else
                % 如不满足应力条件则也不更新粘度；
                % 使用老粘度mius以及屈服标记0
                ETA5(i,j) = ETA(i,j);
                YYN5(i,j) = 0;
            end
        end
    end
    % Compute yielding error
    % 如果有至少一个点满足屈服条件，那么就需要计算误差
    if(NIJPLAST>0)
        YIELDERRNODAL(iloop)=(DIJYIELD/NIJPLAST)^0.5;
    end
    
    % Stop iteration
    if(NIJPLAST==0 || iloop==nloop || YIELDERRNODAL(iloop)<yerrmax)
        break
        % 达到3个条件之一则停止循环
        % 1、没有达到屈服的node点（前面的timestep一般会）；
        % 2、达到100000次（一般不会）；
        % 3、本次误差小于3e5（一般会）
        % Repeat iteration（最大次数为100000/200次）
    else
        % 没有达到循环截止条件时：
        % 1、如果循环为200次的整数倍，
        %    那么dt/2，并且相当于重新迭代（1），
        %    粘度使用当次timestep的老VP粘度与老屈服标志。
        % 2、如果不是200次的整数倍（1*N-200*N之内）
        %    那么使用新的VP粘度与新屈服标志。
        % Decrease computational timestep if too many iterations
        if(fix(iloop/dtstep)*dtstep==iloop)% reach to 200 times
            % Decrease timestep
            dt=dt/2;% dt/2
            aaaa = 1;
            % Reset old viscoplastic viscosity
            ETAVP=ETAVP00;
            YYN  =YYN00;
        else
            % Use new viscoplastic viscosity
            ETAVP=ETA5;
            YYN=YYN5;
        end
    end

% 结束循环
end

    for m = 1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        if(YYN(i,j)>0 || YYN(i+1,j)>0 || YYN(i,j+1)>0 || YYN(i+1,j+1)>0)            
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            etavpm(m)= 1/(YYN(i,j)*wtmij   /ETAVP(i,j)   + YYN(i+1,j)*wtmi1j   /ETAVP(i+1,j)  ...
                         +YYN(i,j+1)*wtmij1/ETAVP(i,j+1) + YYN(i+1,j+1)*wtmi1j1/ETAVP(i+1,j+1));
            % 限制粘度？？？
            if(etavpm(m)>=etam(tm(m)))
                etavpm(m)=etam(tm(m));
            end
        else
            % 如果该次timestep迭代没有屈服欧拉点
            % 则不需要更新粘度只需使用最初粘度进入下一个timestep。
            etavpm(m)=etam(tm(m));    
        end  
    end
   
    % Computing "STRESS" subgrid diffusion for markers
    if (subgrdifcoes>0)
        % Existence of subgrid diffusion.
        % Page162 How to correct the problem ?
        % operating  consistent subgrid diffusion .
        % Clear subgrid temperature changes(dTijsub) for nodes
        % P-NODES
        WPNODES = zeros(Ny1,Nx1);
        SXXSUM = zeros(Ny1,Nx1);
        % Basic-NODES        
        WNODES = zeros(Ny,Nx);
        SXYSUM = zeros(Ny,Nx);
        % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
        for m = 1:marknum
            % Interpolate T to P-NODES(Nx*Ny)
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            sxxm0nodal= sxx(i,j)*wtmij + sxx(i+1,j)*wtmi1j  ...
                +sxx(i,j+1)*wtmij1 + sxx(i+1,j+1)*wtmi1j1;
            j=fix((xm(m)-x(1))/dx)+1;
            i=fix((ym(m)-y(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-x(j);
            dis_y=ym(m)-y(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            sxym0nodal= sxy(i,j)*wtmij + sxy(i+1,j)*wtmi1j  ...
                +sxy(i,j+1)*wtmij1 + sxy(i+1,j+1)*wtmi1j1;
            % NOTE THAT the answer is sxxm(m)-sxxm0nodal.
            % Eq.10.14
            dsxxm0 = sxxm0nodal - sxxm(m);
            dsxym0 = sxym0nodal - sxym(m);
            % Page209
            tdiff = etam(tm(m))/gggm(tm(m));
            % Computing subgrid diffusion
            % Why??
            % dve = 0;%209,0<dve<1
            sdif=-subgrdifcoes*dtm/tdiff;
            % Page162 Eq.10.16
            dsxxmsub=dsxxm0*(1-exp(sdif));
            dsxymsub=dsxym0*(1-exp(sdif));

            % Eq.10.19
            % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
            sxxm(m) = sxxm(m) + dsxxmsub;
            sxym(m) = sxym(m) + dsxymsub;
            % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
            % Eq.10.17
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                SXXSUM(i,j) = SXXSUM(i,j) + dsxxmsub*wtmij;
                WPNODES(i,j) = WPNODES(i,j) + wtmij;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                SXXSUM(i+1,j) = SXXSUM(i+1,j) + dsxxmsub*wtmi1j;
                WPNODES(i+1,j) = WPNODES(i+1,j) + wtmi1j;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                SXXSUM(i,j+1) = SXXSUM(i,j+1) + dsxxmsub*wtmij1;
                WPNODES(i,j+1) = WPNODES(i,j+1) + wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                SXXSUM(i+1,j+1) = SXXSUM(i+1,j+1) + dsxxmsub*wtmi1j1;
                WPNODES(i+1,j+1) = WPNODES(i+1,j+1) + wtmi1j1;
            end
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-x(1))/dx)+1;
            i=fix((ym(m)-y(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-x(j);
            dis_y=ym(m)-y(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                SXYSUM(i,j) = SXYSUM(i,j) + dsxymsub*wtmij;
                WNODES(i,j) = WNODES(i,j) + wtmij;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                SXYSUM(i+1,j) = SXYSUM(i+1,j) + dsxymsub*wtmi1j;
                WNODES(i+1,j) = WNODES(i+1,j) + wtmi1j;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                SXYSUM(i,j+1) = SXYSUM(i,j+1) + dsxymsub*wtmij1;
                WNODES(i,j+1) = WNODES(i,j+1) + wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                SXYSUM(i+1,j+1) = SXYSUM(i+1,j+1) + dsxymsub*wtmi1j1;
                WNODES(i+1,j+1) = WNODES(i+1,j+1) + wtmi1j1;
            end
        end
        dsxxijsub = zeros(Ny1,Nx1);
        dsxyijsub = zeros(Ny,Nx);
        % P-NODES
        for j=2:1:Nx
            for i=2:1:Ny
                if(WPNODES(i,j)>0)
                    dsxxijsub(i,j)=SXXSUM(i,j)/WPNODES(i,j);
                end
            end
        end
        % Basic nodes
        for j=1:1:Nx
            for i=1:1:Ny
                if(WNODES(i,j)>0)
                    dsxyijsub(i,j) = SXYSUM(i,j)/WNODES(i,j);
                end
            end
        end
        % Eq.10.18
        % Update dTij(dTij(remain) = dTij - dTij(sub)  )
        DSXX = DSXX - dsxxijsub;
        DSXY = DSXY - dsxyijsub;
    end
    % Interpolate L-markers(dTremain) from P-node(dsxxijremain)
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<2)
            j=2;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<2)
            i=2;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dsxxmremain= DSXX(i,j)  *wtmij  + DSXX(i+1,j)   *wtmi1j  ...
                   + DSXX(i,j+1)*wtmij1 + DSXX(i+1,j+1) *wtmi1j1;
        % "NOTE THAT" this discard interpolation of new stress SXX. 
        sxxm(m) = sxxm(m) + dsxxmremain;
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dsxymremain=DSXY(i,j)  *wtmij  + DSXY(i+1,j)  *wtmi1j  ...
                   +DSXY(i,j+1)*wtmij1 + DSXY(i+1,j+1)*wtmi1j1;
        % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
        % Eq.10.19
        sxym(m) = sxym(m) + dsxymremain;
    end
    
    Hsij = zeros(Ny1,Nx1);
    for j = 2:1:Nx
        for i = 2:1:Ny   
            pxyxy = (1/4)*( SXY(i,j)^2/ETAVP(i,j)   + SXY(i-1,j)^2/ETAVP(i-1,j)...
                          + SXY(i,j-1)/ETAVP(i,j-1) + SXY(i-1,j-1)/ETAVP(i-1,j-1));
            % Shear heating Hs
            Hsij(i,j) = SXX(i,j)^2/ETAPVP(i,j)+ pxyxy;
        end
    end
    Haij = zeros(Ny1,Nx1);
    % Adiabatic heating Ha
    for j = 2:1:Nx
        for i = 2:1:Ny
            kvy = ( vy(i,j)+vy(i-1,j) )/2;
            kvx = ( vx(i,j)+vx(i,j-1) )/2;
            Haij(i,j) = T0(i,j)*Aefij(i,j)*RHOP(i,j)*(gy*kvy+gx*kvx);
        end
    end

    % Solve temperature equation.
    % Preliminary dtm to define possible temperature changes.3
    dtT=dtm;
    dttsum=0;
    titer=1;
    while(dttsum<dtm)
        % Insulating boundary condition.
        % Up and down
        for j=1:1:Nx1
            for i=1:1:Ny1
                % Define global index in algebraic space
                kt=(j-1)*Ny1+i;
                % External points
                if(i==1 || i==Ny1 || j==1 || j==Nx1)
                    % Boundary Condition
                    % Top BC: i
                    if(i==1 && j>1 && j<Nx1)
                        coet(kt,kt)=1; % Left part
                        coet(kt,kt+1)=-1; % Left part
                        bt(kt)=0; % Right part
                    end
                    % Bottom BC: i
                    if(i==Ny1 && j>1 && j<Nx1)
                        coet(kt,kt)=1; % Left part
                        coet(kt,kt-1)=-1; % Left part
                        bt(kt)=0; % Right part
                    end
                    % Left BC: i
                    if(j==1)
                        coet(kt,kt)=1; % Left part
                        coet(kt,kt+Ny1)=-1; % Left part
                        bt(kt)=0; % Right part
                    end
                    % Right BC: i
                    if(j==Nx1)
                        coet(kt,kt)=1; % Left part
                        coet(kt,kt-Ny1)=-1; % Left part
                        bt(kt)=0; % Right part
                    end
                else
                    % Internal points: Temperature eq.
                    % Left part
                    % KVX == Kh;KVY == Kv
                    khij  = KVX(i,j);
                    khij1 = KVX(i,j-1);
                    kvij  = KVY(i,j);
                    kvi1j = KVY(i-1,j);
                    % Not 2* why?? page177
                    coet(kt, kt) = (khij+khij1)/dx^2+RHOPCP(i,j)/dtT...
                                  +(kvij+kvi1j)/dy^2;% middle T3 i,j
                    coet(kt, kt-1) = -(kvi1j)/(2.*dy.^2); % up T2 i-1,j
                    coet(kt, kt+1) = -(kvij)/(2.*dy.^2); % down T4 i+1,j
                    coet(kt, kt-Ny1) = -(khij1)/(dx.^2); % left T1 i,j-1
                    coet(kt, kt+Ny1) = -(khij)/(dx.^2); % right T5 i,j+1
                    % !!!Note that there are not advection term because MIC have
                    % marker transport.!!!
                    % Adding H(P-nodes)
                    bt(kt, 1) = T0(i,j)*RHOPCP(i,j)/dtT + Hrij(i,j) + Haij(i,j) + Hsij(i,j);
                end
            end
        end

        %direct method:right martix is divided by coe martix on the left
        u = coet \ bt;
        % transform vector to grids
        % U has Ny1 rows and Nx1 columns
        U = reshape(u, Ny1, Nx1);
        T1 = U;
        % Computing dTi,j = dTi,j(subgrid) + dTi,j(remaining)
        % Eq10.13
        dTij = T1-T0;
        % Adjust dt for must condition:DTmax,and max number of iteration 
        % is 2  
        % Define dtT for temperature equation.
        % dtT <= dtm(markers instead of stokes, visible in LINE-727)
        if(titer == 1)
            % A given absolute nodal temperature change limit.2
            maxDTcurrent=max(max(abs(dTij)));
            if(maxDTcurrent>DTmax)
                dtT=dtT/maxDTcurrent*DTmax;
            else
                dttsum=dttsum+dtT; % Update dttsum
            end
        else
            % A given absolute time step limit.1!!!
            % Maybe this is 3! dtT can't except dtm.
            dttsum=dttsum+dtT; % Update dttsum
            % Adjust timestep
            if(dtT>dtm-dttsum)
                dtT=dtm-dttsum;
            end
        end
        % Update iteration counter.
        titer=titer+1; 
    end
    % "NOTE" that tk0==tk1 in the answer.
    dTij = T1-T0;
    % Computing subgrid diffusion for markers
    if (subgrdifcoet>0)
        % Existence of subgrid diffusion.
        % Page162 How to correct the problem ?
        % operating  consistent subgrid diffusion .
        % Clear subgrid temperature changes(dTijsub) for nodes
        % From marker to P-NODES
        WPNODES = zeros(Ny1,Nx1);
        WDTM = zeros(Ny1,Nx1);
        % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
        for m = 1:marknum
            % Interpolate T to P-NODES(Nx*Ny)
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            Tm0nodal= T0(i,j)*wtmij + T0(i+1,j)*wtmi1j  ...
                +T0(i,j+1)*wtmij1 + T0(i+1,j+1)*wtmi1j1;
            % Eq.10.14
            dTm = Tm0nodal - tkm(m);
            % Page163
            tdiff = rhocpm(tm(m))/(km(tm(m))*(2/dx^2+2/dy^2));
            % Computing subgrid diffusion
            % Why??
            sdif=-subgrdifcoet*dtm/tdiff;
            % That's discard below code.
%             if(sdif<-30)
%                 sdif=-30;
%             end
            % Page162 Eq.10.16
            dTmsub=dTm*(1-exp(sdif));
            % Eq.10.19
            % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
            tkm(m) = tkm(m) + dTmsub;
            % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
            % Eq.10.17
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                WDTM(i,j) = WDTM(i,j) + dTmsub*rhocpm(tm(m))*wtmij;
                WPNODES(i,j) = WPNODES(i,j) + rhocpm(tm(m))*wtmij;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                WDTM(i+1,j) = WDTM(i+1,j) + dTmsub*rhocpm(tm(m))*wtmi1j;
                WPNODES(i+1,j) = WPNODES(i+1,j) + rhocpm(tm(m))*wtmi1j;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                WDTM(i,j+1) = WDTM(i,j+1) + dTmsub*rhocpm(tm(m))*wtmij1;
                WPNODES(i,j+1) = WPNODES(i,j+1) + rhocpm(tm(m))*wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                WDTM(i+1,j+1) = WDTM(i+1,j+1) + dTmsub*rhocpm(tm(m))*wtmi1j1;
                WPNODES(i+1,j+1) = WPNODES(i+1,j+1) + rhocpm(tm(m))*wtmi1j1;
            end
        end
        dTijsub = zeros(Ny1,Nx1);
        for j = 1:Nx1
            for i = 1:Ny1
                if(WPNODES(i,j)>0)
                    % Compting dTijsub
                    % Eq.10.17
                    dTijsub(i,j) = WDTM(i,j)/WPNODES(i,j);
                end
            end
        end
        % Eq.10.18
        % Update dTij(dTij(remain) = dTij - dTijsub)
        dTij = dTij - dTijsub;
    end
    % Interpolate L-markers(dTremain) from P-node(dTijremain)
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dTmremain=dTij(i,j)  *wtmij  + dTij(i+1,j)  *wtmi1j  ...
                 +dTij(i,j+1)*wtmij1 + dTij(i+1,j+1)*wtmi1j1;
        % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
        % Eq.10.19            
        tkm(m) = tkm(m) + dTmremain;
        if(t==1)
            % Interpolate new temperature for the 1st timestep
            tkm(m) = T1(i,j)*wtmij + T1(i+1,j)*wtmi1j  ...
                    +T1(i,j+1)*wtmij1 + T1(i+1,j+1)*wtmi1j1;
        end
    end

    % Computing Vx/Vy at the P-nodes
    for j = 2:1:Nx
        for i = 2:1:Ny
            %  Computing internal Vx and Vy at the P nodes.
            % Vx at internal(P) nodes.
            pvx(i,j) = ( vx(i,j) + vx(i,j-1) )./2;
            % Vy at internal nodes.
            pvy(i,j) = ( vy(i,j) + vy(i-1,j) )./2;
        end
    end
    % Vx
    % Top
    pvx(1,2:Nx-1)   = pvx(2,2:Nx-1);
    % Bottom
    pvx(Ny1,2:Nx-1) = pvx(Ny,2:Nx-1);
    % Left
    pvx(:,1)        = 2*vxleft -pvx(:,2);
    % Right
    pvx(:,Nx1)      = 2*vxright-pvx(:,Nx);
    % Vy
    % Left
    pvy(2:Ny-1,1)  =  pvy(2:Ny-1,2);
    % Right
    pvy(2:Ny-1,Nx1)=  pvy(2:Ny-1,Nx); % Free slip
    % Top
    pvy(1,:)       =  2*vytop   - pvy(2,:);
    % Bottom
    pvy(Ny1,:)     =  2*vybottom- pvy(Ny,:);

    % Rotate stress by Analytical formulas.
    for j = 1:1:Nx
        for i = 1:1:Ny
            % Computing rotation value.
            wyx(i,j) = (1/2)*( (vy(i,j+1)-vy(i,j))/dx ...
                             - (vx(i+1,j)-vx(i,j))/dy ) ;
        end
    end

    % The classical Runge-Kutta scheme,Fourth-order in sapce First-order in time
    % Define Vxa(Vya)1,Vxb(Vyb)2,Vxc(Vyc)3,Vxd(Vyd)4.
    vxm=zeros(4,1);
    vym=zeros(4,1);
    % Interpolate vx and vy components from E-nodes to L-markers.
    for m=1:1:marknum
        % Computing wm and rotate stress.
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Compute vxm and vym velocity
        wm = wyx(i,j)*wtmij+wyx(i+1,j)*wtmi1j...
           + wyx(i,j+1)*wtmij1+wyx(i+1,j+1)*wtmi1j1;
        angleAB = wm*dtm;
        sxymnew = sxxm(m)*sin(2*angleAB)+sxym(m)*cos(2*angleAB);
        sxxmnew = sxxm(m)*cos(angleAB)^2 - sxxm(m)*sin(angleAB)^2-sxym(m)*sin(2*angleAB) ;
        sxym(m) = sxymnew;
        sxxm(m) = sxxmnew;
        % Reserve original coordinate.
        xa = xm(m);
        ya = ym(m);
        for rk = 1:1:4
            % Interpolate vx-p and vy-p from P-staggered nodes to L-markers.
            % P staggered nodes.(Nx1 * Ny1)
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vxm and vym velocity
            vxm(rk) = pvx(i,j)*wtmij    + pvx(i+1,j)*wtmi1j...
                     +pvx(i,j+1)*wtmij1 + pvx(i+1,j+1)*wtmi1j1;
            vym(rk) = pvy(i,j)*wtmij    + pvy(i+1,j)*wtmi1j...
                     +pvy(i,j+1)*wtmij1 + pvy(i+1,j+1)*wtmi1j1;
            % Interpolate vx from Vx-staggered nodes to L-markers.
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvx(1))/dx)+1;
            i=fix((ym(m)-yvx(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            % Vx staggered nodes.(Nx * Ny+1)
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xvx(j);
            dis_y=ym(m)-yvx(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vx velocity
            vxm(rk) = (1/3)*vxm(rk) + (2/3)*(vx(i,j)*wtmij+vx(i+1,j)*wtmi1j...
                                           + vx(i,j+1)*wtmij1+vx(i+1,j+1)*wtmi1j1);
            % Interpolate vy
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvy(1))/dx)+1;
            i=fix((ym(m)-yvy(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-xvy(j);
            dis_y=ym(m)-yvy(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vx velocity
            vym(rk) = (1/3)*vym(rk) + (2/3)*(vy(i,j)*wtmij+vy(i+1,j)*wtmi1j...
                     +vy(i,j+1)*wtmij1+vy(i+1,j+1)*wtmi1j1); 
                 
            if(rk == 1 || rk == 2)
                xm(m) = vxm(rk)*dtm/2 + xa;
                ym(m) = vym(rk)*dtm/2 + ya;
            elseif(rk == 3)
                xm(m) = vxm(rk)*dtm + xa;
                ym(m) = vym(rk)*dtm + ya;
            end
        end
        % Return original coordinate.
        xm(m) = xa;
        ym(m) = ya;
        % Move markers with effective velocity field.
        vxefft = (1/6)*(vxm(1)+2*vxm(2)+2*vxm(3)+vxm(4));
        vyefft = (1/6)*(vym(1)+2*vym(2)+2*vym(3)+vym(4));        
        xm(m)=xm(m)+dtm*vxefft;
        ym(m)=ym(m)+dtm*vyefft;
    end
    % Sum of time.
    timesum=timesum+dtm;
    % Figure at every 20 timesteps.
    if(t==1 || fix(t/20)*20==t)
        % ETA,Ha and T.
        figure(1);
        % Figure
        subplot(1,3,1);
        colormap('Jet');
        pcolor(x,y,log10(ETAVP));
        hold on;
        %P nodes:(Nx1 * Ny1).
        quiver(xp(1:2:Nx1),yp(1:2:Ny1),pvx(1:2:Ny1,1:2:Nx1),pvy(1:2:Ny1,1:2:Nx1),'w')
        xlabel('Horizontal(m)')
        ylabel('Vertical(m)')
        caxis([17 21]);
        set(gca,'xaxislocation','top');
        set (gca,'YDir','reverse')
        shading interp;
        axis ij image;
        colorbar
        title(['log10(ETA) after ',num2str(t),' deltat'])
        % Ha
        subplot(1,3,2);
        colormap('Jet');
        pcolor(xp,yp,Hrij);
        xlabel('Horizontal(m)')
        ylabel('Vertical(m)')
        set(gca,'xaxislocation','top');
        set (gca,'YDir','reverse')
        shading interp;
        colorbar;
        axis ij image;
        title(['Ha after ',num2str(t),' deltat'])
        subplot(1,3,3);
        pcolor(xp,yp,T1);colorbar;
        xlabel('Horizontal(Km)');
        ylabel('Vertical(Km)');
        zlabel('Gravitational potential');
        title(['(Ibc)(MIC) Temperature after',num2str(t),' deltat'])
        set(gca,'xaxislocation','top');
        set (gca,'YDir','reverse')
        axis ij image;
        shading interp;
        % Change of yielderror with time.
        figure(2);
        plot(YIELDERRNODAL,'k','LineWidth',3);
        title(['YIELDERR time=',num2str(timesum/(365.25*24*3600)),' Yr'])
        % Viscosity distribution plotted on P-node.
        figure(3);
        colormap('Jet');
        pcolor(x/1000,y/1000,log10(ETAVP));% caxis([17 21])
        shading flat;
        axis ij image;
        colorbar
        title(['log10ETA, Pa*s timestep=',num2str(t),' time=',num2str(timesum/(365.25*24*3600)),' Yr'])
        
%       % Save figure
        namefig=['VepmyNODE_' num2str(t)];
        print ('-djpeg', '-r150',namefig);
        
        pause(0.1);
    end
end
figure(4);
plot(YIELDERRNODAL(1:500),'k','LineWidth',3);
title(['YIELDERR time=',num2str(timesum/(365.25*24*3600)),' Yr'])
