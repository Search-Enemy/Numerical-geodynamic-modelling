% "Adding inertia and comressiable to" global visco-elasto-plastic iterations on "Eulerian-NODE".
% THE KEY OF PROGRAM：
% LINE166,LINE488,LINE152-LINE160,LINE482-487,LINE753-LINE860
% LOOPSTART491,LOOPEND862
% 无论对欧拉点还是拉格朗日标记进行全局循环都会再次解stokes equ。
% 但前者不需要在每次迭代重新更新标记特性，除非进入了下一个timestep。
% adjust DTmax
clear all;clf;
% Set parameters
% Length of model
Lx = 100000; 
Ly = 100000;
x_mid = Lx/2;
y_mid = Ly/2;
% Sum of point number of model
Nx = 101; 
Ny = 101; 
Nx1 = Nx+1;
Ny1 = Ny+1;
% Interval of E-staggered-nodes
dx = Lx / (Nx-1);
dy = Ly / (Ny-1);
% Gravity acceleration
gx = 0;
gy = 0;
% Basic nodes.
x = 0:dx:Lx;
y = 0:dy:Ly;
% Vx staggered nodes.(Nx_node * Ny_node+1)
xvx = 0:dx:Lx+dx;
yvx = -dy/2 : dy : Ly+dy/2;
% Vy staggered nodes.(Nx_node+1 * Ny_node)
xvy = -dx/2 : dx : Lx+dx/2;
yvy = 0:dy:Ly+dy;
% P staggered nodes.(Nx_node+1 * Ny_node+1)
xp = -dx/2 : dx : Lx+dx/2;
yp = -dy/2 : dy : Ly+dy/2;

% Velocity and Pressure matrix
% Vx NODE
vx0 = zeros(Ny1,Nx1);
vx = zeros(Ny1,Nx1);
RHOVX=zeros(Ny1,Nx1); 
KVX=zeros(Ny1,Nx1); 
% Vy NODE
vy0 = zeros(Ny1,Nx1);
vy = zeros(Ny1,Nx1);
RHOVY=zeros(Ny1,Nx1); 
KVY=zeros(Ny1,Nx1); 
% P NODE
RHOP = zeros(Ny1,Nx1);
RHOPCP = zeros(Ny1,Nx1); %Den*Cp(hct)
ALPHAP = zeros(Ny1,Nx1);
BEITAP = zeros(Ny1,Nx1);
Hrij = zeros(Ny1,Nx1);
Haij = zeros(Ny1,Nx1);
Hsij = zeros(Ny1,Nx1);
ETAPVP = zeros(Ny1,Nx1);
GGGP = zeros(Ny1,Nx1);
EXX=zeros(Ny1,Nx1); % EPSILONxx, 1/s
SXX=zeros(Ny1,Nx1); % SIGMA'xx, 1/s
SXX0 = zeros(Ny1,Nx1);
T0 = zeros(Ny1,Nx1); %Told
T1 = zeros(Ny1,Nx1); %Tnew
P0 = zeros(Ny1,Nx1);
P = zeros(Ny1,Nx1);
% vx/vy at pnodes
pvx = zeros(Ny1,Nx1);
pvy = zeros(Ny1,Nx1);

% Basic node
ETAVP = zeros(Ny,Nx);
ETA = zeros(Ny,Nx);
GGG = zeros(Ny,Nx);
EXY = zeros(Ny,Nx);
SXY = zeros(Ny,Nx);
SXY0 = zeros(Ny,Nx);
wyx = zeros(Ny,Nx);
FRICT = zeros(Ny,Nx);
COSHE = zeros(Ny,Nx);
YYN = zeros(Ny,Nx);% Determine whether node meets yielding condition.

% Stokes-equ and continuity-equ
% Temperature-equ
% Amount of markers.
Nxm = 4*(Nx-1);
Nym = 4*(Ny-1);
marknum=Nxm*Nym;
% Step-length among L-marker points
dxm = Lx/Nxm;
dym = Ly/Nym;
% Marker points.
% Stokes-equ and continuity-equ
xm=zeros(1,marknum); % Horizontal coordinates, m
ym=zeros(1,marknum);
tm = zeros(1,marknum); % index of properties
tkm = zeros(1,marknum); % temperature
sxxm = zeros(1,marknum);
sxym = zeros(1,marknum);
etavpm = zeros(1,marknum);
p0m=zeros(1,marknum); % Marker pressure, Pa
vx0m=zeros(1,marknum); % Marker vx, m/s
vy0m=zeros(1,marknum); % Marker vy, m/s

% Parameters ()
rhom   = [3300   3200   1     ]; % Density, kg/m^3
etam   = [1e+23  1e+17  1e+17 ]; % Viscosity, Pa s
rhocpm = [3.3e+6 3.2e+6 3.3e+6]; % Volumetric heat capacity, kg/m^3
alpham = [3e-5   2e-5   0     ]; % Thermal expansion, 1/K
beitam = [1e-12,1e-12,1e-12];% Compressibility 1/Pa
km     = [3      2      3000  ]; % Thermal conductivity, W/m/K
hrm    = [2e-8   3e-8   0     ]; % Radiogenic heat production, W/m^3
gggm   = [1e+11  1e+11  1e+11 ]; % Shear Modulus, Pa
frictm = [0.6    0      0     ]; % Friction coefficient
coshesm = [1e+8   1e+7   1e+7  ]; % Cohesion, Pa (SeiGeMa_c)
etaweak = 1e17;
gggweak = 1e11;
m = 1;
for jm=1:1:Nxm
    for im=1:1:Nym
        % Define marker coordinates
        xm(m)=dxm/2+(jm-1)*dxm+(rand-0.5)*dxm;
        ym(m)=dym/2+(im-1)*dym+(rand-0.5)*dym;
        % Marker properties
        % "Strong Block(Mantle)" 
        tm(m) = 1;
        % "Squared inclusion(plume)"
        if(abs(xm(m)-x_mid)<5000 && abs(ym(m)-y_mid)<5000)
            tm(m) = 2;
        end
        % "Weak medium(striky)"
        if(ym(m)<0.2*Ly || ym(m)>0.8*Ly)
            tm(m) = 3;
        end
        tkm(m) = 273;
        etavpm(m) = etam(tm(m));
        % Update marker counter
        m=m+1;
    end
end

% Define matrix for Stokes
unknowns = Nx1*Ny1*3;
R  =   zeros(unknowns, 1);
coe = sparse(unknowns,unknowns);
% Define matrix for T
unknowns = Nx1*Ny1;
bt = zeros(unknowns,1);
coet = sparse(unknowns, unknowns);
 
% Boundary condition : free slip = -1 ; no slip = 1
bc_left   = -1;
bc_right  = -1;
bc_top    = -1;
bc_bottom = -1;
% Extension/shortening velocities
strainrate=1e-13; % Shortening strain rate
vxleft=strainrate*Lx/2;
vxright=-strainrate*Lx/2;
vytop=-strainrate*Ly/2;
vybottom=strainrate*Ly/2;
% In fact, bc of veloity is unchanged.
% vxleft   = 5e-9;
% vxright  = -5e-9;
% vytop    = -5e-9;
% vybottom = 5e-9;
% Pressure BC
PCONF=1e+8;
 
% Define dt for stokes equation.
dtelastic = 5e+7; % initial timestep
dt = dtelastic;
dtmin = 1e+6;
dxymax   = 0.01;
dtkoefv=1.1; % Koefficient to decrese dt for P,T,vx,vy,SIGMA limits 
dtkoef=2; % Koefficient to decrese dt in case of no convergence
dtstep=200; % Number of iterations before changing dt
dtkoefup=1.1; % 达到更改dt(dt/2)的循环迭代次数后，逐渐增加dt(1.1)但不会超过dtelastic
% "每一个时间步长，而不是每一个迭代"   ？？？下面数值从何而来
DTmax=20; % max temperature change per iteration step, K
DPmax = 1e9; % max pressure change per iteration step, Pa
DSmax = 1e9; % max stress change per time step.
subgrdifcoes =0; % Subgrid"Stress and Pressure(SXX,SXY,P)" diffusion parameter
subgrdifcoet=0; % Subgrid "temperature(T)" diffusion parameter
subgrdifcoev=0; % Subgrid "velocity(Vx,Vy)" diffusion parameter
timesum = 0;
minetavpm = 1e+17;
maxetavpm = 1e+23;
nloop=100000;
yerrmax =  3e+5;% Tolerance level for yielding error, Pa
terrmax=1e-3; % Tolerance level for temperature error, K
perrmax=3e+5; % Tolerance level for pressure error, Pa，下面三行是对应的存储数组
YIELDERRNODAL=zeros(1,nloop);
TEMERRNODAL = zeros(1,nloop);
PREERRNODAL = zeros(1,nloop);
% 400-->500
Nt = 500;
c = 1e-3;  % empirical coefficent
t = 1;
for t = t:1:Nt     
    
% Save old stresses
sxxm00=sxxm; 
sxym00=sxym;
% what items were added in this interpolation???
% Vx(vxnode),Vy(vynode),Beita(pnode)

    % BASCI NODE
    WTSUM = zeros(Ny,Nx);
    ETAVPSUM = zeros(Ny,Nx);
    GGGSUM = zeros(Ny,Nx);
    SXYSUM = zeros(Ny,Nx);
    ETASUM = zeros(Ny,Nx);
    FRICTSUM = zeros(Ny,Nx);
    COSHESUM = zeros(Ny,Nx);
    % Vx nodes    
    RHOXSUM=zeros(Ny1,Nx1);
    WTXSUM=zeros(Ny1,Nx1);
    KXSUM=zeros(Ny1,Nx1);
    VXSUM = zeros(Ny1,Nx1);
    % Vy nodes    
    RHOYSUM=zeros(Ny1,Nx1);
    WTYSUM=zeros(Ny1,Nx1);
    KYSUM=zeros(Ny1,Nx1);
    VYSUM = zeros(Ny1,Nx1);
    %Pnodes
    WTPSUM = zeros(Ny1,Nx1);% weights except T
    ETAPVPSUM = zeros(Ny1,Nx1);% Viscosity at P node
    SXXSUM = zeros(Ny1,Nx1);
    GGGPSUM = zeros(Ny1,Nx1);% miu at P node
    RHOSUM = zeros(Ny1,Nx1);% Density at P node
    HRSUM = zeros(Ny1,Nx1);  % Hr at P node
    ALPHASUM = zeros(Ny1,Nx1); % Aef at P node
    RHOCPSUM = zeros(Ny1,Nx1);% Den*Cp at P node
    BEITAPSUM = zeros(Ny1,Nx1);   %beita 1/Pa
    TKSUM = zeros(Ny1,Nx1); % T at P node
    P0SUM = zeros(Ny1,Nx1); % P0 at P node
    % Interpolate viscosity from markers to BASIC NODES.
    % Searching the coordinate of upper-left node of every L-marker.
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            ETAVPSUM(i,j)=ETAVPSUM(i,j)+etavpm(m)*wtmij;
            ETASUM(i,j)=ETASUM(i,j)+etam(tm(m))*wtmij;
            FRICTSUM(i,j)=FRICTSUM(i,j)+frictm(tm(m))*wtmij;
            COSHESUM(i,j)=COSHESUM(i,j)+coshesm(tm(m))*wtmij;
            GGGSUM(i,j)=GGGSUM(i,j)+1/gggm(tm(m))*wtmij;
            SXYSUM(i,j)=SXYSUM(i,j)+sxym(m)*wtmij;
            WTSUM(i,j)=WTSUM(i,j)+wtmij;
        end
        % i+1,j Node
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            ETAVPSUM(i+1,j)=ETAVPSUM(i+1,j)+etavpm(m)*wtmi1j;
            ETASUM(i+1,j)=ETASUM(i+1,j)+etam(tm(m))*wtmi1j;
            FRICTSUM(i+1,j)=FRICTSUM(i+1,j)+frictm(tm(m))*wtmi1j;
            COSHESUM(i+1,j)=COSHESUM(i+1,j)+coshesm(tm(m))*wtmi1j;
            GGGSUM(i+1,j)=GGGSUM(i+1,j)+1/gggm(tm(m))*wtmi1j;
            SXYSUM(i+1,j)=SXYSUM(i+1,j)+sxym(m)*wtmi1j;
            WTSUM(i+1,j)=WTSUM(i+1,j)+wtmi1j;
        end
        % i,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            ETAVPSUM(i,j+1)=ETAVPSUM(i,j+1)+etavpm(m)*wtmij1;
            ETASUM(i,j+1)=ETASUM(i,j+1)+etam(tm(m))*wtmij1;
            FRICTSUM(i,j+1)=FRICTSUM(i,j+1)+frictm(tm(m))*wtmij1;
            COSHESUM(i,j+1)=COSHESUM(i,j+1)+coshesm(tm(m))*wtmij1;
            GGGSUM(i,j+1)=GGGSUM(i,j+1)+1/gggm(tm(m))*wtmij1;
            SXYSUM(i,j+1)=SXYSUM(i,j+1)+sxym(m)*wtmij1;
            WTSUM(i,j+1)=WTSUM(i,j+1)+wtmij1;
        end
        % i+1,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            ETAVPSUM(i+1,j+1)=ETAVPSUM(i+1,j+1)+etavpm(m)*wtmi1j1;
            ETASUM(i+1,j+1)=ETASUM(i+1,j+1)+etam(tm(m))*wtmi1j1;
            FRICTSUM(i+1,j+1)=FRICTSUM(i+1,j+1)+frictm(tm(m))*wtmi1j1;
            COSHESUM(i+1,j+1)=COSHESUM(i+1,j+1)+coshesm(tm(m))*wtmi1j1;
            GGGSUM(i+1,j+1)=GGGSUM(i+1,j+1)+1/gggm(tm(m))*wtmi1j1;
            SXYSUM(i+1,j+1)=SXYSUM(i+1,j+1)+sxym(m)*wtmi1j1;
            WTSUM(i+1,j+1)=WTSUM(i+1,j+1)+wtmi1j1;
        end   
        % Interpolation to vx-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xvx(j);
        dis_y=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        RHOXSUM(i,j)=RHOXSUM(i,j)+rhom(tm(m))*wtmij;
        KXSUM(i,j)=KXSUM(i,j)+km(tm(m))*wtmij;
        VXSUM(i,j)=VXSUM(i,j)+vx0m(tm(m))*rhom(tm(m))*wtmij;
        WTXSUM(i,j)=WTXSUM(i,j)+wtmij;
        % i+1,j Node
        RHOXSUM(i+1,j)=RHOXSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        KXSUM(i+1,j)=KXSUM(i+1,j)+km(tm(m))*wtmi1j;
        VXSUM(i+1,j)=VXSUM(i+1,j)+vx0m(tm(m))*rhom(tm(m))*wtmi1j;
        WTXSUM(i+1,j)=WTXSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        RHOXSUM(i,j+1)=RHOXSUM(i,j+1)+rhom(tm(m))*wtmij1;
        KXSUM(i,j+1)=KXSUM(i,j+1)+km(tm(m))*wtmij1;
        VXSUM(i,j+1)=VXSUM(i,j+1)+vx0m(tm(m))*rhom(tm(m))*wtmij1;
        WTXSUM(i,j+1)=WTXSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        RHOXSUM(i+1,j+1)=RHOXSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        KXSUM(i+1,j+1)=KXSUM(i+1,j+1)+km(tm(m))*wtmi1j1;
        VXSUM(i+1,j+1)=VXSUM(i+1,j+1)+vx0m(tm(m))*rhom(tm(m))*wtmi1j1;
        WTXSUM(i+1,j+1)=WTXSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation to vy-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xvy(j);
        dis_y=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        RHOYSUM(i,j)=RHOYSUM(i,j)+rhom(tm(m))*wtmij;
        KYSUM(i,j)=KYSUM(i,j)+km(tm(m))*wtmij;
        VYSUM(i,j)=VYSUM(i,j)+vy0m(tm(m))*rhom(tm(m))*wtmij;
        WTYSUM(i,j)=WTYSUM(i,j)+wtmij;
        % i+1,j Node
        RHOYSUM(i+1,j)=RHOYSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        KYSUM(i+1,j)=KYSUM(i+1,j)+km(tm(m))*wtmi1j;
        VYSUM(i+1,j)=VYSUM(i+1,j)+vy0m(tm(m))*rhom(tm(m))*wtmi1j;
        WTYSUM(i+1,j)=WTYSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        RHOYSUM(i,j+1)=RHOYSUM(i,j+1)+rhom(tm(m))*wtmij1;
        KYSUM(i,j+1)=KYSUM(i,j+1)+km(tm(m))*wtmij1;
        VYSUM(i,j+1)=VYSUM(i,j+1)+vy0m(tm(m))*rhom(tm(m))*wtmij1;
        WTYSUM(i,j+1)=WTYSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        RHOYSUM(i+1,j+1)=RHOYSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        KYSUM(i+1,j+1)=KYSUM(i+1,j+1)+km(tm(m))*wtmi1j1;
        VYSUM(i+1,j+1)=VYSUM(i+1,j+1)+vy0m(tm(m))*rhom(tm(m))*wtmi1j1;
        WTYSUM(i+1,j+1)=WTYSUM(i+1,j+1)+wtmi1j1;
        % Interpolation to P-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            ETAPVPSUM(i,j)=ETAPVPSUM(i,j)+etavpm(m)*wtmij;
            GGGPSUM(i,j)=GGGPSUM(i,j)+1/gggm(tm(m))*wtmij;
            SXXSUM(i,j)=SXXSUM(i,j)+sxxm(m)*wtmij;
            RHOSUM(i,j)=RHOSUM(i,j)+rhom(tm(m))*wtmij;
            RHOCPSUM(i,j)=RHOCPSUM(i,j)+rhocpm(tm(m))*wtmij;
            ALPHASUM(i,j)=ALPHASUM(i,j)+alpham(tm(m))*wtmij;
            HRSUM(i,j)=HRSUM(i,j)+hrm(tm(m))*wtmij;
            TKSUM(i,j)=TKSUM(i,j)+tkm(m)*rhocpm(tm(m))*wtmij;
            BEITAPSUM(i,j)=BEITAPSUM(i,j)+beitam(tm(m))*wtmij;
            P0SUM(i,j) = P0SUM(i,j)+p0m(tm(m))*wtmij;
            WTPSUM(i,j)=WTPSUM(i,j)+wtmij;
        end
        % i+1,j Node
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            ETAPVPSUM(i+1,j)=ETAPVPSUM(i+1,j)+etavpm(m)*wtmi1j;
            GGGPSUM(i+1,j)=GGGPSUM(i+1,j)+1/gggm(tm(m))*wtmi1j;
            SXXSUM(i+1,j)=SXXSUM(i+1,j)+sxxm(m)*wtmi1j;
            RHOSUM(i+1,j)=RHOSUM(i+1,j)+rhom(tm(m))*wtmi1j;
            RHOCPSUM(i+1,j)=RHOCPSUM(i+1,j)+rhocpm(tm(m))*wtmi1j;
            ALPHASUM(i+1,j)=ALPHASUM(i+1,j)+alpham(tm(m))*wtmi1j;
            HRSUM(i+1,j)=HRSUM(i+1,j)+hrm(tm(m))*wtmi1j;
            TKSUM(i+1,j)=TKSUM(i+1,j)+tkm(m)*rhocpm(tm(m))*wtmi1j;
            BEITAPSUM(i+1,j)=BEITAPSUM(i+1,j)+beitam(tm(m))*wtmi1j;
            P0SUM(i+1,j) = P0SUM(i+1,j)+p0m(tm(m))*wtmi1j;
            WTPSUM(i+1,j)=WTPSUM(i+1,j)+wtmi1j;
        end
        % i,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            ETAPVPSUM(i,j+1)=ETAPVPSUM(i,j+1)+etavpm(m)*wtmij1;
            GGGPSUM(i,j+1)=GGGPSUM(i,j+1)+1/gggm(tm(m))*wtmij1;
            SXXSUM(i,j+1)=SXXSUM(i,j+1)+sxxm(m)*wtmij1;
            RHOSUM(i,j+1)=RHOSUM(i,j+1)+rhom(tm(m))*wtmij1;
            RHOCPSUM(i,j+1)=RHOCPSUM(i,j+1)+rhocpm(tm(m))*wtmij1;
            ALPHASUM(i,j+1)=ALPHASUM(i,j+1)+alpham(tm(m))*wtmij1;
            HRSUM(i,j+1)=HRSUM(i,j+1)+hrm(tm(m))*wtmij1;
            TKSUM(i,j+1)=TKSUM(i,j+1)+tkm(m)*rhocpm(tm(m))*wtmij1;
            BEITAPSUM(i,j+1)=BEITAPSUM(i,j+1)+beitam(tm(m))*wtmij1;
            P0SUM(i,j+1) = P0SUM(i,j+1)+p0m(tm(m))*wtmij1;
            WTPSUM(i,j+1)=WTPSUM(i,j+1)+wtmij1;
        end
        % i+1,j+1 Node
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            ETAPVPSUM(i+1,j+1)=ETAPVPSUM(i+1,j+1)+etavpm(m)*wtmi1j1;
            GGGPSUM(i+1,j+1)=GGGPSUM(i+1,j+1)+1/gggm(tm(m))*wtmi1j1;
            SXXSUM(i+1,j+1)=SXXSUM(i+1,j+1)+sxxm(m)*wtmi1j1;
            RHOSUM(i+1,j+1)=RHOSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
            RHOCPSUM(i+1,j+1)=RHOCPSUM(i+1,j+1)+rhocpm(tm(m))*wtmi1j1;
            ALPHASUM(i+1,j+1)=ALPHASUM(i+1,j+1)+alpham(tm(m))*wtmi1j1;
            HRSUM(i+1,j+1)=HRSUM(i+1,j+1)+hrm(tm(m))*wtmi1j1;
            TKSUM(i+1,j+1)=TKSUM(i+1,j+1)+tkm(m)*rhocpm(tm(m))*wtmi1j1;
            BEITAPSUM(i+1,j+1)=BEITAPSUM(i+1,j+1)+beitam(tm(m))*wtmi1j1;
            P0SUM(i+1,j+1) = P0SUM(i+1,j+1)+p0m(tm(m))*wtmi1j1;
            WTPSUM(i+1,j+1)=WTPSUM(i+1,j+1)+wtmi1j1;
        end
    end
    YYN=zeros(Ny,Nx);
    % Computing the value of density and viscosity of BASIC-NODE. 
    for j = 1:1:Nx
        for i = 1:1:Ny
            if(WTSUM(i,j)>0)
                % Not need RHO on the basic nodes.Just Y nodes.
                ETAVP(i,j) = ETAVPSUM(i,j)/WTSUM(i,j);%etaVp = eta in viscosity-elastic matreials.
                ETA(i,j) = ETASUM(i,j)/WTSUM(i,j);
                % 只有经过修正后的ETAVP才会小于ETA
                % 又因为修正代表该欧拉点满足应力屈服条件
                % 所以同时满足这两个条件的欧拉点需要标记为1（屈服）
                if(ETAVP(i,j)<ETA(i,j))
                    YYN(i,j) = 1;
                end
                FRICT(i,j) = FRICTSUM(i,j)/WTSUM(i,j);
                COSHE(i,j) = COSHESUM(i,j)/WTSUM(i,j);
                GGG(i,j) = WTSUM(i,j)/GGGSUM(i,j);
                SXY0(i,j) = SXYSUM(i,j)/WTSUM(i,j);
            end
        end
    end
    % Computing Density and K value at the VY and VX-nodes.
    for j=1:1:Nx1
        for i=1:1:Ny1
            % VY-nodes:(Nx1 * Ny) absent Ny1=0 !!!
            if(WTYSUM(i,j)>0)
                % rou_v
                RHOVY(i,j)=RHOYSUM(i,j)/WTYSUM(i,j);
                % K_v
                KVY(i,j)=KYSUM(i,j)/WTYSUM(i,j);
                % Vy
                vy0(i,j) = VYSUM(i,j)/RHOYSUM(i,j);
            end
            % VX-nodes:(Nx * Ny1)absent Nx1=0 !!!
            if(WTXSUM(i,j)>0)
                % rou_h
                RHOVX(i,j)=RHOXSUM(i,j)/WTXSUM(i,j);
                % K_h
                KVX(i,j) = KXSUM(i,j)/WTXSUM(i,j);
                % Vx
                vx0(i,j) = VXSUM(i,j)/RHOXSUM(i,j);
            end
        end
    end
    % Computing properities at P-node
    for j = 1:1:Nx1
        for i = 1:1:Ny1
            if(WTPSUM(i,j)>0)
                % 这一行不必要，答案没有写，后面会计算ETAVPs的平均值来作为ETAVPn
%                 ETAPVP(i,j) = ETAPVPSUM(i,j)/WTPSUM(i,j);%etaVP = eta in viscosity-elastic materials.
                GGGP(i,j) = WTPSUM(i,j)/GGGPSUM(i,j);
                SXX0(i,j) = SXXSUM(i,j)/WTPSUM(i,j);
                RHOP(i,j) = RHOSUM(i,j)/WTPSUM(i,j);
                Hrij(i,j) = HRSUM(i,j)/WTPSUM(i,j);
                ALPHAP(i,j) = ALPHASUM(i,j)/WTPSUM(i,j);
                RHOPCP(i,j) = RHOCPSUM(i,j)/WTPSUM(i,j);%Den*Cp
                T0(i,j)  = TKSUM(i,j)/RHOCPSUM(i,j);%T
                BEITAP(i,j) = BEITAPSUM(i,j)/WTPSUM(i,j);%beita
                P0(i,j) = P0SUM(i,j)/WTPSUM(i,j);%P0
            end
        end
    end
    % Why??
    % Apply boundary condition after interpolate T0 from markers(any t).
    % top and left Ctbc
    T0(1,2:Nx) = T0(2,2:Nx);
    T0(Ny1,2:Nx) = T0(Ny,2:Nx);
    % left and right Ibc
    T0(:,1) = T0(:,2);
    T0(:,Nx1) = T0(:,Nx);
    % Apply boundary condition for vx0 and vy0
    % Applying "VX-VELOCITY boundary" conditions for interpolated vx0
    % Upper 
    vx0(1,2:Nx-1)=-bc_top*vx0(2,2:Nx-1); % free slip
    % Lower 
    vx0(Ny1,2:Nx-1)=-bc_bottom*vx0(Ny,2:Nx-1); % free slip
    % Left 
    vx0(:,1)=vxleft; % no slip/constant velocity
    % Right 
    vx0(:,Nx)=vxright; % no slip/constant velocity
    % Applying "VY-VELOCITY boundary" conditions for interpolated vy0
    % Left 
    vy0(2:Ny-1,1)=-bc_left*vy0(2:Ny-1,2); % free slip
    % Right 
    vy0(2:Ny-1,Nx1)=-bc_right*vy0(2:Ny-1,Nx); % free slip
    % Upper
    vy0(1,:)=vytop; % no slip/constant velocity
    % Lower 
    vy0(Ny,:)=vybottom; % no slip/constant velocity
    % Apply P boundary condition for interpolated P0   ?????
    dp0=P0(2,2)-PCONF; % dp0 == 0;
    P0=P0-dp0;     
    p0m=p0m-dp0;
    
    
    % 假设第一次循环时，必定不会满足容许误差限，所以dt/2
    % 然后在之后的每一个timestep 都要逐渐增加dt,但不会超过5e7.
    dt = min(dtkoefup*dt,dtelastic);
    % 传递（old）YNN（屈服标记）与ETAVP（miusvp）
    YYN00 = YYN;
    ETAVP00 = ETAVP;% ETAVP at "every timestep" instead of "every loop(200)"
    T1 = T0;
    % 定义达到改变dt的临界迭代次数(200)变量
    icount = 0;
    % Mechanical Solution
for iloop=1:1:nloop
        
    % etaweak == etamin;gggweak == gggmin
    NSetavpmin = max(etaweak,c*dt*min(min(GGG)));% ???max
    % Limit viscosity in the basic nodes
    for i=1:1:Ny
        for j=1:1:Nx
            if(ETAVP(i,j)<NSetavpmin)
                ETAVP(i,j)=NSetavpmin;
            end
        end
    end
    Kcont  = NSetavpmin/dx;   
    % ETAPVP was only computed at this.
    for i=2:1:Ny
        for j=2:1:Nx
            ETAPVP(i,j)=1/((1/ETAVP(i-1,j-1)+1/ETAVP(i,j-1)+1/ETAVP(i-1,j)+1/ETAVP(i,j))/4);
        end
    end
    % Solve Stokes-equ and Continuity-equ.
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global indexes in algebraic space
            kvx=((j-1)*Ny1+i-1)*3+1; % Vx
            kvy=kvx+1; % Vy
            kpm=kvx+2; % P
            
            % Vx equation External points
            if(i==1 || i==Ny1 || j==1 || j==Nx || j==Nx1)
                % Boundary Condition
                % Ghost points.
                % 1*Vx=0
                if (j==Nx1)
                    coe(kvx,kvx)=1; % Left part
                    R(kvx)=0; % Right part
                end
                % Left boundary(prescribe vx)
                if (j==1 )
                    coe(kvx,kvx)=1; % Left part
                    R(kvx)=vxleft; % Right part
                end
                % Right boundary(prescribe vx)
                if (j==Nx)
                    coe(kvx,kvx)=1; % Left part
                    R(kvx)=vxright; % Right part
                end
                % Top boundary(free slip)
                if(i==1 && j>1 && j<Nx)
                    coe(kvx,kvx)=1; % Left part
                    coe(kvx,kvx+3)=bc_top; % Left part
                    R(kvx)=0; % Right part
                end
                % Bottom boundary(free slip)
                if(i==Ny1 && j>1 && j<Nx)
                    coe(kvx,kvx)=1; % Left part
                    coe(kvx,kvx-3)=bc_bottom; % Left part
                    R(kvx)=0; % Right part
                end
            else
                % Internal points: x-Stokes eq.
                % ETA*(d2Vx/dx^2+d2Vx/dy^2)-dP/dx=0
                %            Vx2
                %             |
                %        Vy1  |  Vy3
                %             |
                %     Vx1-P1-Vx3-P2-Vx5
                %             |
                %        Vy2  |  Vy4
                %             |
                %            Vx4
                %
                % Density gradients
                dRHOdx=(RHOVX(i,j+1)-RHOVX(i,j-1))/2/dx;
                dRHOdy=(RHOVX(i+1,j)-RHOVX(i-1,j))/2/dy;
                % Modify parameters
                ETAPMIU2 = dt*GGGP(i,j+1)*ETAPVP(i,j+1)/(GGGP(i,j+1)*dt+ETAPVP(i,j+1));
                ETAPMIU1 = dt*GGGP(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));                
                ETAMIU1 =  dt*GGG(i-1,j)*ETAVP(i-1,j)/(GGG(i-1,j)*dt+ETAVP(i-1,j));
                ETAMIU2 =  dt*GGG(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
                % Stress
                SXX2 = SXX0(i,j+1)*ETAPVP(i,j+1)/(GGGP(i,j+1)*dt+ETAPVP(i,j+1));
                SXX1 = SXX0(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));      
                SXY2 = SXY0(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
                SXY1 = SXY0(i-1,j)*ETAVP(i-1,j)/(GGG(i-1,j)*dt+ETAVP(i-1,j));
                % Left part
                coe(kvx,kvx-Ny1*3)=2*ETAPMIU1/dx^2  ; % Vx1(i,j-1)
                coe(kvx,kvx-3)=ETAMIU1/dy^2          ; % Vx2(i-1,j)
                coe(kvx,kvx)=-2*(ETAPMIU2+ETAPMIU1)/dx^2 ...
                               -(ETAMIU2+ ETAMIU1) /dy^2 - gx*dt*dRHOdx   - RHOVX(i,j)/dt; % Vx3(i,j)
                coe(kvx,kvx+3)=ETAMIU2/dy^2      ; % Vx4(i+1,j)
                coe(kvx,kvx+Ny1*3)=2*ETAPMIU2/dx^2    ; % Vx5(i,j+1)
                coe(kvx,kvy)      = -ETAMIU2/dy/dx -dRHOdy*gx*dt/4  ;  % Vy2(i,j)
                coe(kvx,kvy+Ny1*3)= ETAMIU2/dy/dx  -dRHOdy*gx*dt/4   ;  % Vy4(i,j+1)
                coe(kvx,kvy-3)    = ETAMIU1/dx/dy -dRHOdy*gx*dt/4  ;  % Vy1(i-1,j)
                coe(kvx,kvy+Ny1*3-3)= -ETAMIU1/dx/dy -dRHOdy*gx*dt/4  ;  % Vy3(i-1,j+1)
                coe(kvx,kpm)=Kcont/dx; % P1(i,j)
                coe(kvx,kpm+Ny1*3)=-Kcont/dx; % P2(i,j+1)

                % Right part !!!
                R(kvx)=-RHOVX(i,j)*(gx + vx0(i,j)/dt) -(SXX2-SXX1) /dx...
                                       -(SXY2-SXY1)/dy ;
            end
            
            % Vy equation External points
            if(j==1 || j==Nx1 || i==1 || i==Ny || i==Ny1)
                % Boundary Condition
                % Ghost points.
                % 1*Vy=0
                if (i == Ny1)
                    coe(kvy,kvy)=1; % Left part
                    R(kvy)=0; % Right part
                end
                % Up boundary(prescribe v)
                if (i == 1)
                    coe(kvy,kvy)=1; % Left part
                    R(kvy)=vytop; % Right part
                end
                % Down boundary(prescribe v)
                if (i == Ny)
                    coe(kvy,kvy)=1; % Left part
                    R(kvy)=vybottom; % Right part
                end
                % Left boundary(free slip)
                if(j==1 && i>1 && i<Ny)
                    coe(kvy,kvy)=1; % Left part
                    coe(kvy,kvy+3*Ny1)=bc_left; % Left part
                    R(kvy)=0; % Right part
                end
                % Right boundary(free slip)
                if(j==Nx1 && i>1 && i<Ny)
                    coe(kvy,kvy)=1; % Left part
                    coe(kvy,kvy-3*Ny1)=bc_right; % Left part
                    R(kvy)=0; % Right part
                end
            else
                % Internal points: y-Stokes eq.
                % ETA*(d2Vy/dx^2+d2Vy/dy^2)-dP/dy=-RHO*gy
                %            Vy2
                %             |
                %         Vx1 P1 Vx3
                %             |
                %     Vy1----Vy3----Vy5
                %             |
                %         Vx2 P2 Vx4
                %             |
                %            Vy4
                %
                % Viscosity points
                dRHOdx=(RHOVY(i,j+1)-RHOVY(i,j-1))/2/dx;
                dRHOdy=(RHOVY(i+1,j)-RHOVY(i-1,j))/2/dy;
                ETAPMIU2 = 2*dt*GGGP(i+1,j)*ETAPVP(i+1,j)/(GGGP(i+1,j)*dt+ETAPVP(i+1,j));
                ETAPMIU1 = 2*dt*GGGP(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));
                ETAMIU1  = 2*dt*GGG(i,j-1)*ETAVP(i,j-1)/(GGG(i,j-1)*dt+ETAVP(i,j-1));
                ETAMIU2  = 2*dt*GGG(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));        
                SYY2 = -SXX0(i+1,j)*ETAPVP(i+1,j)/(GGGP(i+1,j)*dt+ETAPVP(i+1,j));
                SYY1 = -SXX0(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));      
                SYX2 = SXY0(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
                SYX1 = SXY0(i,j-1)*ETAVP(i,j-1)/(GGG(i,j-1)*dt+ETAVP(i,j-1));
                % Left part
                coe(kvy,kvy-Ny1*3)=ETAMIU1/2/dx^2    ; % Vy1(i,j-1)
                coe(kvy,kvy-3)=ETAPMIU1/dy^2    ; % Vy2(i-1,j)
                coe(kvy,kvy)=-ETAPMIU1/dy^2-ETAPMIU2/dy^2 ...
                             -ETAMIU2/2/dx^2-ETAMIU1/2/dx^2 - dRHOdy*gy*dt     - RHOVY(i,j)/dt; % Vy3(i,j)
                coe(kvy,kvy+3)=ETAPMIU2/dy^2   ; % Vy4(i+1,j)
                coe(kvy,kvy+Ny1*3)=ETAMIU2/2/dx^2   ; % Vy5(i,j+1)
                coe(kvy,kvx)= - ETAMIU2/2/dx/dy    -dRHOdx*gy*dt/4; %Vx3(i,j)
                coe(kvy,kvx+3)=  ETAMIU2/2/dx/dy   -dRHOdx*gy*dt/4; %Vx4(i+1,j)
                coe(kvy,kvx-Ny1*3)= ETAMIU1/2/dx/dy    -dRHOdx*gy*dt/4; %Vx1(i,j-1)
                coe(kvy,kvx+3-Ny1*3)= - ETAMIU1/2/dx/dy     -dRHOdx*gy*dt/4; %Vx2(i+1,j-1)
                coe(kvy,kpm)=Kcont/dy; % P1
                coe(kvy,kpm+3)=-Kcont/dy; % P2
                
                % Right part
                R(kvy)=-RHOVY(i,j)*(gy + vy0(i,j)/dt) - (SYY2-SYY1)/dy...
                                      - (SYX2-SYX1)/dx;
            end
            
            % P equation External points
            if(i==1 || j==1 || i==Ny1 || j==Nx1)
                % Boundary Condition
                % 1*P=0
                coe(kpm,kpm)=1; % Left part
                R(kpm)=0; % Right part  !!!
            else
                % Internal points: continuity eq.
                % dVx/dx+dVy/dy=0
                %            Vy1
                %             |
                %        Vx1--P--Vx2
                %             |
                %            Vy2
                %
                % Left part
                coe(kpm,kvx-Ny1*3)=-1/dx; % Vx1
                coe(kpm,kvx)=1/dx; % Vx2
                coe(kpm,kvy-3)=-1/dy; % Vy1
                coe(kpm,kvy)=1/dy; % Vy2
                coe(kpm,kpm) = Kcont*BEITAP(i,j)/dt;
                % Right part
                R(kpm)=0 + P0(i,j)*BEITAP(i,j)/dt  + ALPHAP(i,j)*(T1(i,j)-T0(i,j))/dt;
            end
        end
    end
    % Computing the solution U:include vx,vy and p
    U = coe \ R;
    % Decompose the solution of global matrix. 
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global indexes in algebraic space
            kvx=((j-1)*Ny1+i-1)*3+1; % Vx
            kvy=kvx+1; % Vy
            kpm=kvx+2; % P
            % Reload solution
            vx(i,j)=U(kvx);
            vy(i,j)=U(kvy);
            P(i,j)=U(kpm)*Kcont;
        end
    end
    DVX = vx-vx0;
    DVY = vy-vy0;

    EXY = zeros(Ny,Nx);
    SXY = zeros(Ny,Nx);
    DSXY = zeros(Ny,Nx);
    % Computing strain rate(xy) and deviatoric(xy) stress components.
    for j = 1:1:Nx
        for i = 1:1:Ny
            %ETAVP = ETA,which plastic is absent.
            EXY(i,j) = (1/2)*( (vx(i+1,j)-vx(i,j))/dy + (vy(i,j+1)-vy(i,j))/dx ) ;
            % srxy is strain rate,sxy is stressxy
            SXY(i,j) = 2*ETAVP(i,j)*EXY(i,j) *GGG(i,j)*dt/(GGG(i,j)*dt+ETAVP(i,j)) ...
                                  + SXY0(i,j) * (  ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j)));
            DSXY(i,j) = SXY(i,j) - SXY0(i,j);
        end
    end
    % Define second invariant value of stress and strain rate.
    EXX = zeros(Ny1,Nx1);
    SXX = zeros(Ny1,Nx1);
    EII = zeros(Ny1,Nx1);
    SII = zeros(Ny1,Nx1);
    DSXX = zeros(Ny1,Nx1);
    DP = zeros(Ny1,Nx1);
    % Computing strain rate(xx) and deviatoric(xx) stress components.
    for j = 2:1:Nx
        for i = 2:1:Ny        
            % Note that EXX is not the 1/2 item in the chapter13 of book.
            % Note that EXX is the 1/2 item in the chapter14 of book.
            EXX(i,j) =  0.5*((vx(i,j)-vx(i,j-1))/dx-(vy(i,j)-vy(i-1,j))/dy);
            % srxx is strain rate,sxx is stressxx
            SXX(i,j) = 2*ETAPVP(i,j)*EXX(i,j)*GGGP(i,j)*dt/(GGGP(i,j)*dt+ETAPVP(i,j)) ...
                                   + SXX0(i,j) * (  ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j)));
            DSXX(i,j) = SXX(i,j) - SXX0(i,j);
            % The second invariant value.
            EII(i,j) = ( EXX(i,j)^2 + ((EXY(i-1,j)   + EXY(i,j-1) ...
                             + EXY(i-1,j-1) + EXY(i,j))/4)^2 )^0.5;
            SII(i,j) = ( SXX(i,j)^2 + ((SXY(i-1,j)   + SXY(i,j-1) ...
                + SXY(i-1,j-1) + SXY(i,j))/4)^2 )^0.5;
            DP(i,j) = P(i,j) - P0(i,j);
                   
        end
    end
    
    Hsij = zeros(Ny1,Nx1);
    for j = 2:1:Nx
        for i = 2:1:Ny   
            pxyxy = (1/4)*( SXY(i,j)^2/ETAVP(i,j)   + SXY(i-1,j)^2/ETAVP(i-1,j)...
                          + SXY(i,j-1)/ETAVP(i,j-1) + SXY(i-1,j-1)/ETAVP(i-1,j-1));
            % Shear heating Hs
            Hsij(i,j) = SXX(i,j)^2/ETAPVP(i,j)+ pxyxy;
        end
    end
    Haij = zeros(Ny1,Nx1);
    % Adiabatic heating Ha
    for j = 2:1:Nx
        for i = 2:1:Ny
%             kvy = ( vy(i,j)+vy(i-1,j) )/2;
%             kvx = ( vx(i,j)+vx(i,j-1) )/2;
%             Haij(i,j) = T0(i,j)*Aefij(i,j)*RHOP(i,j)*(gy*kvy+gx*kvx);
                 Haij(i,j) = T0(i,j)*ALPHAP(i,j)*(P(i,j) - P0(i,j))/dt;
        end
    end
    % Solve temperature equation.

    % Insulating boundary condition.
    % Up and down
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global index in algebraic space
            kt=(j-1)*Ny1+i;
            % External points
            if(i==1 || i==Ny1 || j==1 || j==Nx1)
                % Boundary Condition
                % Top BC: i
                if(i==1 && j>1 && j<Nx1)
                    coet(kt,kt)=1; % Left part
                    coet(kt,kt+1)=-1; % Left part
                    bt(kt)=0; % Right part
                end
                % Bottom BC: i
                if(i==Ny1 && j>1 && j<Nx1)
                    coet(kt,kt)=1; % Left part
                    coet(kt,kt-1)=-1; % Left part
                    bt(kt)=0; % Right part
                end
                % Left BC: i
                if(j==1)
                    coet(kt,kt)=1; % Left part
                    coet(kt,kt+Ny1)=-1; % Left part
                    bt(kt)=0; % Right part
                end
                % Right BC: i
                if(j==Nx1)
                    coet(kt,kt)=1; % Left part
                    coet(kt,kt-Ny1)=-1; % Left part
                    bt(kt)=0; % Right part
                end
            else
                % Internal points: Temperature eq.
                % Left part
                % KVX == Kh;KVY == Kv
                khij  = KVX(i,j);
                khij1 = KVX(i,j-1);
                kvij  = KVY(i,j);
                kvi1j = KVY(i-1,j);
                % Not 2* why?? page177
                coet(kt, kt) = (khij+khij1)/dx^2+RHOPCP(i,j)/dt...
                    +(kvij+kvi1j)/dy^2;% middle T3 i,j
                coet(kt, kt-1) = -(kvi1j)/(2.*dy.^2); % up T2 i-1,j
                coet(kt, kt+1) = -(kvij)/(2.*dy.^2); % down T4 i+1,j
                coet(kt, kt-Ny1) = -(khij1)/(dx.^2); % left T1 i,j-1
                coet(kt, kt+Ny1) = -(khij)/(dx.^2); % right T5 i,j+1
                % !!!Note that there are not advection term because MIC have
                % marker transport.!!!
                % Adding H(P-nodes)
                bt(kt, 1) = T0(i,j)*RHOPCP(i,j)/dt + Hrij(i,j) + Haij(i,j) + Hsij(i,j);
            end
        end
    end
    
    % Direct method:right martix is divided by coe martix on the left
    u = coet \ bt;
    % transform vector to grids
    % U has Ny1 rows and Nx1 columns
    U = reshape(u, Ny1, Nx1);
    T1 = U;
    % Computing T1-T0 = dTi,j = dTi,j(subgrid) + dTi,j(remaining)
    % Eq10.13
    dTij = T1-T0;

    P(:,1)  = P(:,2);
    P(:,Nx1)= P(:,Nx);
    P(1,:)  = P(2,:);
    P(Ny1,:)= P(Ny,:);
    P0(:,1)=P0(:,2);
    P0(:,Nx1)=P0(:,Nx);
    P0(1,:)=P0(2,:);
    P0(Ny1,:)=P0(Ny,:);
    SXX(:,1)=SXX(:,2);
    SXX(:,Nx1)=SXX(:,Nx);
    SXX(1,:)=SXX(2,:);
    SXX(Ny1,:)=SXX(Ny,:);
    SXX0(:,1)=SXX0(:,2);
    SXX0(:,Nx1)=SXX0(:,Nx);
    SXX0(1,:)=SXX0(2,:);
    SXX0(Ny1,:)=SXX0(Ny,:);
    
    
    ETA5=ETA; % 传递老mius 而不是miusvp ，在每一次timestep
    YYN5=zeros(Ny,Nx);% 设置一个中间变量来传递“屈服标记矩阵”
    % "Update ETAVP(i,j)"
    DIJYIELD = 0;
    NIJPLAST = 0;
    % Iterate over BASIC-NODE.
    for j = 1:Nx
        for i = 1:Ny
            syieldij = COSHE(i,j)+FRICT(i,j)*(P(i,j)+P(i+1,j)+P(i,j+1)+P(i+1,j+1))/4;
            syieldij = max(syieldij,0);
            siiij = (SXY(i,j)^2 + (1/16)*(SXX(i,j)+SXX(i+1,j)+SXX(i,j+1)+SXX(i+1,j+1))^2)^0.5;
            % "NOTE THAT" 13.50 is different with below line.
            siielaij = siiij*(GGG(i,j)*dt+ETAVP(i,j))/ETAVP(i,j);
            % Check whather each marker has been checked.0 is no,1 is yes.
            ynij = 0;%首先假定每一个欧拉点都不屈服
            % By default, each marker is subject to stress conditions???
            if(YYN(i,j) > 0)
                ynij = 1;%如果老欧拉点屈服，表明满足应力与粘度条件ynij=1
                NIJPLAST = NIJPLAST + 1;
                DIJYIELD = DIJYIELD + (siiij-syieldij)^2;
            end
            % ETAVP(i,j) = ETA(i,j);
            if(syieldij<siielaij)
                % 满足应力屈服条件则更新粘度miuvp
                ETAVPij = GGG(i,j)*dt*syieldij/(siielaij-syieldij);
                if(ETAVPij < ETA(i,j))                
                    % 满足应力与粘度条件则应用于下一次循环，否则该欧拉点保持原来粘度。
                    % 并且标记屈服1于此欧拉点
                    ETA5(i,j) = ETAVPij; 
                    YYN5(i,j) = 1;
                    % 要注意在m13_2中的更新粘度有上下界
%                     minetavpm = min(etaweak,c*dt*gggweak);
                    if(ETA5(i,j)<minetavpm)
                        ETA5(i,j)=minetavpm;
                    elseif(ETA5(i,j)>maxetavpm)
                        ETA5(i,j)=maxetavpm;
                    end
                    if(ynij ==0 )
                        % 如果该欧拉点是之前不屈服，经过修正后屈服的                        
                        NIJPLAST = NIJPLAST + 1;
                        DIJYIELD = DIJYIELD + (siiij-syieldij)^2;
                        % 如果欧拉点之前屈服，经过修正后仍然屈服的
                        % 不进行累计 
                        % 或者说：
                        %ynn = 1的即已经计算误差并累计的此处不再计算
                        %并且以前不屈服的，现在屈服了进行累计。
                        %排除掉以前屈服的现在也屈服的，也就是说不对其进行累计。
                    end
                else
                    % 如果满足应力条件但不满足粘度条件则不更新粘度
                    % 使用老粘度mius以及屈服标记0
                    ETA5(i,j) =ETA(i,j);
                    YYN5(i,j) = 0;
                end
                % Setoff tolerance level.
            else
                % 如不满足应力条件则也不更新粘度；
                % 使用老粘度mius以及屈服标记0
                ETA5(i,j) = ETA(i,j);
                YYN5(i,j) = 0;
            end
        end
    end
    % Compute yielding error
    % 如果有至少一个点满足屈服条件，那么就需要计算误差
    if(NIJPLAST>0)
        YIELDERRNODAL(iloop)=(DIJYIELD/NIJPLAST)^0.5;
    end
    % Apply criteria for decreasing the timestep
    yndt=0;
    
    % Define displacement timestep dtm
    dtm=dt;
    maxvx=max(max(abs(vx)));
    maxvy=max(max(abs(vy)));
    if(dtm*maxvx>dxymax*dx)
        dtm=dxymax*dx/maxvx/dtkoefv;
        yndt=1;
    end
    if(dtm*maxvy>dxymax*dy)
        dtm=dxymax*dy/maxvy/dtkoefv;
        yndt=1;
    end
    
    % Apply maximal stress change condition
    dts=dt;
    maxDScurrent=max(max(max(abs(DSXX))),max(max(abs(DSXY))));
    if(maxDScurrent>DSmax)
        dts=dts/maxDScurrent*DSmax/dtkoefv;
        yndt=1;
    end
    
    % Apply pressure timestepping condition
    dtp=dt;
    maxDPcurrent=max(max(abs(DP)));
    if(maxDPcurrent>DPmax)
        dtp=dtp/maxDPcurrent*DPmax/dtkoefv;
        yndt=1;
    end
    
    % Apply thermal timestepping condition
    dtt=dt;
    maxDTcurrent=max(max(abs(dTij)));
    if(maxDTcurrent>DTmax)
        dtt=dtt/maxDTcurrent*DTmax/dtkoefv;
        yndt=1;
    end
    
    % Decrease computational timestep if too many iterations
    dtpl=dt;
    if(fix((icount+1)/dtstep)*dtstep==(icount+1))
        % Decrease timestep
        dtpl=dtpl/dtkoef;  % 达到200次循环后对dt进行缩减2倍
        yndt=1;
    end
    
    % Check if further dt reduction possible
    if(dt<=dtmin)
        yndt=0;
    end
    
    % Reset dt, restart iteration
    ynstop=0;
    if(yndt>0)
        % 如果T,M,P,LOOP,S的差异大于容许值则需要重置粘度使用老VP粘度
        % 然后重新进行判断，并“重新迭代”
        dt=max(dtmin,min([dtt, dtm, dts, dtpl, dtp]));
        % Reset old viscoplastic viscosity, temperature
        ETAVP=ETAVP00;
        YYN=YYN00;
        T1 = T0;
    elseif(icount>0)
        % 不更改dt时，只需对循环内(200次)的粘度进行更新，或达到截止条件时跳出iterations
        % Check max P,T change between iterations
        TEMERRNODAL(iloop)=max(max(abs(dTij-DT0)));
        PREERRNODAL(iloop)=max(max(abs(DP-DP0)));
        % Stop iteration
        % 达到3个条件之一“并且T与P满足误差容许值”，则停止循环
        % 1、没有达到屈服的node点（一般不会）开始的100左右timestep可能会；
        % 2、达到最大迭代次数100000次（一般不会）；
        % 3、本次屈服误差小于容许值3e5（一般会）
        % Repeat iteration（最大次数为100000/200次）
        if(TEMERRNODAL(iloop)<terrmax && PREERRNODAL(iloop)<perrmax && ...
                (NIJPLAST==0 || iloop==nloop || YIELDERRNODAL(iloop)<yerrmax))
            ynstop=1;
            % Repeat iteration
        elseif(NIJPLAST>0)
            % 第N>2次循环时，如果有至少一个欧拉点满足12屈服条件，就要使用修正的的ETAVP值
            ETAVP=ETA5;
            YYN=YYN5;
        end
    % 第一次循环时，如果有至少一个欧拉点满足12屈服条件，就要使用修正的的ETAVP值
    elseif(NIJPLAST>0)
        % Use new viscoplastic viscosity
        ETAVP=ETA5;
        YYN=YYN5;
    end
    % Save Last DT and DP
    DT0=dTij;
    DP0=DP;
    % 其实判断下面行的过程在每一个timestep只有一次
    % 如果硬性5个差异条件至少有一个不满足容许误差或迭代条件达到200次时
    % 才重置icount
    % 否则只需对icount进行累加
    % icount最大为199(此时重置并dt/2)，原因为dt太大，多次迭代仍不足以满足截止条件
    if(yndt>0)
        icount=0;
    else
        icount=icount+1;
    end
    % ynstop == 1意味着循环截止条件达到，此时只需跳出iterations
    % 否则不跳出
    if(ynstop>0)
        break;
    end
    % End Plastic iterations on Nodes
end


    for m = 1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        if(YYN(i,j)>0 || YYN(i+1,j)>0 || YYN(i,j+1)>0 || YYN(i+1,j+1)>0)            
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            etavpm(m)= 1/(YYN(i,j)*wtmij   /ETAVP(i,j)   + YYN(i+1,j)*wtmi1j   /ETAVP(i+1,j)  ...
                         +YYN(i,j+1)*wtmij1/ETAVP(i,j+1) + YYN(i+1,j+1)*wtmi1j1/ETAVP(i+1,j+1));
            % 限制粘度？？？
            if(etavpm(m)>=etam(tm(m)))
                etavpm(m)=etam(tm(m));
            end
        else
            % 如果该次timestep迭代中该m个marker对应的周围四个欧拉点没有屈服
            % 则不需要更新粘度只需使用最初粘度进入下一个timestep。
            etavpm(m)=etam(tm(m));    
        end
    end
    
    % Reset displacement timestep
    % 保证整个程序都使用相同的dt(dtm==dtT==dt)，粘度迭代修改后的dt。
    dtm=dt;
    %  This
    
    % Computing "STRESS" and "Pressure"subgrid diffusion for markers
    if (subgrdifcoes>0)
        % Existence of subgrid diffusion.
        % Page162 How to correct the problem ?
        % operating  consistent subgrid diffusion .
        % Clear subgrid temperature changes(dTijsub) for nodes
        % P-NODES
        WPNODES = zeros(Ny1,Nx1);
        SXXSUM = zeros(Ny1,Nx1);
        P0SUM = zeros(Ny1,Nx1);
        % Basic-NODES        
        WNODES = zeros(Ny,Nx);
        SXYSUM = zeros(Ny,Nx);
        % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
        for m = 1:marknum
            % Interpolate T to P-NODES(Nx*Ny)
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            sxxm0nodal= SXX0(i,j)*wtmij + SXX0(i+1,j)*wtmi1j  ...
                                     + SXX0(i,j+1)*wtmij1 + SXX0(i+1,j+1)*wtmi1j1;
            p0mnodal = P0(i,j)*wtmij + P0(i+1,j)*wtmi1j  ...
                                   +P0(i,j+1)*wtmij1 + P0(i+1,j+1)*wtmi1j1;
            j=fix((xm(m)-x(1))/dx)+1;
            i=fix((ym(m)-y(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-x(j);
            dis_y=ym(m)-y(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            sxym0nodal= SXY0(i,j)*wtmij + SXY0(i+1,j)*wtmi1j  ...
                +SXY0(i,j+1)*wtmij1 + SXY0(i+1,j+1)*wtmi1j1;
            % NOTE THAT the answer is sxxm(m)-sxxm0nodal.
            % Eq.10.14
            dsxxm0 = sxxm0nodal - sxxm(m);
            dp0m     = p0mnodal - p0m(m);
            dsxym0 = sxym0nodal - sxym(m);
            % Page209
            tdiff = etam(tm(m))/gggm(tm(m));
            % Computing subgrid diffusion
            % Why??
            % dve = 0;%209,0<dve<1
            sdif=-subgrdifcoes*dtm/tdiff;
            % Page162 Eq.10.16
            dsxxmsub=dsxxm0*(1-exp(sdif));
            dp0msub = dp0m*(1-exp(sdif));
            dsxymsub=dsxym0*(1-exp(sdif));

            % Eq.10.19
            % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
            sxxm(m) = sxxm(m) + dsxxmsub;
            p0m(m)  = p0m(m) + dp0msub;
            sxym(m) = sxym(m) + dsxymsub;
            % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
            % Eq.10.17
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                SXXSUM(i,j) = SXXSUM(i,j) + dsxxmsub*wtmij;
                P0SUM(i,j) = P0SUM(i,j) + dp0msub*wtmij;
                WPNODES(i,j) = WPNODES(i,j) + wtmij;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                SXXSUM(i+1,j) = SXXSUM(i+1,j) + dsxxmsub*wtmi1j;
                P0SUM(i+1,j) = P0SUM(i+1,j) + dp0msub*wtmi1j;
                WPNODES(i+1,j) = WPNODES(i+1,j) + wtmi1j;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                SXXSUM(i,j+1) = SXXSUM(i,j+1) + dsxxmsub*wtmij1;
                P0SUM(i,j+1) = P0SUM(i,j+1) + dp0msub*wtmij1;
                WPNODES(i,j+1) = WPNODES(i,j+1) + wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                SXXSUM(i+1,j+1) = SXXSUM(i+1,j+1) + dsxxmsub*wtmi1j1;
                P0SUM(i+1,j+1) = P0SUM(i+1,j+1) + dp0msub*wtmi1j1;
                WPNODES(i+1,j+1) = WPNODES(i+1,j+1) + wtmi1j1;
            end
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-x(1))/dx)+1;
            i=fix((ym(m)-y(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-x(j);
            dis_y=ym(m)-y(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                SXYSUM(i,j) = SXYSUM(i,j) + dsxymsub*wtmij;
                WNODES(i,j) = WNODES(i,j) + wtmij;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                SXYSUM(i+1,j) = SXYSUM(i+1,j) + dsxymsub*wtmi1j;
                WNODES(i+1,j) = WNODES(i+1,j) + wtmi1j;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                SXYSUM(i,j+1) = SXYSUM(i,j+1) + dsxymsub*wtmij1;
                WNODES(i,j+1) = WNODES(i,j+1) + wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                SXYSUM(i+1,j+1) = SXYSUM(i+1,j+1) + dsxymsub*wtmi1j1;
                WNODES(i+1,j+1) = WNODES(i+1,j+1) + wtmi1j1;
            end
        end
        dsxxijsub = zeros(Ny1,Nx1);
        dp0ijsub = zeros(Ny1,Nx1);
        dsxyijsub = zeros(Ny,Nx);
        % P-NODES
        for j=2:1:Nx
            for i=2:1:Ny
                if(WPNODES(i,j)>0)
                    dsxxijsub(i,j)=SXXSUM(i,j)/WPNODES(i,j);
                    dp0ijsub(i,j) = P0SUM(i,j)/WPNODES(i,j);
                end
            end
        end
        % Basic nodes
        for j=1:1:Nx
            for i=1:1:Ny
                if(WNODES(i,j)>0)
                    dsxyijsub(i,j) = SXYSUM(i,j)/WNODES(i,j);
                end
            end
        end
        % Eq.10.18
        % Update dTij(dTij(remain) = dTij - dTij(sub)  )
        DSXX = DSXX - dsxxijsub;
        DP = DP - dp0ijsub;
        DSXY = DSXY - dsxyijsub;
    end
    
    
    % Interpolate L-markers(dTremain) from P-node(dsxxijremain)
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<2)
            j=2;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<2)
            i=2;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dsxxmremain= DSXX(i,j)  *wtmij  + DSXX(i+1,j)   *wtmi1j  ...
                                   + DSXX(i,j+1)*wtmij1 + DSXX(i+1,j+1) *wtmi1j1;
        dp0mremain = DP(i,j)  *wtmij  + DP(i+1,j)   *wtmi1j  ...
                                   + DP(i,j+1)*wtmij1 + DP(i+1,j+1) *wtmi1j1;
        % "NOTE THAT" this discard interpolation of new stress SXX. 
        sxxm(m) = sxxm(m) + dsxxmremain;
        p0m(m) = p0m(m) + dp0mremain;
        
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dsxymremain=DSXY(i,j)  *wtmij  + DSXY(i+1,j)  *wtmi1j  ...
                                    +DSXY(i,j+1)*wtmij1 + DSXY(i+1,j+1)*wtmi1j1;
        % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
        % Eq.10.19
        sxym(m) = sxym(m) + dsxymremain;
    end
    
    % Computing "Vx and Vy"subgrid diffusion for markers
    if (subgrdifcoev>0)
        % Vx-NODES
        WVXNODES = zeros(Ny1,Nx1);
        VXSUM = zeros(Ny1,Nx1);
        % Basic-NODES        
        WVYNODES = zeros(Ny,Nx);
        VYSUM = zeros(Ny,Nx);
        % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
        for m = 1:marknum
            % Interpolate Vx to Vx-NODES(Nx*Ny1)
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvx(1))/dx)+1;
            i=fix((ym(m)-yvx(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xvx(j);
            dis_y=ym(m)-yvx(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            vx0mnodal= vx0(i,j)*wtmij + vx0(i+1,j)*wtmi1j  ...
                                   + vx0(i,j+1)*wtmij1 + vx0(i+1,j+1)*wtmi1j1;
            % Interpolate Vy to Vy-NODES(Nx1*Ny)
            j=fix((xm(m)-xvy(1))/dx)+1;
            i=fix((ym(m)-yvy(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-xvy(j);
            dis_y=ym(m)-yvy(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            vy0mnodal= vy0(i,j)*wtmij + vy0(i+1,j)*wtmi1j  ...
                +vy0(i,j+1)*wtmij1 + vy0(i+1,j+1)*wtmi1j1;
            % NOTE THAT the answer is sxxm(m)-sxxm0nodal.
            % Eq.10.14
            dvx0m = vx0mnodal - vx0m(m);
            dvy0m = vy0mnodal - vy0m(m);
            % Page209
            tdiff =rhom(tm(m))/(etavpm(m)*(2/dx^2+2/dy^2));
            % Computing subgrid diffusion
            sdif=-subgrdifcoev*dtm/tdiff;
            % Page162 Eq.10.16
            dvx0msub=dvx0m*(1-exp(sdif));
            dvy0msub=dvy0m*(1-exp(sdif));

            % Eq.10.19
            % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
            vx0m(m) = vx0m(m) + dvx0msub;
            vy0m(m) = vy0m(m) + dvy0msub;
            
            % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
            % Eq.10.17
            j=fix((xm(m)-xvx(1))/dx)+1;
            i=fix((ym(m)-yvx(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xvx(j);
            dis_y=ym(m)-yvx(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                VXSUM(i,j) = VXSUM(i,j) + dvx0msub*rhom(m)*wtmij;
                WVXNODES(i,j) = WVXNODES(i,j) + rhom(m)*wtmij;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                VXSUM(i+1,j) = VXSUM(i+1,j) + dvx0msub*rhom(m)*wtmi1j;
                WVXNODES(i+1,j) = WVXNODES(i+1,j) + rhom(m)*wtmi1j;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                VXSUM(i,j+1) = VXSUM(i,j+1) + dvx0msub*rhom(m)*wtmij1;
                WVXNODES(i,j+1) = WVXNODES(i,j+1) + rhom(m)*wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                VXSUM(i+1,j+1) = VXSUM(i+1,j+1) + dvx0msub*rhom(m)*wtmi1j1;
                WVXNODES(i+1,j+1) = WVXNODES(i+1,j+1) + rhom(m)*wtmi1j1;
            end
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvy(1))/dx)+1;
            i=fix((ym(m)-yvy(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-xvy(j);
            dis_y=ym(m)-yvy(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                VYSUM(i,j) = VYSUM(i,j) + dvy0msub*rhom(m)*wtmij;
                WVYNODES(i,j) = WVYNODES(i,j) + rhom(m)*wtmij;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                VYSUM(i+1,j) = VYSUM(i+1,j) + dvy0msub*rhom(m)*wtmi1j;
                WVYNODES(i+1,j) = WVYNODES(i+1,j) + rhom(m)*wtmi1j;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                VYSUM(i,j+1) = VYSUM(i,j+1) + dvy0msub*rhom(m)*wtmij1;
                WVYNODES(i,j+1) = WVYNODES(i,j+1) + rhom(m)*wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                VYSUM(i+1,j+1) = VYSUM(i+1,j+1) + dvy0msub*rhom(m)*wtmi1j1;
                WVYNODES(i+1,j+1) = WVYNODES(i+1,j+1) + rhom(m)*wtmi1j1;
            end
        end
        
        dvxijsub = zeros(Ny1,Nx1);
        dvyijsub = zeros(Ny1,Nx1);
        % P-NODES
        for j=2:1:Nx
            for i=2:1:Ny
                if(WVXNODES(i,j)>0)
                    dvxijsub(i,j)=VXSUM(i,j)/WVXNODES(i,j);
                end
            end
        end
        % Basic nodes
        for j=1:1:Nx
            for i=1:1:Ny
                if(WVYNODES(i,j)>0)
                    dvyijsub(i,j) = VYSUM(i,j)/WVYNODES(i,j);
                end
            end
        end

        % Eq.10.18
        % Update dTij(dTij(remain) = dTij - dTij(sub)  )
        DVX = DVX - dvxijsub;
        DVY = DVY - dvyijsub;
    end
    % Interpolate L-markers from Vx-node
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1 )
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xvx(j);
        dis_y=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dvxmremain= DVX(i,j)  *wtmij  + DVX(i+1,j)   *wtmi1j  ...
                                  + DVX(i,j+1)*wtmij1 + DVX(i+1,j+1) *wtmi1j1;
        % "NOTE THAT" this discard interpolation of new stress SXX. 
        vx0m(m) = vx0m(m) + dvxmremain;
        
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xvy(j);
        dis_y=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dvymremain=DVY(i,j)  *wtmij  + DVY(i+1,j)  *wtmi1j  ...
                                  +DVY(i,j+1)*wtmij1 + DVY(i+1,j+1)*wtmi1j1;
        % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
        % Eq.10.19
        vy0m(m) = vy0m(m) + dvymremain;
    end
    
    % Computing "temperature"subgrid diffusion for markers
    if (subgrdifcoet>0)
        % Existence of subgrid diffusion.
        % Page162 How to correct the problem ?
        % operating  consistent subgrid diffusion .
        % Clear subgrid temperature changes(dTijsub) for nodes
        % From marker to P-NODES
        WPNODES = zeros(Ny1,Nx1);
        WDTM = zeros(Ny1,Nx1);
        % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
        for m = 1:marknum
            % Interpolate T to P-NODES(Nx*Ny)
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
            Tm0nodal= T0(i,j)*wtmij + T0(i+1,j)*wtmi1j  ...
                +T0(i,j+1)*wtmij1 + T0(i+1,j+1)*wtmi1j1;
            % Eq.10.14
            dTm = Tm0nodal - tkm(m);
            % Page163
            tdiff = rhocpm(tm(m))/(km(tm(m))*(2/dx^2+2/dy^2));
            % Computing subgrid diffusion
            % Why??
            sdif=-subgrdifcoet*dtm/tdiff;
            % That's discard below code.
%             if(sdif<-30)
%                 sdif=-30;
%             end
            % Page162 Eq.10.16
            dTmsub=dTm*(1-exp(sdif));
            % Eq.10.19
            % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
            tkm(m) = tkm(m) + dTmsub;
            % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
            % Eq.10.17
            if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
                WDTM(i,j) = WDTM(i,j) + dTmsub*rhocpm(tm(m))*wtmij;
                WPNODES(i,j) = WPNODES(i,j) + rhocpm(tm(m))*wtmij;
            end
            if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
                WDTM(i+1,j) = WDTM(i+1,j) + dTmsub*rhocpm(tm(m))*wtmi1j;
                WPNODES(i+1,j) = WPNODES(i+1,j) + rhocpm(tm(m))*wtmi1j;
            end
            if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
                WDTM(i,j+1) = WDTM(i,j+1) + dTmsub*rhocpm(tm(m))*wtmij1;
                WPNODES(i,j+1) = WPNODES(i,j+1) + rhocpm(tm(m))*wtmij1;
            end
            if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
                WDTM(i+1,j+1) = WDTM(i+1,j+1) + dTmsub*rhocpm(tm(m))*wtmi1j1;
                WPNODES(i+1,j+1) = WPNODES(i+1,j+1) + rhocpm(tm(m))*wtmi1j1;
            end
        end
        dTijsub = zeros(Ny1,Nx1);
        for j = 1:Nx1
            for i = 1:Ny1
                if(WPNODES(i,j)>0)
                    % Compting dTijsub
                    % Eq.10.17
                    dTijsub(i,j) = WDTM(i,j)/WPNODES(i,j);
                end
            end
        end
        % Eq.10.18
        % Update dTij(dTij(remain) = dTij - dTijsub)
        dTij = dTij - dTijsub;
    end
    % Interpolate L-markers(dTremain) from P-node(dTijremain)
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        dTmremain=dTij(i,j)  *wtmij  + dTij(i+1,j)  *wtmi1j  ...
                 +dTij(i,j+1)*wtmij1 + dTij(i+1,j+1)*wtmi1j1;
        % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
        % Eq.10.19            
        tkm(m) = tkm(m) + dTmremain;
        if(t==1)
            % Interpolate new temperature for the 1st timestep
            tkm(m) = T1(i,j)*wtmij + T1(i+1,j)*wtmi1j  ...
                    +T1(i,j+1)*wtmij1 + T1(i+1,j+1)*wtmi1j1;
        end
    end

    % Computing Vx/Vy at the P-nodes
    for j = 2:1:Nx
        for i = 2:1:Ny
            %  Computing internal Vx and Vy at the P nodes.
            % Vx at internal(P) nodes.
            pvx(i,j) = ( vx(i,j) + vx(i,j-1) )./2;
            % Vy at internal nodes.
            pvy(i,j) = ( vy(i,j) + vy(i-1,j) )./2;
        end
    end
    % Vx
    % Top
    pvx(1,2:Nx-1)       = pvx(2,2:Nx-1);
    % Bottom
    pvx(Ny1,2:Nx-1) = pvx(Ny,2:Nx-1);
    % Left
    pvx(:,1)                    = 2*vxleft -pvx(:,2);
    % Right
    pvx(:,Nx1)              = 2*vxright-pvx(:,Nx);
    % Vy
    % Left
    pvy(2:Ny-1,1)      =  pvy(2:Ny-1,2);
    % Right
    pvy(2:Ny-1,Nx1)=  pvy(2:Ny-1,Nx); % Free slip
    % Top
    pvy(1,:)                   =  2*vytop   - pvy(2,:);
    % Bottom
    pvy(Ny1,:)             =  2*vybottom- pvy(Ny,:);

    % Rotate stress by Analytical formulas.
    for j = 1:1:Nx
        for i = 1:1:Ny
            % Computing rotation value.
            wyx(i,j) = 0.5*((vy(i,j+1)-vy(i,j))/dx-(vx(i+1,j)-vx(i,j))/dy);
        end
    end

    % The classical Runge-Kutta scheme,Fourth-order in sapce and
    % First-order in time(Accuracy).
    % Define Vxa(Vya)1,Vxb(Vyb)2,Vxc(Vyc)3,Vxd(Vyd)4.
    vxm=zeros(4,1);
    vym=zeros(4,1);
    % Interpolate vx and vy components from E-nodes to L-markers.
    for m=1:1:marknum
        % Computing wm and rotate stress.
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Compute vxm and vym velocity
        wm = wyx(i,j)*wtmij+wyx(i+1,j)*wtmi1j...
                 + wyx(i,j+1)*wtmij1+wyx(i+1,j+1)*wtmi1j1;
        angleAB = wm*dtm;
        sxymnew = sxxm(m)*sin(2*angleAB)+sxym(m)*cos(2*angleAB);
        sxxmnew = sxxm(m)*cos(angleAB)^2 - sxxm(m)*sin(angleAB)^2-sxym(m)*sin(2*angleAB) ;
        sxym(m) = sxymnew;
        sxxm(m) = sxxmnew;
        % Reserve original coordinate.
        xa = xm(m);
        ya = ym(m);
        for rk = 1:1:4
            % Interpolate vx-p and vy-p from P-staggered nodes to L-markers.
            % P staggered nodes.(Nx1 * Ny1)
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vxm and vym velocity
            vxm(rk) = pvx(i,j)*wtmij    + pvx(i+1,j)*wtmi1j...
                     +pvx(i,j+1)*wtmij1 + pvx(i+1,j+1)*wtmi1j1;
            vym(rk) = pvy(i,j)*wtmij    + pvy(i+1,j)*wtmi1j...
                     +pvy(i,j+1)*wtmij1 + pvy(i+1,j+1)*wtmi1j1;
            % Interpolate vx from Vx-staggered nodes to L-markers.
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvx(1))/dx)+1;
            i=fix((ym(m)-yvx(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            % Vx staggered nodes.(Nx * Ny+1)
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xvx(j);
            dis_y=ym(m)-yvx(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vx velocity
            vxm(rk) = (1/3)*vxm(rk) + (2/3)*(vx(i,j)*wtmij+vx(i+1,j)*wtmi1j...
                                           + vx(i,j+1)*wtmij1+vx(i+1,j+1)*wtmi1j1);
            % Interpolate vy
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvy(1))/dx)+1;
            i=fix((ym(m)-yvy(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-xvy(j);
            dis_y=ym(m)-yvy(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vx velocity
            vym(rk) = (1/3)*vym(rk) + (2/3)*(vy(i,j)*wtmij+vy(i+1,j)*wtmi1j...
                     +vy(i,j+1)*wtmij1+vy(i+1,j+1)*wtmi1j1); 
                 
            if(rk == 1 || rk == 2)
                xm(m) = vxm(rk)*dtm/2 + xa;
                ym(m) = vym(rk)*dtm/2 + ya;
            elseif(rk == 3)
                xm(m) = vxm(rk)*dtm + xa;
                ym(m) = vym(rk)*dtm + ya;
            end
        end
        % Return original coordinate.
        xm(m) = xa;
        ym(m) = ya;
        % Move markers with effective velocity field.
        vxefft = (1/6)*(vxm(1)+2*vxm(2)+2*vxm(3)+vxm(4));
        vyefft = (1/6)*(vym(1)+2*vym(2)+2*vym(3)+vym(4));        
        xm(m)=xm(m)+dtm*vxefft;
        ym(m)=ym(m)+dtm*vyefft;
    end
    % Sum of time.
    timesum=timesum+dtm;
    % Figure at every 20 timesteps.
    if(t==1 || fix(t/20)*20==t)
        % ETA,Ha and T.
        figure(1);
        % Figure
        subplot(1,3,1);
        colormap('Jet');
        pcolor(x,y,log10(ETAVP));
        hold on;
        %P nodes:(Nx1 * Ny1).
        quiver(xp(1:2:Nx1),yp(1:2:Ny1),pvx(1:2:Ny1,1:2:Nx1),pvy(1:2:Ny1,1:2:Nx1),'w')
        xlabel('Horizontal(m)')
        ylabel('Vertical(m)')
        caxis([17 21]);
        set(gca,'xaxislocation','top');
        set (gca,'YDir','reverse')
        shading interp;
        axis ij image;
        colorbar
        title(['log10(ETA) after ',num2str(t),' deltat'])
        % Ha
        subplot(1,3,2);
        colormap('Jet');
        pcolor(xp,yp,Hrij);
        xlabel('Horizontal(m)')
        ylabel('Vertical(m)')
        set(gca,'xaxislocation','top');
        set (gca,'YDir','reverse')
        shading interp;
        colorbar;
        axis ij image;
        title(['Ha after ',num2str(t),' deltat'])
        subplot(1,3,3);
        pcolor(xp,yp,T1);colorbar;
        xlabel('Horizontal(Km)');
        ylabel('Vertical(Km)');
        zlabel('Gravitational potential');
        title(['(Ibc)(MIC) Temperature after',num2str(t),' deltat'])
        set(gca,'xaxislocation','top');
        set (gca,'YDir','reverse')
        axis ij image;
        shading interp;
        % Change of yielderror with time.
        figure(2);
        plot(YIELDERRNODAL,'k','LineWidth',3);
        title(['YIELDERR time=',num2str(timesum/(365.25*24*3600)),' Yr'])
        % Viscosity distribution plotted on P-node.
        figure(3);
        colormap('Jet');
        pcolor(x/1000,y/1000,log10(ETAVP));% caxis([17 21])
        shading flat;
        axis ij image;
        colorbar
        title(['log10ETA, Pa*s timestep=',num2str(t),' time=',num2str(timesum/(365.25*24*3600)),' Yr'])
        
        % Save figure
        namefig=['VepmyNODE_' num2str(t)];
        print ('-djpeg', '-r150',namefig);
        
        pause(0.1);
    end
end
% Figure the change of yielderror. 
figure(4);
plot(YIELDERRNODAL(1:500),'k','LineWidth',3);
title(['YIELDERR time=',num2str(timesum/(365.25*24*3600)),' Yr'])
