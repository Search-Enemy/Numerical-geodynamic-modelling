% " Included marker interpolation and transporation".
% " Backtracing dev-stress(SXX,SXY),velocity(Vx,Vy),pressure(P) and state(OM)
%    with Fourth-order Runge-Kutta scheme".ABOUT LINES 2300-2870.
% " Adjust rate- and state- dependent friction(RSF) to previous program".
% " Tracking distance of fault slip and observing mutation of Vp(slip rate)"


clear all;clf;
% Set parameters
% Length of model
Lx = 150000; 
Ly = 150000;
x_mid = Lx/2;
y_mid = Ly/2;
% Sum of point number of model
Nx = 201; 
Ny = 51; 
Nx1 = Nx+1;
Ny1 = Ny+1;
% Interval of E-staggered-nodes
dx = Lx / (Nx-1);
dy = Ly / (Ny-1);
% Gravity acceleration
gx = 0;
gy = 0;
% Basic nodes.
x = 0:dx:Lx;
y = 0:dy:Ly;
% Vx staggered nodes.(Nx_node * Ny_node+1)
xvx = 0:dx:Lx+dx;
yvx = -dy/2 : dy : Ly+dy/2;
% Vy staggered nodes.(Nx_node+1 * Ny_node)
xvy = -dx/2 : dx : Lx+dx/2;
yvy = 0:dy:Ly+dy;
% P staggered nodes.(Nx_node+1 * Ny_node+1)
xp =   -dx/2 : dx : Lx+dx/2;
yp =   -dy/2 : dy : Ly+dy/2;



% Velocity and Pressure matrix
% Basic NODE
ETAVP = zeros(Ny,Nx);
ETA = zeros(Ny,Nx);
GGG = zeros(Ny,Nx);
EXY = zeros(Ny,Nx);
SXY = zeros(Ny,Nx);
SXY0 = zeros(Ny,Nx);
wyx = zeros(Ny,Nx);
COSHE = zeros(Ny,Nx);
FRICT0 = zeros(Ny,Nx);
YYN = zeros(Ny,Nx);% Determine whether node meets yielding condition.
% (RSF)
OM0=zeros(Ny,Nx); % Old state parameter
OM=zeros(Ny,Nx); % State parameter
ARSF=zeros(Ny,Nx); % a-parameter of RSF
BRSF=zeros(Ny,Nx); % b-parameter of RSF
LRSF=zeros(Ny,Nx); % L-parameter of RSF
VPRSF=zeros(Ny,Nx); % Slip velocity of RSF

% Vx NODE
vx0 = zeros(Ny1,Nx1);
vx = zeros(Ny1,Nx1);
RHOVX=zeros(Ny1,Nx1); 
KVX=zeros(Ny1,Nx1); 

% Vy NODE
vy0 = zeros(Ny1,Nx1);
vy = zeros(Ny1,Nx1);
RHOVY=zeros(Ny1,Nx1); 
KVY=zeros(Ny1,Nx1); 

% P NODE
RHOP = zeros(Ny1,Nx1);
RHOPCP = zeros(Ny1,Nx1); %Den*Cp(hct)
ALPHAP = zeros(Ny1,Nx1);
BEITAP = zeros(Ny1,Nx1);
HR = zeros(Ny1,Nx1);
HA = zeros(Ny1,Nx1);
HS = zeros(Ny1,Nx1);
ETAPVP = zeros(Ny1,Nx1);
GGGP = zeros(Ny1,Nx1);
EXX=zeros(Ny1,Nx1); % EPSILONxx, 1/s
SXX=zeros(Ny1,Nx1); % SIGMA'xx, 1/s
SXX0 = zeros(Ny1,Nx1);
T0 = zeros(Ny1,Nx1); %Told
T1 = zeros(Ny1,Nx1); %Tnew
pvx = zeros(Ny1,Nx1);% vx/vy at P-NODES
pvy = zeros(Ny1,Nx1);
P0 = zeros(Ny1,Nx1);
P = zeros(Ny1,Nx1);

% Amount of markers.
Nxm = 4*(Nx-1);
Nym = 4*(Ny-1);
marknum=Nxm*Nym;
% Step-length among L-marker points
dxm = Lx/Nxm;
dym = Ly/Nym;
% Marker points.
% Stokes-equ and continuity-equ
xm=zeros(1,marknum); % Horizontal coordinates, m
ym=zeros(1,marknum);
tm = zeros(1,marknum); % index of properties
tkm = zeros(1,marknum); % temperature
sxxm = zeros(1,marknum);
sxym = zeros(1,marknum);
etavpm = zeros(1,marknum);
p0m=zeros(1,marknum); % Marker pressure, Pa
vx0m=zeros(1,marknum); % Marker vx, m/s
vy0m=zeros(1,marknum); % Marker vy, m/s
om0m=zeros(1,marknum); % Marker vy, m/s
rhom    = [2700   2700   2700  ]; % Density, kg/m^3
etam    = [1e+23  1e+23  1e+23 ]; % Viscosity, Pa s
rhocpm  = [2.7e+6 2.7e+6 2.7e+6]; % Volumetric heat capacity, kg/m^3
alpham  = [0e-5   0e-5   0e-5  ]; % Thermal expansion, 1/K
beitam  = [2e-11  2e-11  2e-11 ]; % Compressibility, 1/Pa
km      = [3      3      3     ]; % Thermal conductivity, W/m/K
hrm     = [3e-8   3e-8   3e-8  ]; % Radiogenic heat production, W/m^3
gggm    = [3e+10  3e+10  3e+10 ]; % Shear Modulus, Pa
cohesm  = [0e+5   0e+5   0e+5  ]; % Cohesion, Pa
frict0m = [0.2    0.2    0.2   ]; % Reference friction coefficient of RSF
arsfm =   [0.011  0.011  0.011 ]; % a-parameter of RSF
brsfm =   [0.017  0.017  0.001 ]; % b-parameter of RSF
lrsfm =   [0.010  0.010  0.010 ]; % L-parameter of RSF (characteristic slip distance)
V0=4e-9; % Reference slip velocity of RSF, m/s
D=dy; % D-parameter of RSF

% Define marker coordinates, temperature and material type
m=1; % Marker counter
for jm=1:1:Nxm
    for im=1:1:Nym
        % Define marker coordinates
        % 注意这里没有加marker的随机移动(尽管是限制在半个标记步长)
        xm(m)=dxm/2+(jm-1)*dxm;%+(rand-0.5)*dxm;
        ym(m)=dym/2+(im-1)*dym;%+(rand-0.5)*dym;
        % Marker properties
        % 注意这里虽然定义并应用了om0m，但是在后面没有用，并插值到OM0(i,j)。
        om0m(m)=40; % State parameter
        % Block
        tm(m)=1; % Material type
        % Fault
        if(ym(m)>Ly/2-dy && ym(m)<Ly/2+dy)
            % 根据后面OM0的定义，初始断层仍然限制在中间有限宽度(Ny1/2 - 1 , Ny1/2 + 1).
            tm(m)=2; % Material type
            om0m(m)=-1; % State parameter
            % Buffer zones 
            % 与rate-dependent一样，初始断层左右有缓冲区
            if(xm(m)<32000 || xm(m)>118000)
                tm(m)=3; % Material type
            end
        end
        % Initial temperature
        tkm(m)=273;
        % Initial visco-plastic viscosity
        etavpm(m)=etam(tm(m));
        % Update marker counter
        m=m+1;
    end
end



% Define matrix for Stokes
unknowns = Nx1*Ny1*3;
b  =   zeros(unknowns, 1);
coe = sparse(unknowns,unknowns);
unknowns = Nx1*Ny1;
bt  =   zeros(unknowns, 1);
coet = sparse(unknowns,unknowns);
    
% Boundary condition : free slip = -1 ; no slip = 1
bcleft   = 1;
bcright  = 1;
bctop    = 1;
bcbottom = 1;
% Extension/shortening velocities
strainrate=1e-13; % Shortening strain rate
vxtop=2e-9;%strainrate*xsize/2;
vxbottom=-2e-9;%-strainrate*xsize/2;

% Pressure BC
PCONF=5e+6;

% Setting timestep.
% 第一次的dt是大的，然后自适应为小的(RSF)
dtelastic = 1e+8; % initial timestep
dt = dtelastic;
dtmin = 1e-6;
dtkoefv=1.1; % Koefficient to decrese dt for P,T,vx,vy,SIGMA limits 
dtkoef=2; % Koefficient to decrese dt in case of no convergence
dtkoefup=1.1; % 达到更改dt(dt/2)的循环迭代次数后，逐渐增加dt(1.1)但不会超过dtelastic
% 此处缩减10倍(200-->20)
dtstep=20; % Number of iterations before changing dt
dxymax   = 0.001;
DTmax=20; % max temperature change per iteration step, K
DPmax = 1e9; % max pressure change per iteration step, Pa
DSmax = 1e9; % max stress change per time step.
% 多了Ω状态参量（无维度）
DOMmax=0.2; % Max change in RSF state
subgrdifcoes =0; % Subgrid"Stress and Pressure(SXX,SXY,P)" diffusion parameter
subgrdifcoet=0; % Subgrid "temperature(T)" diffusion parameter
subgrdifcoev=0; % Subgrid "velocity(Vx,Vy)" diffusion parameter
timesum = 0;
minetavpm = 1e-3;
maxetavpm = 1e+26;
nloop=100000;
 visstep = 10;
yerrmax =  3e-1;% Tolerance level for yielding error, Pa
terrmax=1e-3; % Tolerance level for temperature error, K
perrmax=3e+4; % Tolerance level for pressure error, Pa，下面三行是对应的存储数组
YIELDERRNODAL=zeros(1,nloop);
TEMERRNODAL = zeros(1,nloop);
PREERRNODAL = zeros(1,nloop);
vpratio = 1/3;
% 400-->500
Nt = 5000;
dt00=dt;
c = 1e-9;  % empirical coefficent

t = 1;
for t = t:1:Nt     
    
    
    
    % Save old stresses
sxxm00=sxxm; 
sxym00=sxym;
% what items were added in this interpolation???
% Vx(vxnode),Vy(vynode),Beita(pnode)

    % BASCI NODE
    ETAVPSUM = zeros(Ny,Nx);
    ETASUM = zeros(Ny,Nx);
    GGGSUM = zeros(Ny,Nx);
    SXYSUM = zeros(Ny,Nx);
    COSHESUM = zeros(Ny,Nx);
    FRICT0UM = zeros(Ny,Nx);
    ARSFSUM=zeros(Ny,Nx);
    BRSFSUM=zeros(Ny,Nx);
    LRSFSUM=zeros(Ny,Nx);
    OM0SUM=zeros(Ny,Nx);
    WTBSUM = zeros(Ny,Nx);
    % Vx nodes    
    RHOXSUM=zeros(Ny1,Nx1);
    WTXSUM=zeros(Ny1,Nx1);
    KXSUM=zeros(Ny1,Nx1);
    VXSUM = zeros(Ny1,Nx1);
    % Vy nodes    
    RHOYSUM=zeros(Ny1,Nx1);
    WTYSUM=zeros(Ny1,Nx1);
    KYSUM=zeros(Ny1,Nx1);
    VYSUM = zeros(Ny1,Nx1);
    %Pnodes
    WTPSUM=zeros(Ny1,Nx1);
    GGGPSUM=zeros(Ny1,Nx1);
    SXXSUM=zeros(Ny1,Nx1);
    RHOSUM=zeros(Ny1,Nx1);
    RHOCPSUM=zeros(Ny1,Nx1);
    ALPHASUM=zeros(Ny1,Nx1);
    BEITAPSUM=zeros(Ny1,Nx1);
    HRSUM=zeros(Ny1,Nx1);
    TKSUM=zeros(Ny1,Nx1);
    P0SUM=zeros(Ny1,Nx1);

    % Interpolate viscosity from markers to BASIC NODES.
    % Searching the coordinate of upper-left node of every L-marker.
    for m = 1:1:marknum
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % 注意m与tm(m)
        % 仅有sxym(m),etavpm(m),omom(m)三个！
        % i,j Node
        ETAVPSUM(i,j)=ETAVPSUM(i,j)+etavpm(m)*wtmij;
        ETASUM(i,j)=ETASUM(i,j)+etam(tm(m))*wtmij;
        FRICT0UM(i,j)=FRICT0UM(i,j)+frict0m(tm(m))*wtmij;
        COSHESUM(i,j)=COSHESUM(i,j)+cohesm(tm(m))*wtmij;
        GGGSUM(i,j)=GGGSUM(i,j)+1/gggm(tm(m))*wtmij;
        SXYSUM(i,j)=SXYSUM(i,j)+sxym(m)*wtmij;
        ARSFSUM(i,j)=ARSFSUM(i,j) + arsfm(tm(m))*wtmij;
        BRSFSUM(i,j)=BRSFSUM(i,j) + brsfm(tm(m))*wtmij;
        LRSFSUM(i,j)=LRSFSUM(i,j)   + lrsfm(tm(m))*wtmij;
        OM0SUM(i,j)=OM0SUM(i,j) + om0m(m)*wtmij;
        WTBSUM(i,j)=WTBSUM(i,j)+wtmij;
        % i+1,j Node
        ETAVPSUM(i+1,j)=ETAVPSUM(i+1,j)+etavpm(m)*wtmi1j;
        ETASUM(i+1,j)=ETASUM(i+1,j)+etam(tm(m))*wtmi1j;
        FRICT0UM(i+1,j)=FRICT0UM(i+1,j)+frict0m(tm(m))*wtmi1j;
        COSHESUM(i+1,j)=COSHESUM(i+1,j)+cohesm(tm(m))*wtmi1j;
        GGGSUM(i+1,j)=GGGSUM(i+1,j)+1/gggm(tm(m))*wtmi1j;
        SXYSUM(i+1,j)=SXYSUM(i+1,j)+sxym(m)*wtmi1j;
        ARSFSUM(i+1,j)=ARSFSUM(i+1,j) + arsfm(tm(m))*wtmi1j;
        BRSFSUM(i+1,j)=BRSFSUM(i+1,j) + brsfm(tm(m))*wtmi1j;
        LRSFSUM(i+1,j)=LRSFSUM(i+1,j)   + lrsfm(tm(m))*wtmi1j;
        OM0SUM(i+1,j)=OM0SUM(i+1,j) + om0m(m)*wtmi1j;
        WTBSUM(i+1,j)=WTBSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        ETAVPSUM(i,j+1)=ETAVPSUM(i,j+1)+etavpm(m)*wtmij1;
        ETASUM(i,j+1)=ETASUM(i,j+1)+etam(tm(m))*wtmij1;
        FRICT0UM(i,j+1)=FRICT0UM(i,j+1)+frict0m(tm(m))*wtmij1;
        COSHESUM(i,j+1)=COSHESUM(i,j+1)+cohesm(tm(m))*wtmij1;
        GGGSUM(i,j+1)=GGGSUM(i,j+1)+1/gggm(tm(m))*wtmij1;
        SXYSUM(i,j+1)=SXYSUM(i,j+1)+sxym(m)*wtmij1;
        ARSFSUM(i,j+1)=ARSFSUM(i,j+1) + arsfm(tm(m))*wtmij1;
        BRSFSUM(i,j+1)=BRSFSUM(i,j+1) + brsfm(tm(m))*wtmij1;
        LRSFSUM(i,j+1)=LRSFSUM(i,j+1)   + lrsfm(tm(m))*wtmij1;
        OM0SUM(i,j+1)=OM0SUM(i,j+1) + om0m(m)*wtmij1;
        WTBSUM(i,j+1)=WTBSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        ETAVPSUM(i+1,j+1)=ETAVPSUM(i+1,j+1)+etavpm(m)*wtmi1j1;
        ETASUM(i+1,j+1)=ETASUM(i+1,j+1)+etam(tm(m))*wtmi1j1;
        FRICT0UM(i+1,j+1)=FRICT0UM(i+1,j+1)+frict0m(tm(m))*wtmi1j1;
        COSHESUM(i+1,j+1)=COSHESUM(i+1,j+1)+cohesm(tm(m))*wtmi1j1;
        GGGSUM(i+1,j+1)=GGGSUM(i+1,j+1)+1/gggm(tm(m))*wtmi1j1;
        SXYSUM(i+1,j+1)=SXYSUM(i+1,j+1)+sxym(m)*wtmi1j1;
        ARSFSUM(i+1,j+1)=ARSFSUM(i+1,j+1) + arsfm(tm(m))*wtmi1j1;
        BRSFSUM(i+1,j+1)=BRSFSUM(i+1,j+1) + brsfm(tm(m))*wtmi1j1;
        LRSFSUM(i+1,j+1)=LRSFSUM(i+1,j+1)   + lrsfm(tm(m))*wtmi1j1;
        OM0SUM(i+1,j+1)=OM0SUM(i+1,j+1) + om0m(m)*wtmi1j1;
        WTBSUM(i+1,j+1)=WTBSUM(i+1,j+1)+wtmi1j1;
        % Interpolation to vx-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xvx(j);
        dis_y=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        RHOXSUM(i,j)=RHOXSUM(i,j)+rhom(tm(m))*wtmij;
        KXSUM(i,j)=KXSUM(i,j)+km(tm(m))*wtmij;
        VXSUM(i,j)=VXSUM(i,j)+vx0m(m)*rhom(tm(m))*wtmij;
        WTXSUM(i,j)=WTXSUM(i,j)+wtmij;
        % i+1,j Node
        RHOXSUM(i+1,j)=RHOXSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        KXSUM(i+1,j)=KXSUM(i+1,j)+km(tm(m))*wtmi1j;
        VXSUM(i+1,j)=VXSUM(i+1,j)+vx0m(m)*rhom(tm(m))*wtmi1j;
        WTXSUM(i+1,j)=WTXSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        RHOXSUM(i,j+1)=RHOXSUM(i,j+1)+rhom(tm(m))*wtmij1;
        KXSUM(i,j+1)=KXSUM(i,j+1)+km(tm(m))*wtmij1;
        VXSUM(i,j+1)=VXSUM(i,j+1)+vx0m(m)*rhom(tm(m))*wtmij1;
        WTXSUM(i,j+1)=WTXSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        RHOXSUM(i+1,j+1)=RHOXSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        KXSUM(i+1,j+1)=KXSUM(i+1,j+1)+km(tm(m))*wtmi1j1;
        VXSUM(i+1,j+1)=VXSUM(i+1,j+1)+vx0m(m)*rhom(tm(m))*wtmi1j1;
        WTXSUM(i+1,j+1)=WTXSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation to vy-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xvy(j);
        dis_y=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        RHOYSUM(i,j)=RHOYSUM(i,j)+rhom(tm(m))*wtmij;
        KYSUM(i,j)=KYSUM(i,j)+km(tm(m))*wtmij;
        VYSUM(i,j)=VYSUM(i,j)+vy0m(m)*rhom(tm(m))*wtmij;
        WTYSUM(i,j)=WTYSUM(i,j)+wtmij;
        % i+1,j Node
        RHOYSUM(i+1,j)=RHOYSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        KYSUM(i+1,j)=KYSUM(i+1,j)+km(tm(m))*wtmi1j;
        VYSUM(i+1,j)=VYSUM(i+1,j)+vy0m(m)*rhom(tm(m))*wtmi1j;
        WTYSUM(i+1,j)=WTYSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        RHOYSUM(i,j+1)=RHOYSUM(i,j+1)+rhom(tm(m))*wtmij1;
        KYSUM(i,j+1)=KYSUM(i,j+1)+km(tm(m))*wtmij1;
        VYSUM(i,j+1)=VYSUM(i,j+1)+vy0m(m)*rhom(tm(m))*wtmij1;
        WTYSUM(i,j+1)=WTYSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        RHOYSUM(i+1,j+1)=RHOYSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        KYSUM(i+1,j+1)=KYSUM(i+1,j+1)+km(tm(m))*wtmi1j1;
        VYSUM(i+1,j+1)=VYSUM(i+1,j+1)+vy0m(m)*rhom(tm(m))*wtmi1j1;
        WTYSUM(i+1,j+1)=WTYSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation to P-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Update properties
        % i,j Node
        GGGPSUM(i,j)=GGGPSUM(i,j)+1/gggm(tm(m))*wtmij;
        SXXSUM(i,j)=SXXSUM(i,j)+sxxm(m)*wtmij;
        RHOSUM(i,j)=RHOSUM(i,j)+rhom(tm(m))*wtmij;
        RHOCPSUM(i,j)=RHOCPSUM(i,j)+rhocpm(tm(m))*wtmij;
        ALPHASUM(i,j)=ALPHASUM(i,j)+alpham(tm(m))*wtmij;
        BEITAPSUM(i,j)=BEITAPSUM(i,j)+beitam(tm(m))*wtmij;
        HRSUM(i,j)=HRSUM(i,j)+hrm(tm(m))*wtmij;
        TKSUM(i,j)=TKSUM(i,j)+tkm(m)*rhocpm(tm(m))*wtmij;
        P0SUM(i,j)=P0SUM(i,j)+p0m(m)*wtmij;
        WTPSUM(i,j)=WTPSUM(i,j)+wtmij;
        % i+1,j Node
        GGGPSUM(i+1,j)=GGGPSUM(i+1,j)+1/gggm(tm(m))*wtmi1j;
        SXXSUM(i+1,j)=SXXSUM(i+1,j)+sxxm(m)*wtmi1j;
        RHOSUM(i+1,j)=RHOSUM(i+1,j)+rhom(tm(m))*wtmi1j;
        RHOCPSUM(i+1,j)=RHOCPSUM(i+1,j)+rhocpm(tm(m))*wtmi1j;
        ALPHASUM(i+1,j)=ALPHASUM(i+1,j)+alpham(tm(m))*wtmi1j;
        BEITAPSUM(i+1,j)=BEITAPSUM(i+1,j)+beitam(tm(m))*wtmi1j;
        HRSUM(i+1,j)=HRSUM(i+1,j)+hrm(tm(m))*wtmi1j;
        TKSUM(i+1,j)=TKSUM(i+1,j)+tkm(m)*rhocpm(tm(m))*wtmi1j;
        P0SUM(i+1,j)=P0SUM(i+1,j)+p0m(m)*wtmi1j;
        WTPSUM(i+1,j)=WTPSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        GGGPSUM(i,j+1)=GGGPSUM(i,j+1)+1/gggm(tm(m))*wtmij1;
        SXXSUM(i,j+1)=SXXSUM(i,j+1)+sxxm(m)*wtmij1;
        RHOSUM(i,j+1)=RHOSUM(i,j+1)+rhom(tm(m))*wtmij1;
        RHOCPSUM(i,j+1)=RHOCPSUM(i,j+1)+rhocpm(tm(m))*wtmij1;
        ALPHASUM(i,j+1)=ALPHASUM(i,j+1)+alpham(tm(m))*wtmij1;
        BEITAPSUM(i,j+1)=BEITAPSUM(i,j+1)+beitam(tm(m))*wtmij1;
        HRSUM(i,j+1)=HRSUM(i,j+1)+hrm(tm(m))*wtmij1;
        TKSUM(i,j+1)=TKSUM(i,j+1)+tkm(m)*rhocpm(tm(m))*wtmij1;
        P0SUM(i,j+1)=P0SUM(i,j+1)+p0m(m)*wtmij1;
        WTPSUM(i,j+1)=WTPSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        GGGPSUM(i+1,j+1)=GGGPSUM(i+1,j+1)+1/gggm(tm(m))*wtmi1j1;
        SXXSUM(i+1,j+1)=SXXSUM(i+1,j+1)+sxxm(m)*wtmi1j1;
        RHOSUM(i+1,j+1)=RHOSUM(i+1,j+1)+rhom(tm(m))*wtmi1j1;
        RHOCPSUM(i+1,j+1)=RHOCPSUM(i+1,j+1)+rhocpm(tm(m))*wtmi1j1;
        ALPHASUM(i+1,j+1)=ALPHASUM(i+1,j+1)+alpham(tm(m))*wtmi1j1;
        BEITAPSUM(i+1,j+1)=BEITAPSUM(i+1,j+1)+beitam(tm(m))*wtmi1j1;
        HRSUM(i+1,j+1)=HRSUM(i+1,j+1)+hrm(tm(m))*wtmi1j1;
        TKSUM(i+1,j+1)=TKSUM(i+1,j+1)+tkm(m)*rhocpm(tm(m))*wtmi1j1;
        P0SUM(i+1,j+1)=P0SUM(i+1,j+1)+p0m(m)*wtmi1j1;
        WTPSUM(i+1,j+1)=WTPSUM(i+1,j+1)+wtmi1j1;
    end
%     YYN=zeros(Ny,Nx);
    % Computing the value of density and viscosity of BASIC-NODE.
    for j=1:1:Nx
        for i=1:1:Ny
            if(WTBSUM(i,j)>0)
                % Not need RHO on the basic nodes.Just Y nodes.
                ETA(i,j)=ETASUM(i,j)/WTBSUM(i,j);
%                 ETAVP(i,j)=ETAVPSUM(i,j)/WTSUM(i,j);
                % 只有经过修正后的ETAVP才会小于ETA
                % 又因为修正代表该欧拉点满足应力屈服条件
                % 所以同时满足这两个条件的欧拉点需要标记为1（屈服）
%                 if(ETAVP(i,j)<ETA(i,j))
%                     YYN(i,j)=1;
%                 end
                GGG(i,j)=1/(GGGSUM(i,j)/WTBSUM(i,j));
%                 SXY0(i,j)=SXYSUM(i,j)/WTSUM(i,j);
                COSHE(i,j)=COSHESUM(i,j)/WTBSUM(i,j);
                FRICT0(i,j)=FRICT0UM(i,j)/WTBSUM(i,j);
                ARSF(i,j) = ARSFSUM(i,j)/WTBSUM(i,j);
                BRSF(i,j) = BRSFSUM(i,j)/WTBSUM(i,j);
                LRSF(i,j) = LRSFSUM(i,j)/WTBSUM(i,j);
               
%                 OM0(i,j) = OM0SUM(i,j)/WTBSUM(i,j);
            end
        end
    end
    % Computing Density and K value at the VY and VX-nodes.
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTXSUM(i,j)>0)
                % rou_h, k_h, vx0
                RHOVX(i,j)=RHOXSUM(i,j)/WTXSUM(i,j);
                KVX(i,j)=KXSUM(i,j)/WTXSUM(i,j);
%                 vx0(i,j)=VXSUM(i,j)/RHOXSUM(i,j);
            end
        end
    end
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTYSUM(i,j)>0)
                % rou_v, k_v,% vy0
                RHOVY(i,j)=RHOYSUM(i,j)/WTYSUM(i,j);
                KVY(i,j)=KYSUM(i,j)/WTYSUM(i,j);
%                 vy0(i,j)=VYSUM(i,j)/RHOYSUM(i,j);
            end
        end
    end
    % Computing properities at P-node
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTPSUM(i,j)>0)
                % 这一行不必要，答案没有写，后面会计算ETAVPs的平均值来作为ETAVPn
                % ETAPVP(i,j) = ETAPVPSUM(i,j)/WTPSUM(i,j);%etaVP = eta in viscosity-elastic materials.
                GGGP(i,j)=1/(GGGPSUM(i,j)/WTPSUM(i,j));
%                 SXX0(i,j)=SXXSUM(i,j)/WTPSUM(i,j);
                RHOP(i,j)=RHOSUM(i,j)/WTPSUM(i,j);
                RHOPCP(i,j)=RHOCPSUM(i,j)/WTPSUM(i,j);
                ALPHAP(i,j)=ALPHASUM(i,j)/WTPSUM(i,j);
                BEITAP(i,j)=BEITAPSUM(i,j)/WTPSUM(i,j);
                HR(i,j)=HRSUM(i,j)/WTPSUM(i,j);
                T0(i,j)=TKSUM(i,j)/RHOCPSUM(i,j);
%                 P0(i,j)=P0SUM(i,j)/WTPSUM(i,j);
            end
        end
    end
    % Applying thermal boundary conditions for interpolated temperature
    % Upper boundary
    T0(1,2:Nx)=T0(2,2:Nx); % Insulating boundary
    % Lower boundary
    T0(Ny1,2:Nx)=T0(Ny,2:Nx); % Insulating boundary
    % Left boundary
    T0(:,1)=T0(:,2); % Insulating boundary
    % Right boundary
    T0(:,Nx1)=T0(:,Nx); % Insulating boundary
    % Applying vx-velocity boundary conditions for interpolated velocity
    % Upper boundary
    vx0(1,2:Nx-1)=2*vxtop-bctop*vx0(2,2:Nx-1); % prescribed velocity
    % Lower boundary
    vx0(Ny1,2:Nx-1)=2*vxbottom-bcbottom*vx0(Ny,2:Nx-1); % prescribed velocity
    % Left boundary
    vx0(:,1)=vx0(:,2); % dVx/dx=0
    % Right boundary
    vx0(:,Nx)=vx0(:,Nx-1); % dVx/dx=0
    % Applying vy-velocity boundary conditions for interpolated velocity
    % Left boundary
    vy0(2:Ny-1,1)=-bcleft*vy0(2:Ny-1,2); % no slip
    % Right boundary
    vy0(2:Ny-1,Nx1)=-bcright*vy0(2:Ny-1,Nx); % no slip
    % Upper boundary
    vy0(1,:)=0; % no slip
    % Lower boundary
    vy0(Ny,:)=0; % no slip
    
    % Setting P0,OM0 and ETAVP
    if(t==1)
        P0 = PCONF*ones(Ny,Nx);%为什么不是NY1*NX1
        OM0=40*ones(Ny,Nx);
        OM0(Ny1/2,:)=-1;
        ETAVP=ETA;
    end
    % 假设第一次循环时，必定不会满足容许误差限，所以dt/2
    % 然后在之后的每一个timestep 都要逐渐增加dt,但不会超过5e7.
    % 下面这行什么意思？？
    if(dt>=dt00)
        dt=min(dt*dtkoefup,dtelastic);
    end
    dt00=dt;
    % Set initial viscoplastic viscosity
    
    % 传递（old）YNN（屈服标记）与ETAVP（miusvp）
    YYN00 = YYN;
    ETAVP00 = ETAVP;% ETAVP at "every timestep" instead of "every loop(200)"
    OM = OM0;
    % 这里重新添加了T。
    T1 = T0;
    % 定义达到改变dt的临界迭代次数(200)变量
    icount = 0;
    % Mechanical Solution
for iloop=1:1:nloop
        
    % etaweak == etamin;gggweak == gggmin
    NSetavpmin=max(minetavpm, dt*min(min(GGG))*c);%???      max???
    % Limit viscosity in the basic nodes
    for i=1:1:Ny
        for j=1:1:Nx
            if(ETAVP(i,j)>ETA(i,j))
                ETAVP(i,j)=ETA(i,j);
            end
            if(ETAVP(i,j)<NSetavpmin)
                ETAVP(i,j)=NSetavpmin;
            end
        end
    end
    Kcont  = NSetavpmin/dx;   
    % ETAPVP was only computed at this.
    for i=2:1:Ny
        for j=2:1:Nx
            ETAPVP(i,j)=1/((1/ETAVP(i-1,j-1)+1/ETAVP(i,j-1)+1/ETAVP(i-1,j)+1/ETAVP(i,j))/4);
        end
    end
    
    % Composing global matrixes L(), R() for Navier-Stokes and continuity equations
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global indexes in algebraic space
            kvx=((j-1)*Ny1+i-1)*3+1; % Vx
            kvy=kvx+1; % Vy
            kpm=kvx+2; % P
            
            % Vx equation External points
            if(i==1 || i==Ny1 || j==1 || j==Nx || j==Nx1)
                % Boundary Condition
                % Ghost unknowns 1*Vx=0
                if(j==Nx1)
                    coe(kvx,kvx)=1; % Left part
                    b(kvx)=0; % Right part
                end
                % Left Boundary
                if(j==1)
                    coe(kvx,kvx)=1; % Left part
                    coe(kvx,kvx+Ny1*3)=-1; % Left part
                    b(kvx)=0; % Right part
                end
                % Right Boundary
                if(j==Nx)
                    coe(kvx,kvx)=1; % Left part
                    coe(kvx,kvx-Ny1*3)=-1; % Left part
                    b(kvx)=0; % Right part
                end
                % Top boundary
                if(i==1 && j>1 && j<Nx)
                    coe(kvx,kvx)=1; % Left part
                    coe(kvx,kvx+3)=bctop; % Left part
                    b(kvx)=2*vxtop; % Right part
                end
                % Top boundary
                if(i==Ny1 && j>1 && j<Nx)
                    coe(kvx,kvx)=1; % Left part
                    coe(kvx,kvx-3)=bcbottom; % Left part
                    b(kvx)=2*vxbottom; % Right part
                end
            else
                % Internal points: x-Navier-Stokes eq.
                %            Vx2
                %             |
                %        Vy1  |  Vy3
                %             |
                %     Vx1-P1-Vx3-P2-Vx5
                %             |
                %        Vy2  |  Vy4
                %             |
                %            Vx4
                %
                % Computational viscosity
                ETA1=ETAVP(i-1,j)*GGG(i-1,j)*dt/(GGG(i-1,j)*dt+ETAVP(i-1,j));
                ETA2=ETAVP(i,j)*GGG(i,j)*dt/(GGG(i,j)*dt+ETAVP(i,j));
                ETAP1=ETAPVP(i,j)*GGGP(i,j)*dt/(GGGP(i,j)*dt+ETAPVP(i,j));
                ETAP2=ETAPVP(i,j+1)*GGGP(i,j+1)*dt/(GGGP(i,j+1)*dt+ETAPVP(i,j+1));
                % Old stresses
                SXY1=SXY0(i-1,j)*ETAVP(i-1,j)/(GGG(i-1,j)*dt+ETAVP(i-1,j));
                SXY2=SXY0(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
                SXX1=SXX0(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));
                SXX2=SXX0(i,j+1)*ETAPVP(i,j+1)/(GGGP(i,j+1)*dt+ETAPVP(i,j+1));
                % Density gradients
                dRHOdx=(RHOVX(i,j+1)-RHOVX(i,j-1))/2/dx;
                dRHOdy=(RHOVX(i+1,j)-RHOVX(i-1,j))/2/dy;
                % Left part
                coe(kvx,kvx-Ny1*3)=ETAP1/dx^2; % Vx1
                coe(kvx,kvx-3)=ETA1/dy^2; % Vx2
                coe(kvx,kvx)=-(ETAP1+ETAP2)/dx^2-...
                    (ETA1+ETA2)/dy^2-...
                    dRHOdx*gx*dt-RHOVX(i,j)/dt; % Vx3
                coe(kvx,kvx+3)=ETA2/dy^2; % Vx4
                coe(kvx,kvx+Ny1*3)=ETAP2/dx^2; % Vx5
                coe(kvx,kvy)=ETAP1/dx/dy-ETA2/dx/dy-dRHOdy*gx*dt/4;  % Vy2
                coe(kvx,kvy+Ny1*3)=-ETAP2/dx/dy+ETA2/dx/dy-dRHOdy*gx*dt/4;  % Vy4
                coe(kvx,kvy-3)=-ETAP1/dx/dy+ETA1/dx/dy-dRHOdy*gx*dt/4;  % Vy1
                coe(kvx,kvy+Ny1*3-3)=ETAP2/dx/dy-ETA1/dx/dy-dRHOdy*gx*dt/4;  % Vy3
                coe(kvx,kpm)=Kcont/dx; % P1
                coe(kvx,kpm+Ny1*3)=-Kcont/dx; % P2
                % Right part
                b(kvx)=-RHOVX(i,j)*(gx+vx0(i,j)/dt)-(SXY2-SXY1)/dy-(SXX2-SXX1)/dx;
            end
            
            % Vy equation External points
            if(j==1 || j==Nx1 || i==1 || i==Ny || i==Ny1)
                % Boundary Condition
                % Ghost unknowns 1*Vx=0
                if(i==Ny1)
                    coe(kvy,kvy)=1; % Left part
                    b(kvy)=0; % Right part
                end
                % Top boundary
                if(i==1)
                    coe(kvy,kvy)=1; % Left part
                    b(kvy)=0; % Right part
                end
                % Bottom boundary
                if(i==Ny)
                    coe(kvy,kvy)=1; % Left part
                    b(kvy)=0; % Right part
                end
                % Left boundary
                if(j==1 && i>1 && i<Ny)
                    coe(kvy,kvy)=1; % Left part
                    coe(kvy,kvy+3*Ny1)=bcleft; % Left part
                    b(kvy)=0; % Right part
                end
                % Right boundary
                if(j==Nx1 && i>1 && i<Ny)
                    coe(kvy,kvy)=1; % Left part
                    coe(kvy,kvy-3*Ny1)=bcright; % Left part
                    b(kvy)=0; % Right part
                end
            else
                % Internal points: y-Navier-Stokes eq.
                %            Vy2
                %             |
                %         Vx1 P1 Vx3
                %             |
                %     Vy1----Vy3----Vy5
                %             |
                %         Vx2 P2 Vx4
                %             |
                %            Vy4
                %
                % Computational viscosity
                ETA1=ETAVP(i,j-1)*GGG(i,j-1)*dt/(GGG(i,j-1)*dt+ETAVP(i,j-1));
                ETA2=ETAVP(i,j)*GGG(i,j)*dt/(GGG(i,j)*dt+ETAVP(i,j));
                ETAP1=ETAPVP(i,j)*GGGP(i,j)*dt/(GGGP(i,j)*dt+ETAPVP(i,j));
                ETAP2=ETAPVP(i+1,j)*GGGP(i+1,j)*dt/(GGGP(i+1,j)*dt+ETAPVP(i+1,j));
                % Old stresses
                SXY1=SXY0(i,j-1)*ETAVP(i,j-1)/(GGG(i,j-1)*dt+ETAVP(i,j-1));
                SXY2=SXY0(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
                SYY1=-SXX0(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));
                SYY2=-SXX0(i+1,j)*ETAPVP(i+1,j)/(GGGP(i+1,j)*dt+ETAPVP(i+1,j));
                % Density gradients
                dRHOdx=(RHOVY(i,j+1)-RHOVY(i,j-1))/2/dx;
                dRHOdy=(RHOVY(i+1,j)-RHOVY(i-1,j))/2/dy;
                % Left part
                coe(kvy,kvy-Ny1*3)=ETA1/dx^2; % Vy1
                coe(kvy,kvy-3)=ETAP1/dy^2; % Vy2
                coe(kvy,kvy)=-(ETAP1+ETAP2)/dy^2-...
                    (ETA1+ETA2)/dx^2-...
                    dRHOdy*gy*dt-RHOVY(i,j)/dt; % Vy3
                coe(kvy,kvy+3)=ETAP2/dy^2; % Vy4
                coe(kvy,kvy+Ny1*3)=ETA2/dx^2; % Vy5
                coe(kvy,kvx)=ETAP1/dx/dy-ETA2/dx/dy-dRHOdx*gy*dt/4; %Vx3
                coe(kvy,kvx+3)=-ETAP2/dx/dy+ETA2/dx/dy-dRHOdx*gy*dt/4; %Vx4
                coe(kvy,kvx-Ny1*3)=-ETAP1/dx/dy+ETA1/dx/dy-dRHOdx*gy*dt/4; %Vx1
                coe(kvy,kvx+3-Ny1*3)=ETAP2/dx/dy-ETA1/dx/dy-dRHOdx*gy*dt/4; %Vx2
                coe(kvy,kpm)=Kcont/dy; % P1
                coe(kvy,kpm+3)=-Kcont/dy; % P2
                
                % Right part
                b(kvy)=-RHOVY(i,j)*(gy+vy0(i,j)/dt)-(SXY2-SXY1)/dx-(SYY2-SYY1)/dy;
            end
            
            % P equation External points
            if(i==1 || j==1 || i==Ny1 || j==Nx1)
                % Boundary Condition
                % 1*P=0
                coe(kpm,kpm)=1; % Left part
                b(kpm)=0; % Right part
            else
                % Internal points: compressible continuity eq.
                % dVx/dx+dVy/dy+BETTA*DP/Dt=ALPHA*DT/Dt
                %            Vy1
                %             |
                %        Vx1--P--Vx2
                %             |
                %            Vy2
                %
                % Left part
                coe(kpm,kvx-Ny1*3)=-1/dx; % Vx1
                coe(kpm,kvx)=1/dx; % Vx2
                coe(kpm,kvy-3)=-1/dy; % Vy1
                coe(kpm,kvy)=1/dy; % Vy2
                % Incompressible pressure buildup at the first timestep
                %         if(timestep>1)
                coe(kpm,kpm)=Kcont*BEITAP(i,j)/dt; % P
                %         end
                % Right part
                % Incompressible pressure buildup at the first timestep
                %         if(timestep>1)
                b(kpm)=BEITAP(i,j)*P0(i,j)/dt+ALPHAP(i,j)*(T1(i,j)-T0(i,j))/dt;
                %         else
                %             R(kpm)=0;
                %         end
                
            end
            
        end
    end
    
    
    % Composing global matrixes L(), R()
    for j=1:-1:Nx1
        for i=1:1:Ny1
            % Computing global indexes for vx,vy,p
            kx=((j-1)*Ny1+i-1)*3+1; % Vx
            ky=kx+1; % Vy
            kp=kx+2; % P
            
            % Vx equation External points
            if(i==1 || i==Ny1 || j==1 || j==Nx || j==Nx1)
                % Boundary Condition
                % Ghost unknowns 1*Vx=0
                if(j==Nx1)
                    coe(kx,kx)=1; % Left part
                    b(kx)=0; % Right part
                end
                % Left Boundary
                if(j==1)
                    coe(kx,kx)=1; % Left part
                    coe(kx,kx+Ny1*3)=-1; % Left part
                    b(kx)=0; % Right part
                end
                % Right Boundary
                if(j==Nx)
                    coe(kx,kx)=1; % Left part
                    coe(kx,kx-Ny1*3)=-1; % Left part
                    b(kx)=0; % Right part
                end
                % Top boundary
                if(i==1 && j>1 && j<Nx)
                    coe(kx,kx)=1; % Left part
                    coe(kx,kx+3)=bctop; % Left part
                    b(kx)=2*vxtop; % Right part
                end
                % Top boundary
                if(i==Ny1 && j>1 && j<Nx)
                    coe(kx,kx)=1; % Left part
                    coe(kx,kx-3)=bcbottom; % Left part
                    b(kx)=2*vxbottom; % Right part
                end
            else
                % Total X-Stokes: dSIGMAxxt'/dx+dSIGMAxyt'/dy-dPt/dx=-RHOt*gx
                % SIGMAijt=2*ETA*EPSILONijs*K+SIGMAijt0*(1-K)
                %             vxs2
                %        vys1  |    vys3
                %              |
                %  vxs1--Pt1--vxs3--Pt2--vxs5
                %              |
                %        vys2  |    vys4
                %             vxs4
                % Viscosity
                ETAXY1=ETAVP(i-1,j);
                ETAXY2=ETAVP(i,j);
                ETAXX1=ETAPVP(i,j);
                ETAXX2=ETAPVP(i,j+1);
                % Shear modulus
                GXY1=GGG(i-1,j);
                GXY2=GGG(i,j);
                GXX1=GGGP(i,j);
                GXX2=GGGP(i,j+1);
                % Viscoelasticity factor
                KXY1=dt*GXY1/(dt*GXY1+ETAXY1);
                KXY2=dt*GXY2/(dt*GXY2+ETAXY2);
                KXX1=dt*GXX1/(dt*GXX1+ETAXX1);
                KXX2=dt*GXX2/(dt*GXX2+ETAXX2);
                % Numerical viscosity
                ETAXY1=ETAXY1*KXY1;
                ETAXY2=ETAXY2*KXY2;
                ETAXX1=ETAXX1*KXX1;
                ETAXX2=ETAXX2*KXX2;
                % Numerical stresses
                SXY1=SXY0(i-1,j)*(1-KXY1);
                SXY2=SXY0(i,j)*(1-KXY2);
                SXX1=SXX0(i,j)*(1-KXX1);
                SXX2=SXX0(i,j+1)*(1-KXX2);
                % Density derivatives
                dRHOdx=(RHOVX(i,j+1)-RHOVX(i,j-1))/2/dx;
                dRHOdy=(RHOVX(i+1,j)-RHOVX(i-1,j))/2/dy;
                % Left part
                coe(kx,kx)=-(ETAXX1+ETAXX2)/dx^2 ...
                    -(ETAXY1+ETAXY2)/dy^2-gx*dt*dRHOdx-RHOVX(i,j)/dt; %vxs3
                coe(kx,kx-Ny1*3)=ETAXX1/dx^2; %vxs1
                coe(kx,kx+Ny1*3)=ETAXX2/dx^2; %vxs5
                coe(kx,kx-3)=ETAXY1/dy^2; %vxs2
                coe(kx,kx+3)=ETAXY2/dy^2; %vxs4
                coe(kx,ky-3)=ETAXY1/dx/dy-ETAXX1/dx/dy-gx*dt*dRHOdy/4; %vys1
                coe(kx,ky)=-ETAXY2/dx/dy+ETAXX1/dx/dy-gx*dt*dRHOdy/4; %vys2
                coe(kx,ky-3+Ny1*3)=-ETAXY1/dx/dy+ETAXX2/dx/dy-gx*dt*dRHOdy/4; %vys3
                coe(kx,ky+Ny1*3)=ETAXY2/dx/dy-ETAXX2/dx/dy-gx*dt*dRHOdy/4; %vys4
                coe(kx,kp)=Kcont/dx; %Pt1'
                coe(kx,kp+Ny1*3)=-Kcont/dx; %Pt2'
                % Right part
                b(kx)=-RHOVX(i,j)*(vx0(i,j)/dt+gx)-(SXX2-SXX1)/dx-(SXY2-SXY1)/dy;
            end
            
            % Vy equation External points
            if(j==1 || j==Nx1 || i==1 || i==Ny || i==Ny1)
                % Boundary Condition
                % Ghost unknowns 1*Vx=0
                if(i==Ny1)
                    coe(ky,ky)=1; % Left part
                    b(ky)=0; % Right part
                end
                % Top boundary
                if(i==1)
                    coe(ky,ky)=1; % Left part
                    b(ky)=0; % Right part
                end
                % Bottom boundary
                if(i==Ny)
                    coe(ky,ky)=1; % Left part
                    b(ky)=0; % Right part
                end
                % Left boundary
                if(j==1 && i>1 && i<Ny)
                    coe(ky,ky)=1; % Left part
                    coe(ky,ky+3*Ny1)=bcleft; % Left part
                    b(ky)=0; % Right part
                end
                % Right boundary
                if(j==Nx1 && i>1 && i<Ny)
                    coe(ky,ky)=1; % Left part
                    coe(ky,ky-3*Ny1)=bcright; % Left part
                    b(ky)=0; % Right part
                end
            else
                % Total Y-Stokes: dSIGMAyxt'/dx+dSIGMAyyt'/dy-dPt/dy=-RHOt*gy
                % y-Stokes equation: dSIGMA'yx/dx+dSIGMA'yy/dy-dP/dy=-RHO*gy
                %
                %               vys2
                %                |
                %         vxs1  Pt1  vxs3
                %                |
                %   vys1---------vys3--------vys5
                %                |
                %         vxs2  Pt2  vxs4
                %                |
                %               vys4
                % Viscosity
                ETAXY1=ETAVP(i,j-1);
                ETAXY2=ETAVP(i,j);
                ETAYY1=ETAPVP(i,j);
                ETAYY2=ETAPVP(i+1,j);
                % Shear modulus
                GXY1=GGG(i,j-1);
                GXY2=GGG(i,j);
                GYY1=GGGP(i,j);
                GYY2=GGGP(i+1,j);
                % Viscoelasticity factor
                KXY1=dt*GXY1/(dt*GXY1+ETAXY1);
                KXY2=dt*GXY2/(dt*GXY2+ETAXY2);
                KYY1=dt*GYY1/(dt*GYY1+ETAYY1);
                KYY2=dt*GYY2/(dt*GYY2+ETAYY2);
                % Numerical viscosity
                ETAXY1=ETAXY1*KXY1;
                ETAXY2=ETAXY2*KXY2;
                ETAYY1=ETAYY1*KYY1;
                ETAYY2=ETAYY2*KYY2;
                % Numerical stresses
                SXY1=SXY0(i,j-1)*(1-KXY1);
                SXY2=SXY0(i,j)*(1-KXY2);
                SYY1=-SXX0(i,j)*(1-KYY1);
                SYY2=-SXX0(i+1,j)*(1-KYY2);
                % Density derivatives
                dRHOdx=(RHOVY(i,j+1)-RHOVY(i,j-1))/2/dx;
                dRHOdy=(RHOVY(i+1,j)-RHOVY(i-1,j))/2/dy;
                % Left part
                coe(ky,ky)=-(ETAYY1+ETAYY2)/dy^2-...
                    (ETAXY1+ETAXY2)/dx^2-gy*dt*dRHOdy-RHOVY(i,j)/dt; %vys3
                coe(ky,ky-Ny1*3)=ETAXY1/dx^2; %vys1
                coe(ky,ky+Ny1*3)=ETAXY2/dx^2; %vys5
                coe(ky,ky-3)=ETAYY1/dy^2; %vys2
                coe(ky,ky+3)=ETAYY2/dy^2; %vys4
                coe(ky,kx-Ny1*3)=ETAXY1/dx/dy-ETAYY1/dx/dy-gy*dt*dRHOdx/4; %vxs1
                coe(ky,kx+3-Ny1*3)=-ETAXY1/dx/dy+ETAYY2/dx/dy-gy*dt*dRHOdx/4; %vxs2
                coe(ky,kx)=-ETAXY2/dx/dy+ETAYY1/dx/dy-gy*dt*dRHOdx/4; %vxs3
                coe(ky,kx+3)=ETAXY2/dx/dy-ETAYY2/dx/dy-gy*dt*dRHOdx/4; %vxs4
                coe(ky,kp)=Kcont/dy; %Pt1'
                coe(ky,kp+3)=-Kcont/dy; %Pt2'
                % Right part
                b(ky)=-RHOVY(i,j)*(vy0(i,j)/dt+gy)-(SYY2-SYY1)/dy-(SXY2-SXY1)/dx;
            end
            
            
            % 5c) Composing equation for Pt
            if(i==1 || j==1 || i==Ny1 || j==Nx1)
                % BC equation: 1*Pt=0
                coe(kp,kp)=1;
                b(kp)=0;
            else
                % Solid Continuity: dVxs/dx+dVys/dy+(Pt-Pf)/ETAbulk=0
                %              vys1
                %               |
                %        vxs1--Pt,Pf--vxs2
                %               |
                %              vys2
                % Left part
                coe(kp,kx-Ny1*3)=-1/dx; %vxs1
                coe(kp,kx)=1/dx; %vxs2
                coe(kp,ky-3)=-1/dy; %vys1
                coe(kp,ky)=1/dy; %vys2
                coe(kp,kp)=BEITAP(i,j)*Kcont/dt; %Pt
                % Right part
                % The item(T1-T0) is commented out here.
                b(kp)=P0(i,j)*BEITAP(i,j)/dt;
            end
        end
    end
    % Computing the solution U:include vx,vy and p
    Us = coe \ b;
    % Decompose the solution of global matrix. 
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global indexes in algebraic space
            kvx=((j-1)*Ny1+i-1)*3+1; % Vx
            kvy=kvx+1; % Vy
            kpm=kvx+2; % P
            % Reload solution
            vx(i,j)=Us(kvx);
            vy(i,j)=Us(kvy);
            P(i,j)=Us(kpm)*Kcont;
        end
    end
    DVX = vx-vx0;
    DVY = vy-vy0;

    % Compute Stress, stress change and strain rate components
    % Compute EPSILONxy, SIGMAxy in basic nodes
    EXY=zeros(Ny,Nx); % Strain rate EPSILONxy, 1/s
    SXY=zeros(Ny,Nx); % Stress SIGMAxy, Pa
    DSXY=zeros(Ny,Nx); % Stress change SIGMAxy, Pa
    for j=1:1:Nx
        for i=1:1:Ny
            % EXY,SXY, DSXY
            EXY(i,j)=0.5*((vx(i+1,j)-vx(i,j))/dy+...
                (vy(i,j+1)-vy(i,j))/dx);
            SXY(i,j)=2*ETAVP(i,j)*EXY(i,j)*GGG(i,j)*dt/(GGG(i,j)*dt+ETAVP(i,j))+...
                SXY0(i,j)*ETAVP(i,j)/(GGG(i,j)*dt+ETAVP(i,j));
            DSXY(i,j)=SXY(i,j)-SXY0(i,j);
        end
    end
    % Compute EPSILONxx, SIGMA'xx in pressure nodes
    EXX=zeros(Ny1,Nx1); % Strain rate EPSILONxx, 1/s
    EII=zeros(Ny1,Nx1); % Second strain rate invariant, 1/s
    SXX=zeros(Ny1,Nx1); % Stress SIGMA'xx, Pa
    SII=zeros(Ny1,Nx1); % Second stress invariant, Pa
    DSXX=zeros(Ny1,Nx1); % Stress change SIGMA'xx, Pa
    DP=zeros(Ny1,Nx1); % Pressure change, Pa
    for j=2:1:Nx
        for i=2:1:Ny
            % EXX
            EXX(i,j)=0.5*((vx(i,j)-vx(i,j-1))/dx-(vy(i,j)-vy(i-1,j))/dy);
            % SXX
            SXX(i,j)=2*ETAPVP(i,j)*EXX(i,j)*GGGP(i,j)*dt/(GGGP(i,j)*dt+ETAPVP(i,j))+...
                SXX0(i,j)*ETAPVP(i,j)/(GGGP(i,j)*dt+ETAPVP(i,j));
            DSXX(i,j)=SXX(i,j)-SXX0(i,j);
            % EII
            EII(i,j)=(EXX(i,j)^2+((EXY(i,j)+EXY(i-1,j)+...
                EXY(i,j-1)+EXY(i-1,j-1))/4)^2)^0.5;
            % SII
            SII(i,j)=(SXX(i,j)^2+((SXY(i,j)+SXY(i-1,j)+...
                SXY(i,j-1)+SXY(i-1,j-1))/4)^2)^0.5;
            % DP
            DP(i,j)=P(i,j)-P0(i,j);
        end
    end
    % Compute shear heating HS in Temperature/Pressure nodes
    HS=zeros(Ny1,Nx1); % Adiabatic heating, W/m^3
    for j=2:1:Nx
        for i=2:1:Ny
            % Average SXY*EXY
            SXYEXY=(SXY(i,j)^2/ETAVP(i,j)+SXY(i-1,j)^2/ETAVP(i-1,j)+...
                SXY(i,j-1)^2/ETAVP(i,j-1)+SXY(i-1,j-1)^2/ETAVP(i-1,j-1))/4;
            % HS
            HS(i,j)=SXX(i,j)^2/ETAPVP(i,j)+SXYEXY;
        end
    end
    
    % Compute adiabatic heating HA in Temperature/Pressure nodes
    HA=zeros(Ny1,Nx1); % Shear heating, W/m^3
    for j=2:1:Nx
        for i=2:1:Ny
            % Average vy, vx
            VXP=(vx(i,j)+vx(i,j-1))/2;
            VYP=(vy(i,j)+vy(i-1,j))/2;
            % HA
            HA(i,j)=T0(i,j)*ALPHAP(i,j)*(P(i,j)-P0(i,j))/dt;
        end
    end
    
    % Composing global matrixes LT(), RT()
    % Going through all points of the 2D grid and
    % composing respective equations
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Define global index in algebraic space
            gk=(j-1)*Ny1+i;
            % External points
            if(i==1 || i==Ny1 || j==1 || j==Nx1)
                % Boundary Condition
                % Top BC: T=273
                if(i==1 && j>1 && j<Nx1)
                    coet(gk,gk)=1; % Left part
                    coet(gk,gk+1)=-1; % Left part
                    bt(gk)=0; % Right part
                end
                % Bottom BC: T=1500
                if(i==Ny1 && j>1 && j<Nx1)
                    coet(gk,gk)=1; % Left part
                    coet(gk,gk-1)=-1; % Left part
                    bt(gk)=0; % Right part
                end
                % Left BC: dT/dx=0
                if(j==1)
                    coet(gk,gk)=1; % Left part
                    coet(gk,gk+Ny1)=-1; % Left part
                    bt(gk)=0; % Right part
                end
                % Right BC: dT/dx=0
                if(j==Nx1)
                    coet(gk,gk)=1; % Left part
                    coet(gk,gk-Ny1)=-1; % Left part
                    bt(gk)=0; % Right part
                end
            else
                % Internal points: Temperature eq.
                % RHO*CP*dT/dt=-dqx/dx-dqy/dy+Hr+Hs+Ha
                %          Tdt2
                %           |
                %          Ky1
                %           |
                %Tdt1-Kx1-T03,Tdt3-Kx2-Tdt5
                %           |
                %          Ky2
                %           |
                %          Tdt4
                %
                % Left part
                Kx1=KVX(i,j-1);
                Kx2=KVX(i,j);
                Ky1=KVY(i-1,j);
                Ky2=KVY(i,j);
                coet(gk,gk-Ny1)=-Kx1/dx^2; % T1
                coet(gk,gk-1)=-Ky1/dy^2; % FI2
                coet(gk,gk)=RHOPCP(i,j)/dt+(Kx1+Kx2)/dx^2+(Ky1+Ky2)/dy^2; % FI3
                coet(gk,gk+1)=-Ky2/dy^2; % FI4
                coet(gk,gk+Ny1)=-Kx2/dx^2; % FI5
                % Right part
                bt(gk)=RHOPCP(i,j)/dt*T0(i,j)+HR(i,j)+HA(i,j)+HS(i,j);
            end
        end
    end
    
    % Solving matrixes
    ST=coet\bt; % Obtaining algebraic vector of solutions ST()
    
    % Reload solutions ST() to geometrical array Tdt()
    % Going through all grid points
    for j=1:1:Nx1
        for i=1:1:Ny1
            % Compute global index
            gk=(j-1)*Ny1+i;
            % Reload solution
            T1(i,j)=ST(gk);
        end
    end
    % Compute DT
    DT=T1-T0;



% Insulting boundary.

    P(:,1)  = P(:,2);
    P(:,Nx1)= P(:,Nx);
    P(1,:)  = P(2,:);
    P(Ny1,:)= P(Ny,:);
    P0(:,1)=P0(:,2);
    P0(:,Nx1)=P0(:,Nx);
    P0(1,:)=P0(2,:);
    P0(Ny1,:)=P0(Ny,:);
    SXX(:,1)=SXX(:,2);
    SXX(:,Nx1)=SXX(:,Nx);
    SXX(1,:)=SXX(2,:);
    SXX(Ny1,:)=SXX(Ny,:);
    SXX0(:,1)=SXX0(:,2);
    SXX0(:,Nx1)=SXX0(:,Nx);
    SXX0(1,:)=SXX0(2,:);
    SXX0(Ny1,:)=SXX0(Ny,:);
    
    
    ETA5=ETA; % 传递老mius 而不是miusvp ，在每一次timestep
    YYN5=zeros(Ny,Nx);% 设置一个中间变量来传递“屈服标记矩阵”
    DSY=zeros(Ny,Nx);
    OM5=OM;
    % "Update ETAVP(i,j)"
    DIJYIELD = 0;
    NIJPLAST = 0;
    dtrobert=dt;
    dtlapusta=dt;
    % Iterate over BASIC-NODE.
    for j = 1:Nx
        for i = 1:Ny
            SIIB = (SXY(i,j)^2 + (1/16)*(SXX(i,j)+SXX(i+1,j)+SXX(i,j+1)+SXX(i+1,j+1))^2)^0.5;
            % "NOTE THAT" 13.50 is different with below line.
            PB = (P(i,j)+P(i+1,j)+P(i,j+1)+P(i+1,j+1))/4;
            Vp = 2*V0*sinh( max(SIIB-COSHE(i,j),0)/ARSF(i,j)/PB )*exp( -( BRSF(i,j)*OM(i,j)+FRICT0(i,j) )/ARSF(i,j) );
            % 记录Vp
            VPRSF(i,j) = Vp;
            % log 是自然指数对数
            if( Vp*dt/LRSF(i,j)>1e-6 )
                OM5(i,j) = log( V0/Vp + ( exp(OM0(i,j))- V0/Vp )*exp(-Vp*dt/LRSF(i,j)) );
            else
                OM5(i,j) = log( exp(OM0(i,j)) * ( 1-Vp*dt/LRSF(i,j) ) + V0*dt/LRSF(i,j) );
            end
            syieldij=COSHE(i,j)+PB*ARSF(i,j)*asinh(Vp/2/V0*...
                          exp((BRSF(i,j)*OM5(i,j)+FRICT0(i,j))/ARSF(i,j)));

            DEFF(i,j)=D;
            srIIplastic =  Vp/(2*D);
            etapl=ETA(i,j)*syieldij/(2*ETA(i,j)*srIIplastic+syieldij);
            
            % Timestep criterion, Lapusta et al., 2000; Lapusta and Liu, 2009
            % Bulk modulus
            B=1/((BEITAP(i,j)+BEITAP(i+1,j)+BEITAP(i,j+1)+BEITAP(i+1,j+1))/4);
            % Kinematic viscosity coefficient
            vi=(3*B-2*GGG(i,j))/(6*B+2*GGG(i,j));
            % Middle coefficient
            K=2/pi*GGG(i,j)/(1-vi)/dx;
            % 
            kexi=1/4*(K*LRSF(i,j)/ARSF(i,j)/PB-(BRSF(i,j)-...
                ARSF(i,j))/ARSF(i,j))^2-K*LRSF(i,j)/ARSF(i,j)/PB;
            % xi == kexi
            if(kexi<0)
                dTETAmax=min(1-(BRSF(i,j)-ARSF(i,j))*PB/(K*LRSF(i,j)),0.2);
            else
                dTETAmax=min(ARSF(i,j)*PB/(K*LRSF(i,j)-(BRSF(i,j)-ARSF(i,j))*PB),0.2);
            end
            % "dtw"
            dtlapusta=min(dtlapusta,dTETAmax*LRSF(i,j)/Vp);
            % 这里直接用的Xstate_max == 0.2 ，而不是Xstate（dTETAmax）???
            % "dth"
            dtrobert=min(dtrobert,DOMmax*min(LRSF(i,j)/Vp,LRSF(i,j)/V0*exp(OM(i,j))));

            % 这里的意思是所有欧拉点都屈服了
            
            % Update error for old yielding nodes
            ynij=0;
            if(YYN(i,j)>0)
                ynij = 1;     %如果老欧拉点屈服，表明满足应力与粘度条件，则ynij=1
                NIJPLAST = NIJPLAST + 1;
                DIJYIELD = DIJYIELD + (SIIB-syieldij)^2;
                DSY(i,j) = SIIB-syieldij;
            end
            % Recompute nodal visocity
            ETA5(i,j)=etapl;
            % Mark yielding nodes
            YYN5(i,j)=1;
            % Apply viscosity cutoff values
            if(ETA5(i,j)<minetavpm)
                ETA5(i,j)=minetavpm;
            elseif(ETA5(i,j)>maxetavpm)
                ETA5(i,j)=maxetavpm;
            end
            % Update Error for new yielding nodes
            if(ynij==0)
                NIJPLAST = NIJPLAST + 1;
                DIJYIELD = DIJYIELD + (SIIB-syieldij)^2;
                DSY(i,j) = SIIB-syieldij;
            end
        end
    end
    
    % Compute yielding error for markers
    if(NIJPLAST>0)
        YIELDERRNODAL(iloop)=(DIJYIELD/NIJPLAST)^0.5;
    end
    
    
    % Apply criteria for decreasing the timestep
    yndt=0;
    % Define displacement timestep dtm
    dtm=dt;
    maxvx=max(max(abs(vx)));
    maxvy=max(max(abs(vy)));
    if(dtm*maxvx>dxymax*dx)
        dtm=dxymax*dx/maxvx/dtkoefv
        yndt=1;
    end
    if(dtm*maxvy>dxymax*dy)
        dtm=dxymax*dy/maxvy/dtkoefv
        yndt=1;
    end
    % Apply maximal stress change condition
    dts=dt;
    maxDScurrent=max(max(max(abs(DSXX))),max(max(abs(DSXY))));
    if(maxDScurrent>DSmax)
        dts=dts/maxDScurrent*DSmax/dtkoefv
        yndt=1;
    end
    % Apply pressure timestepping condition
    dtp=dt;
    maxDPcurrent=max(max(abs(DP)));
    if(maxDPcurrent>DPmax)
        dtp=dtp/maxDPcurrent*DPmax/dtkoefv
        yndt=1;
    end
    % Apply thermal timestepping condition
    dtt=dt;
    maxDTcurrent=max(max(abs(DT)));
    if(maxDTcurrent>DTmax)
        dtt=dtt/maxDTcurrent*DTmax/dtkoefv
        yndt=1;
    end
    % Apply state variable timestepping condition
    dtom=dt;
    maxDOMcurrent=max(max(abs(OM-OM0)));
    if(maxDOMcurrent>DOMmax)
        dtom=dtom/maxDOMcurrent*DOMmax/dtkoefv
        yndt=1;
    end
    if(dtrobert<dt)
        diff=dtrobert-dtlapusta
        yndt=1;
        dtrobert=dtrobert/dtkoefv
    end
    if(dtlapusta<dt)
        yndt=1;
        dtlapusta=dtlapusta/dtkoefv
    end
    % Decrease computational timestep if too many iterations
    dtpl=dt;
    if(fix((icount+1)/dtstep)*dtstep==(icount+1))
        % Decrease timestep
        dtpl=dtpl/dtkoef
        yndt=1;
    end
    % Check if further dt reduction possible
    if(dt<=dtmin)
        yndt=0;
    end
    
    % Reset timestep, restart iteration
    ynstop=0;
    if(yndt>0)
        dt=max(dtmin,min([dtt, dtm, dts, dtpl, dtom, dtrobert, dtlapusta, dtp]));
        % Reset old viscoplastic viscosity, temperature
        ETAVP=ETAVP00;
        YYN=YYN00;
        OM=OM0;
        T1=T0;
    elseif(icount>0)
        % Check max P,T change between iterations
        TEMERRNODAL(iloop)=max(max(abs(DT-DT0)));
        PREERRNODAL(iloop)=max(max(abs(DP-DP0)));
        % Stop iteration
        if(TEMERRNODAL(iloop)<terrmax && PREERRNODAL(iloop)<perrmax && ...
                (NIJPLAST==0 || iloop==nloop || YIELDERRNODAL(iloop)<yerrmax))
            ynstop=1;
            % Repeat iteration
        elseif(NIJPLAST>0)
            % Use new viscoplastic viscosity
            ETAVP=ETA5;
            YYN=YYN5;
            OM=OM5;
        end
    elseif(NIJPLAST>0)
        % Use new viscoplastic viscosity
        ETAVP=ETA5;
        YYN=YYN5;
        OM=OM5;
    end
    
    % Save Last DT and DP
    DT0=DT;
    DP0=DP;
    
    % Reset/Update iteration counter without dt changes
    if(yndt>0)
        icount=0;
    else
        icount=icount+1;
    end
    if(fix(iloop/visstep)*visstep==iloop || ynstop>0)
        figure(3);colormap('Jet');clf
        subplot(3,4,1)
        pcolor(x/1000,y/1000,log10(DEFF));% caxis([17 21])
        shading flat;
        axis ij image;
        colorbar
        title(['log D, m timestep=',num2str(t)])
        % title(['log10ETA0, Pa*s timestep=',num2str(timestep)])
        
        subplot(3,4,2)
        pcolor(x/1000,y/1000,log10(ETAVP00));% caxis([17 21])
        shading flat;
        axis ij image;
        colorbar
        title(['log10ETA00, Pa*s time=',num2str(timesum/(365.25*24*3600)),' yr'])
        
        subplot(3,4,3)
        pcolor(x/1000,y/1000,log10(ETAVP));% caxis([17 21])
        shading flat;
        axis ij image;
        colorbar
        title(['log10ETA, Pa*s iteration=',num2str(iloop)])
        
        subplot(3,4,4)
        pcolor(x/1000,y/1000,DSY);% caxis([17 21])
        shading flat;
        axis ij image;
        colorbar
        title(['Yield error, Pa for nodes=',num2str(NIJPLAST)])
        
        subplot(3,4,5)
        pcolor(xvx/1000,yvx/1000,vx)
        shading interp;
        axis ij image;
        colorbar
        title(['Vx, m/s time=',num2str(timesum),' s'])

        
        subplot(3,4,6)
        pcolor(xvy/1000,yvy/1000,vy)
        shading interp;
        axis ij image;
        colorbar
        title('Vy, m/s')
        
        subplot(3,4,7)
        pcolor(x/1000,y/1000,OM)
        shading interp;
        axis ij image;
        colorbar
        title('State')
        
        subplot(3,4,8)
        pcolor(xp/1000,yp/1000,log10(EII))
        shading interp;
        axis ij image;
        colorbar
        title('logEPSILONii, 1/s')
       
        % Compute/Plot yielding error
        subplot(3,1,3)
        plot(1:iloop,log10(YIELDERRNODAL(1:iloop)),'k');
        title(['log Yielding error=',num2str(YIELDERRNODAL(iloop)),' Pa for ',num2str(NIJPLAST),' nodes time=',num2str(timesum/(365.25*24*3600)),' yr dt=',num2str(dt),' s'])


    
    end

    % ynstop == 1意味着循环截止条件达到，此时只需跳出iterations
    % 否则不跳出
    if(ynstop>0)
        break;
    end
    % End Plastic iterations on Nodes
end


% Interpolate new viscoplastic viscosity and state to markers
for m=1:1:marknum
    % Interpolation viscosity from basic nodes
    % Define i,j indexes for the upper left node
    j=fix((xm(m)-x(1))/dx)+1;
    i=fix((ym(m)-y(1))/dy)+1;
    if(j<1)
        j=1;
    elseif(j>Nx-1)
        j=Nx-1;
    end
    if(i<1)
        i=1;
    elseif(i>Ny-1)
        i=Ny-1;
    end
    % Compute distances
    dxmj=xm(m)-x(j);
    dymi=ym(m)-y(i);
    % Compute weights
    wtmij=(1-dxmj/dx)*(1-dymi/dy);
    wtmi1j=(1-dxmj/dx)*(dymi/dy);    
    wtmij1=(dxmj/dx)*(1-dymi/dy);
    wtmi1j1=(dxmj/dx)*(dymi/dy);
    % Interpolate State
    om0m(m)=OM(i,j)*wtmij+OM(i+1,j)*wtmi1j+...
            OM(i,j+1)*wtmij1+OM(i+1,j+1)*wtmi1j1;
    % Interpolate visco-plastic viscosity
    if(YYN(i,j)>0 || YYN(i+1,j)>0 || YYN(i,j+1)>0 || YYN(i+1,j+1)>0)
        etavpm(m)=1/(YYN(i,j)/ETAVP(i,j)*wtmij+YYN(i+1,j)/ETAVP(i+1,j)*wtmi1j+...
                YYN(i,j+1)/ETAVP(i,j+1)*wtmij1+YYN(i+1,j+1)/ETAVP(i+1,j+1)*wtmi1j1);
        if(etavpm(m)>=etam(tm(m)))
            etavpm(m)=etam(tm(m));
        end
    else
        etavpm(m)=etam(tm(m));
    end
end


% Reset displacement timestep
dtm=dt;
% Computing "STRESS" and "Pressure"subgrid diffusion for markers
if (subgrdifcoes>0)
    % Existence of subgrid diffusion.
    % Page162 How to correct the problem ?
    % operating  consistent subgrid diffusion .
    % Clear subgrid temperature changes(dTijsub) for nodes
    % P-NODES
    WPNODES = zeros(Ny1,Nx1);
    SXXSUM = zeros(Ny1,Nx1);
    P0SUM = zeros(Ny1,Nx1);
    % Basic-NODES
    WNODES = zeros(Ny,Nx);
    SXYSUM = zeros(Ny,Nx);
    % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
    for m = 1:marknum
        % Interpolate T to P-NODES(Nx*Ny)
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        sxxm0nodal= SXX0(i,j)*wtmij + SXX0(i+1,j)*wtmi1j  ...
            + SXX0(i,j+1)*wtmij1 + SXX0(i+1,j+1)*wtmi1j1;
        p0mnodal = P0(i,j)*wtmij + P0(i+1,j)*wtmi1j  ...
            +P0(i,j+1)*wtmij1 + P0(i+1,j+1)*wtmi1j1;
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        sxym0nodal= SXY0(i,j)*wtmij + SXY0(i+1,j)*wtmi1j  ...
            +SXY0(i,j+1)*wtmij1 + SXY0(i+1,j+1)*wtmi1j1;
        % NOTE THAT the answer is sxxm(m)-sxxm0nodal.
        % Eq.10.14
        dsxxm0 = sxxm0nodal - sxxm(m);
        dp0m     = p0mnodal - p0m(m);
        dsxym0 = sxym0nodal - sxym(m);
        % Page209
        tdiff = etam(tm(m))/mium(tm(m));
        % Computing subgrid diffusion
        % Why??
        % dve = 0;%209,0<dve<1
        sdif=-subgrdifcoes*dtm/tdiff;
        % Page162 Eq.10.16
        dsxxmsub=dsxxm0*(1-exp(sdif));
        dp0msub = dp0m*(1-exp(sdif));
        dsxymsub=dsxym0*(1-exp(sdif));
        
        % Eq.10.19
        % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
        sxxm(m) = sxxm(m) + dsxxmsub;
        p0m(m)  = p0m(m) + dp0msub;
        sxym(m) = sxym(m) + dsxymsub;
        % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
        % Eq.10.17
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            SXXSUM(i,j) = SXXSUM(i,j) + dsxxmsub*wtmij;
            P0SUM(i,j) = P0SUM(i,j) + dp0msub*wtmij;
            WPNODES(i,j) = WPNODES(i,j) + wtmij;
        end
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            SXXSUM(i+1,j) = SXXSUM(i+1,j) + dsxxmsub*wtmi1j;
            P0SUM(i+1,j) = P0SUM(i+1,j) + dp0msub*wtmi1j;
            WPNODES(i+1,j) = WPNODES(i+1,j) + wtmi1j;
        end
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            SXXSUM(i,j+1) = SXXSUM(i,j+1) + dsxxmsub*wtmij1;
            P0SUM(i,j+1) = P0SUM(i,j+1) + dp0msub*wtmij1;
            WPNODES(i,j+1) = WPNODES(i,j+1) + wtmij1;
        end
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            SXXSUM(i+1,j+1) = SXXSUM(i+1,j+1) + dsxxmsub*wtmi1j1;
            P0SUM(i+1,j+1) = P0SUM(i+1,j+1) + dp0msub*wtmi1j1;
            WPNODES(i+1,j+1) = WPNODES(i+1,j+1) + wtmi1j1;
        end
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            SXYSUM(i,j) = SXYSUM(i,j) + dsxymsub*wtmij;
            WNODES(i,j) = WNODES(i,j) + wtmij;
        end
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            SXYSUM(i+1,j) = SXYSUM(i+1,j) + dsxymsub*wtmi1j;
            WNODES(i+1,j) = WNODES(i+1,j) + wtmi1j;
        end
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            SXYSUM(i,j+1) = SXYSUM(i,j+1) + dsxymsub*wtmij1;
            WNODES(i,j+1) = WNODES(i,j+1) + wtmij1;
        end
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            SXYSUM(i+1,j+1) = SXYSUM(i+1,j+1) + dsxymsub*wtmi1j1;
            WNODES(i+1,j+1) = WNODES(i+1,j+1) + wtmi1j1;
        end
    end
    dsxxijsub = zeros(Ny1,Nx1);
    dp0ijsub = zeros(Ny1,Nx1);
    dsxyijsub = zeros(Ny,Nx);
    % P-NODES
    for j=2:1:Nx
        for i=2:1:Ny
            if(WPNODES(i,j)>0)
                dsxxijsub(i,j)=SXXSUM(i,j)/WPNODES(i,j);
                dp0ijsub(i,j) = P0SUM(i,j)/WPNODES(i,j);
            end
        end
    end
    % Basic nodes
    for j=1:1:Nx
        for i=1:1:Ny
            if(WNODES(i,j)>0)
                dsxyijsub(i,j) = SXYSUM(i,j)/WNODES(i,j);
            end
        end
    end
    % Eq.10.18
    % Update dTij(dTij(remain) = dTij - dTij(sub)  )
    DSXX = DSXX - dsxxijsub;
    DP = DP - dp0ijsub;
    DSXY = DSXY - dsxyijsub;
end


% Interpolate L-markers(dTremain) from P-node(dsxxijremain)
for m = 1:1:marknum
    % Define i,j indexes for the upper left node
    j=fix((xm(m)-xp(1))/dx)+1;
    i=fix((ym(m)-yp(1))/dy)+1;
    if(j<2)
        j=2;
    elseif(j>Nx-1)
        j=Nx-1;
    end
    if(i<2)
        i=2;
    elseif(i>Ny-1)
        i=Ny-1;
    end
    % Compute distances
    dis_x=xm(m)-xp(j);
    dis_y=ym(m)-yp(i);
    % Compute weights
    wtmij=(1-dis_x/dx)*(1-dis_y/dy);
    wtmi1j=(1-dis_x/dx)*(dis_y/dy);
    wtmij1=(dis_x/dx)*(1-dis_y/dy);
    wtmi1j1=(dis_x/dx)*(dis_y/dy);
    % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
    dsxxmremain= DSXX(i,j)  *wtmij  + DSXX(i+1,j)   *wtmi1j  ...
        + DSXX(i,j+1)*wtmij1 + DSXX(i+1,j+1) *wtmi1j1;
    dp0mremain = DP(i,j)  *wtmij  + DP(i+1,j)   *wtmi1j  ...
        + DP(i,j+1)*wtmij1 + DP(i+1,j+1) *wtmi1j1;
    % "NOTE THAT" this discard interpolation of new stress SXX.
    sxxm(m) = sxxm(m) + dsxxmremain;
    p0m(m) = p0m(m) + dp0mremain;
    
    % Define i,j indexes for the upper left node
    j=fix((xm(m)-x(1))/dx)+1;
    i=fix((ym(m)-y(1))/dy)+1;
    if(j<1)
        j=1;
    elseif(j>Nx-1)
        j=Nx-1;
    end
    if(i<1)
        i=1;
    elseif(i>Ny-1)
        i=Ny-1;
    end
    % Compute distances
    dis_x=xm(m)-x(j);
    dis_y=ym(m)-y(i);
    % Compute weights
    wtmij=(1-dis_x/dx)*(1-dis_y/dy);
    wtmi1j=(1-dis_x/dx)*(dis_y/dy);
    wtmij1=(dis_x/dx)*(1-dis_y/dy);
    wtmi1j1=(dis_x/dx)*(dis_y/dy);
    % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
    dsxymremain=DSXY(i,j)  *wtmij  + DSXY(i+1,j)  *wtmi1j  ...
        +DSXY(i,j+1)*wtmij1 + DSXY(i+1,j+1)*wtmi1j1;
    % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
    % Eq.10.19
    sxym(m) = sxym(m) + dsxymremain;
end

% Computing "Vx and Vy"subgrid diffusion for markers
if (subgrdifcoev>0)
    % Vx-NODES
    WVXNODES = zeros(Ny1,Nx1);
    VXSUM = zeros(Ny1,Nx1);
    % Basic-NODES
    WVYNODES = zeros(Ny,Nx);
    VYSUM = zeros(Ny,Nx);
    % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
    for m = 1:marknum
        % Interpolate Vx to Vx-NODES(Nx*Ny1)
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xvx(j);
        dis_y=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        vx0mnodal= vx0(i,j)*wtmij + vx0(i+1,j)*wtmi1j  ...
            + vx0(i,j+1)*wtmij1 + vx0(i+1,j+1)*wtmi1j1;
        % Interpolate Vy to Vy-NODES(Nx1*Ny)
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xvy(j);
        dis_y=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        vy0mnodal= vy0(i,j)*wtmij + vy0(i+1,j)*wtmi1j  ...
            +vy0(i,j+1)*wtmij1 + vy0(i+1,j+1)*wtmi1j1;
        % NOTE THAT the answer is sxxm(m)-sxxm0nodal.
        % Eq.10.14
        dvx0m = vx0mnodal - vx0m(m);
        dvy0m = vy0mnodal - vy0m(m);
        % Page209
        tdiff =rhom(tm(m))/(etavpm(m)*(2/dx^2+2/dy^2));
        % Computing subgrid diffusion
        sdif=-subgrdifcoev*dtm/tdiff;
        % Page162 Eq.10.16
        dvx0msub=dvx0m*(1-exp(sdif));
        dvy0msub=dvy0m*(1-exp(sdif));
        
        % Eq.10.19
        % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
        vx0m(m) = vx0m(m) + dvx0msub;
        vy0m(m) = vy0m(m) + dvy0msub;
        
        % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
        % Eq.10.17
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xvx(j);
        dis_y=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            VXSUM(i,j) = VXSUM(i,j) + dvx0msub*rhom(tm(m))*wtmij;
            WVXNODES(i,j) = WVXNODES(i,j) + rhom(tm(m))*wtmij;
        end
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            VXSUM(i+1,j) = VXSUM(i+1,j) + dvx0msub*rhom(tm(m))*wtmi1j;
            WVXNODES(i+1,j) = WVXNODES(i+1,j) + rhom(tm(m))*wtmi1j;
        end
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            VXSUM(i,j+1) = VXSUM(i,j+1) + dvx0msub*rhom(tm(m))*wtmij1;
            WVXNODES(i,j+1) = WVXNODES(i,j+1) + rhom(tm(m))*wtmij1;
        end
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            VXSUM(i+1,j+1) = VXSUM(i+1,j+1) + dvx0msub*rhom(tm(m))*wtmi1j1;
            WVXNODES(i+1,j+1) = WVXNODES(i+1,j+1) + rhom(tm(m))*wtmi1j1;
        end
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xvy(j);
        dis_y=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            VYSUM(i,j) = VYSUM(i,j) + dvy0msub*rhom(tm(m))*wtmij;
            WVYNODES(i,j) = WVYNODES(i,j) + rhom(tm(m))*wtmij;
        end
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            VYSUM(i+1,j) = VYSUM(i+1,j) + dvy0msub*rhom(tm(m))*wtmi1j;
            WVYNODES(i+1,j) = WVYNODES(i+1,j) + rhom(tm(m))*wtmi1j;
        end
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            VYSUM(i,j+1) = VYSUM(i,j+1) + dvy0msub*rhom(tm(m))*wtmij1;
            WVYNODES(i,j+1) = WVYNODES(i,j+1) + rhom(tm(m))*wtmij1;
        end
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            VYSUM(i+1,j+1) = VYSUM(i+1,j+1) + dvy0msub*rhom(tm(m))*wtmi1j1;
            WVYNODES(i+1,j+1) = WVYNODES(i+1,j+1) + rhom(tm(m))*wtmi1j1;
        end
    end
    
    dvxijsub = zeros(Ny1,Nx1);
    dvyijsub = zeros(Ny1,Nx1);
    % P-NODES
    for j=2:1:Nx
        for i=2:1:Ny
            if(WVXNODES(i,j)>0)
                dvxijsub(i,j)=VXSUM(i,j)/WVXNODES(i,j);
            end
        end
    end
    % Basic nodes
    for j=1:1:Nx
        for i=1:1:Ny
            if(WVYNODES(i,j)>0)
                dvyijsub(i,j) = VYSUM(i,j)/WVYNODES(i,j);
            end
        end
    end
    
    % Eq.10.18
    % Update dTij(dTij(remain) = dTij - dTij(sub)  )
    DVX = DVX - dvxijsub;
    DVY = DVY - dvyijsub;
end

% Interpolate L-markers from Vx-node
for m = 1:1:marknum
    % Define i,j indexes for the upper left node
    j=fix((xm(m)-xvx(1))/dx)+1;
    i=fix((ym(m)-yvx(1))/dy)+1;
    if(j<1 )
        j=1;
    elseif(j>Nx-1)
        j=Nx-1;
    end
    if(i<1)
        i=1;
    elseif(i>Ny)
        i=Ny;
    end
    % Compute distances
    dis_x=xm(m)-xvx(j);
    dis_y=ym(m)-yvx(i);
    % Compute weights
    wtmij=(1-dis_x/dx)*(1-dis_y/dy);
    wtmi1j=(1-dis_x/dx)*(dis_y/dy);
    wtmij1=(dis_x/dx)*(1-dis_y/dy);
    wtmi1j1=(dis_x/dx)*(dis_y/dy);
    % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
    dvxmremain= DVX(i,j)  *wtmij  + DVX(i+1,j)   *wtmi1j  ...
        + DVX(i,j+1)*wtmij1 + DVX(i+1,j+1) *wtmi1j1;
    % "NOTE THAT" this discard interpolation of new stress SXX.
    vx0m(m) = vx0m(m) + dvxmremain;
    
    % Define i,j indexes for the upper left node
    j=fix((xm(m)-xvy(1))/dx)+1;
    i=fix((ym(m)-yvy(1))/dy)+1;
    if(j<1)
        j=1;
    elseif(j>Nx)
        j=Nx;
    end
    if(i<1)
        i=1;
    elseif(i>Ny-1)
        i=Ny-1;
    end
    % Compute distances
    dis_x=xm(m)-xvy(j);
    dis_y=ym(m)-yvy(i);
    % Compute weights
    wtmij=(1-dis_x/dx)*(1-dis_y/dy);
    wtmi1j=(1-dis_x/dx)*(dis_y/dy);
    wtmij1=(dis_x/dx)*(1-dis_y/dy);
    wtmi1j1=(dis_x/dx)*(dis_y/dy);
    % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
    dvymremain=DVY(i,j)  *wtmij  + DVY(i+1,j)  *wtmi1j  ...
        +DVY(i,j+1)*wtmij1 + DVY(i+1,j+1)*wtmi1j1;
    % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
    % Eq.10.19
    vy0m(m) = vy0m(m) + dvymremain;
end

% Computing "temperature"subgrid diffusion for markers
if (subgrdifcoet>0)
    % Existence of subgrid diffusion.
    % Page162 How to correct the problem ?
    % operating  consistent subgrid diffusion .
    % Clear subgrid temperature changes(dTijsub) for nodes
    % From marker to P-NODES
    WPNODES = zeros(Ny1,Nx1);
    WDTM = zeros(Ny1,Nx1);
    % Interpolate Tm0(nodal) from E-nodes(T0) to L-markers.
    for m = 1:marknum
        % Interpolate T to P-NODES(Nx*Ny)
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
        Tm0nodal= T0(i,j)*wtmij + T0(i+1,j)*wtmi1j  ...
            +T0(i,j+1)*wtmij1 + T0(i+1,j+1)*wtmi1j1;
        % Eq.10.14
        dTm = Tm0nodal - tkm(m);
        % Page163
        tdiff = rhocpm(tm(m))/(km(tm(m))*(2/dx^2+2/dy^2));
        % Computing subgrid diffusion
        % Why??
        sdif=-subgrdifcoet*dtm/tdiff;
        % Page162 Eq.10.16
        dTmsub=dTm*(1-exp(sdif));
        % Eq.10.19
        % Tcorrected = Tm0 + dTsubgrid (+ dTremain)
        tkm(m) = tkm(m) + dTmsub;
        % Interpolate Basic node(dTijsub) from L-markers(dTmsub)
        % Eq.10.17
        if(dis_x/dx<=0.5 && dis_y/dy<=0.5)
            WDTM(i,j) = WDTM(i,j) + dTmsub*rhocpm(tm(m))*wtmij;
            WPNODES(i,j) = WPNODES(i,j) + rhocpm(tm(m))*wtmij;
        end
        if(dis_x/dx>=0.5 && dis_y/dy<=0.5)
            WDTM(i+1,j) = WDTM(i+1,j) + dTmsub*rhocpm(tm(m))*wtmi1j;
            WPNODES(i+1,j) = WPNODES(i+1,j) + rhocpm(tm(m))*wtmi1j;
        end
        if(dis_x/dx<=0.5 && dis_y/dy>=0.5)
            WDTM(i,j+1) = WDTM(i,j+1) + dTmsub*rhocpm(tm(m))*wtmij1;
            WPNODES(i,j+1) = WPNODES(i,j+1) + rhocpm(tm(m))*wtmij1;
        end
        if(dis_x/dx>=0.5 && dis_y/dy>=0.5)
            WDTM(i+1,j+1) = WDTM(i+1,j+1) + dTmsub*rhocpm(tm(m))*wtmi1j1;
            WPNODES(i+1,j+1) = WPNODES(i+1,j+1) + rhocpm(tm(m))*wtmi1j1;
        end
    end
    dTijsub = zeros(Ny1,Nx1);
    for j = 1:Nx1
        for i = 1:Ny1
            if(WPNODES(i,j)>0)
                % Compting dTijsub
                % Eq.10.17
                dTijsub(i,j) = WDTM(i,j)/WPNODES(i,j);
            end
        end
    end
    % Eq.10.18
    % Update dTij(dTij(remain) = dTij - dTijsub)
    DT = DT - dTijsub;
end
% Interpolate L-markers(dTremain) from P-node(dTijremain)
for m = 1:1:marknum
    % Define i,j indexes for the upper left node
    j=fix((xm(m)-xp(1))/dx)+1;
    i=fix((ym(m)-yp(1))/dy)+1;
    if(j<1)
        j=1;
    elseif(j>Nx)
        j=Nx;
    end
    if(i<1)
        i=1;
    elseif(i>Ny)
        i=Ny;
    end
    % Compute distances
    dis_x=xm(m)-xp(j);
    dis_y=ym(m)-yp(i);
    % Compute weights
    wtmij=(1-dis_x/dx)*(1-dis_y/dy);
    wtmi1j=(1-dis_x/dx)*(dis_y/dy);
    wtmij1=(dis_x/dx)*(1-dis_y/dy);
    wtmi1j1=(dis_x/dx)*(dis_y/dy);
    % Interpolate Basic node(Tm0nodal) from L-markers(T0i,j)
    dTmremain=    DT(i,j)  *wtmij  + DT(i+1,j)  *wtmi1j  ...
        +DT(i,j+1)*wtmij1 + DT(i+1,j+1)*wtmi1j1;
    % Tcorrected = Tm0(Tm0+ dTsubgrid) + dTremain
    % Eq.10.19
    tkm(m) = tkm(m) + dTmremain;
    if(t==1)
        % Interpolate new temperature for the 1st timestep
        tkm(m) = T1(i,j)*wtmij + T1(i+1,j)*wtmi1j  ...
            +T1(i,j+1)*wtmij1 + T1(i+1,j+1)*wtmi1j1;
    end
end
    % Computing Vx/Vy at the P-nodes
    for j = 2:1:Nx
        for i = 2:1:Ny
            %  Computing internal Vx and Vy at the P nodes.
            % Vx at internal(P) nodes.
            pvx(i,j) = ( vx(i,j) + vx(i,j-1) )./2;
            % Vy at internal nodes.
            pvy(i,j) = ( vy(i,j) + vy(i-1,j) )./2;
        end
    end
    % Vx
    % Top
    pvx(1,2:Nx-1)=2*vxtop-bctop*pvx(2,2:Nx-1);
    % Bottom
    pvx(Ny1,2:Nx-1)=2*vxbottom-bcbottom*pvx(Ny,2:Nx-1);
    % Left
    pvx(:,1)=pvx(:,2);
    % Right
    pvx(:,Nx1)=pvx(:,Nx);
     % Vy
    % Left
    pvy(2:Ny-1,1)=-bcleft*pvy(2:Ny-1,2);
    % Right
    pvy(2:Ny-1,Nx1)=-bcright*pvy(2:Ny-1,Nx);
    % Top
    pvy(1,:)=-pvy(2,:);
    % Bottom
    pvy(Ny1,:)=-pvy(Ny,:);
    % Rotate stress by Analytical formulas.
    for i=1:1:Ny
        for j=1:1:Nx
            wyx(i,j)=0.5*((vy(i,j+1)-vy(i,j))/dx-(vx(i+1,j)-vx(i,j))/dy);
        end
    end

    % 此处计算应力压强与速度时没有考虑对其进行的sub与remain修正。
    % "BEFORE" marker-advection.
    % Compute stress, pressure, velocity state 
    % Basic node(SXY)
    SXYSUM=zeros(Ny,Nx);
    OM0SUM=zeros(Ny,Nx);
    WTBSUM=zeros(Ny,Nx);
    % Vx node(Vx)
    VXSUM=zeros(Ny1,Nx1);
    WTXSUM=zeros(Ny1,Nx1);
    % Vy node(Vy)
    VYSUM=zeros(Ny1,Nx1);
    WTYSUM=zeros(Ny1,Nx1);
    % P node(SXX,P)
    SXXSUM=zeros(Ny1,Nx1);
    PSUM=zeros(Ny1,Nx1);
    WTPSUM=zeros(Ny1,Nx1);
    for m=1:1:marknum
        % SXX, P
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xp(j);
        dis_y=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Compute nodal SIGMA'xx, P
        sxxm(m)=SXX(i,j)*wtmij+SXX(i+1,j)*wtmi1j+...
            SXX(i,j+1)*wtmij1+SXX(i+1,j+1)*wtmi1j1;
        p0m(m)=P(i,j)*wtmij+P(i+1,j)*wtmi1j+...
            P(i,j+1)*wtmij1+P(i+1,j+1)*wtmi1j1;
        % Update values on nodes
        % i,j Node
        SXXSUM(i,j)=SXXSUM(i,j)+sxxm(m)*wtmij;
        PSUM(i,j)=PSUM(i,j)+p0m(m)*wtmij;
        WTPSUM(i,j)=WTPSUM(i,j)+wtmij;
        % i+1,j Node
        SXXSUM(i+1,j)=SXXSUM(i+1,j)+sxxm(m)*wtmi1j;
        PSUM(i+1,j)=PSUM(i+1,j)+p0m(m)*wtmi1j;
        WTPSUM(i+1,j)=WTPSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        SXXSUM(i,j+1)=SXXSUM(i,j+1)+sxxm(m)*wtmij1;
        PSUM(i,j+1)=PSUM(i,j+1)+p0m(m)*wtmij1;
        WTPSUM(i,j+1)=WTPSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        SXXSUM(i+1,j+1)=SXXSUM(i+1,j+1)+sxxm(m)*wtmi1j1;
        PSUM(i+1,j+1)=PSUM(i+1,j+1)+p0m(m)*wtmi1j1;
        WTPSUM(i+1,j+1)=WTPSUM(i+1,j+1)+wtmi1j1;
        
        % SIGMAxy
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Compute nodal SIGMAxy
        sxym(m)=SXY(i,j)*wtmij+SXY(i+1,j)*wtmi1j+...
            SXY(i,j+1)*wtmij1+SXY(i+1,j+1)*wtmi1j1;
        % Update value on nodes
        % i,j Node
        SXYSUM(i,j)=SXYSUM(i,j)+sxym(m)*wtmij;
        OM0SUM(i,j)=OM0SUM(i,j)+om0m(m)*wtmij;
        WTBSUM(i,j)=WTBSUM(i,j)+wtmij;
        % i+1,j Node
        SXYSUM(i+1,j)=SXYSUM(i+1,j)+sxym(m)*wtmi1j;
        OM0SUM(i+1,j)=OM0SUM(i+1,j)+om0m(m)*wtmi1j;
        WTBSUM(i+1,j)=WTBSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        SXYSUM(i,j+1)=SXYSUM(i,j+1)+sxym(m)*wtmij1;
        OM0SUM(i,j+1)=OM0SUM(i,j+1)+om0m(m)*wtmij1;
        WTBSUM(i,j+1)=WTBSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        SXYSUM(i+1,j+1)=SXYSUM(i+1,j+1)+sxym(m)*wtmi1j1;
        OM0SUM(i+1,j+1)=OM0SUM(i+1,j+1)+om0m(m)*wtmi1j1;
        WTBSUM(i+1,j+1)=WTBSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation from/to vx-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dis_x=xm(m)-xvx(j);
        dis_y=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Compute nodal vx
        vx0m(m)=vx(i,j)*wtmij+vx(i+1,j)*wtmi1j+...
            vx(i,j+1)*wtmij1+vx(i+1,j+1)*wtmi1j1;
        % Update properties
        % i,j Node
        VXSUM(i,j)=VXSUM(i,j)+vx0m(m)*wtmij;
        WTXSUM(i,j)=WTXSUM(i,j)+wtmij;
        % i+1,j Node
        VXSUM(i+1,j)=VXSUM(i+1,j)+vx0m(m)*wtmi1j;
        WTXSUM(i+1,j)=WTXSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        VXSUM(i,j+1)=VXSUM(i,j+1)+vx0m(m)*wtmij1;
        WTXSUM(i,j+1)=WTXSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        VXSUM(i+1,j+1)=VXSUM(i+1,j+1)+vx0m(m)*wtmi1j1;
        WTXSUM(i+1,j+1)=WTXSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation from/to vy-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-xvy(j);
        dis_y=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Compute nodal vy
        vy0m(m)=vy(i,j)*wtmij+vy(i+1,j)*wtmi1j+...
            vy(i,j+1)*wtmij1+vy(i+1,j+1)*wtmi1j1;
        % Update properties
        % i,j Node
        VYSUM(i,j)=VYSUM(i,j)+vy0m(m)*wtmij;
        WTYSUM(i,j)=WTYSUM(i,j)+wtmij;
        % i+1,j Node
        VYSUM(i+1,j)=VYSUM(i+1,j)+vy0m(m)*wtmi1j;
        WTYSUM(i+1,j)=WTYSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        VYSUM(i,j+1)=VYSUM(i,j+1)+vy0m(m)*wtmij1;
        WTYSUM(i,j+1)=WTYSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        VYSUM(i+1,j+1)=VYSUM(i+1,j+1)+vy0m(m)*wtmi1j1;
        WTYSUM(i+1,j+1)=WTYSUM(i+1,j+1)+wtmi1j1;
    end
    % Basic nodes
    SXY01=zeros(Ny,Nx);
    OM01 = zeros(Ny,Nx);
    for j=1:1:Nx
        for i=1:1:Ny
            if(WTBSUM(i,j)>0)
                SXY01(i,j)=SXYSUM(i,j)/WTBSUM(i,j);
                OM01(i,j)=OM0SUM(i,j)/WTBSUM(i,j);
            end
        end
    end
    % Vx-nodes
    VX01=zeros(Ny1,Nx1);
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTXSUM(i,j)>0)
                VX01(i,j)=VXSUM(i,j)/WTXSUM(i,j);
            end
        end
    end
    % Vy-nodes
    VY01=zeros(Ny1,Nx1);
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTYSUM(i,j)>0)
                VY01(i,j)=VYSUM(i,j)/WTYSUM(i,j);
            end
        end
    end
    % P-nodes
    SXX01=zeros(Ny1,Nx1);
    P01=zeros(Ny1,Nx1);
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTPSUM(i,j)>0)
                SXX01(i,j)=SXXSUM(i,j)/WTPSUM(i,j);
                P01(i,j)=PSUM(i,j)/WTPSUM(i,j);
            end
        end
    end
    
    % After computing stress,pressure and velocity,markers should be
    % advecting.
    
    % The classical Runge-Kutta scheme,Fourth-order in sapce and
    % First-order in time(Accuracy).
    % Define Vxa(Vya)1,Vxb(Vyb)2,Vxc(Vyc)3,Vxd(Vyd)4.
    vxm=zeros(4,1);
    vym=zeros(4,1);
    % Interpolate vx and vy components from E-nodes to L-markers.
    for m=1:1:marknum
        % Computing wm and rotate stress.
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dis_x=xm(m)-x(j);
        dis_y=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dis_x/dx)*(1-dis_y/dy);
        wtmi1j=(1-dis_x/dx)*(dis_y/dy);
        wtmij1=(dis_x/dx)*(1-dis_y/dy);
        wtmi1j1=(dis_x/dx)*(dis_y/dy);
        % Compute vxm and vym velocity
        wm = wyx(i,j)*wtmij+wyx(i+1,j)*wtmi1j...
                 + wyx(i,j+1)*wtmij1+wyx(i+1,j+1)*wtmi1j1;
        angleAB = wm*dtm;
        sxymnew = sxxm(m)*sin(2*angleAB)+sxym(m)*cos(2*angleAB);
        sxxmnew = sxxm(m)*cos(angleAB)^2 - sxxm(m)*sin(angleAB)^2-sxym(m)*sin(2*angleAB) ;
        sxym(m) = sxymnew;
        sxxm(m) = sxxmnew;
        % Reserve original coordinate.
        xa = xm(m);
        ya = ym(m);
        for rk = 1:1:4
            % Interpolate vx-p and vy-p from P-staggered nodes to L-markers.
            % P staggered nodes.(Nx1 * Ny1)
            j=fix((xm(m)-xp(1))/dx)+1;
            i=fix((ym(m)-yp(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xp(j);
            dis_y=ym(m)-yp(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vxm and vym velocity
            vxm(rk) = pvx(i,j)*wtmij    + pvx(i+1,j)*wtmi1j...
                     +pvx(i,j+1)*wtmij1 + pvx(i+1,j+1)*wtmi1j1;
            vym(rk) = pvy(i,j)*wtmij    + pvy(i+1,j)*wtmi1j...
                     +pvy(i,j+1)*wtmij1 + pvy(i+1,j+1)*wtmi1j1;
            % Interpolate vx from Vx-staggered nodes to L-markers.
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvx(1))/dx)+1;
            i=fix((ym(m)-yvx(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx-1)
                j=Nx-1;
            end
            % Vx staggered nodes.(Nx * Ny+1)
            if(i<1)
                i=1;
            elseif(i>Ny)
                i=Ny;
            end
            % Compute distances
            dis_x=xm(m)-xvx(j);
            dis_y=ym(m)-yvx(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vx velocity
            vxm(rk) = (1/3)*vxm(rk) + (2/3)*(vx(i,j)*wtmij+vx(i+1,j)*wtmi1j...
                                           + vx(i,j+1)*wtmij1+vx(i+1,j+1)*wtmi1j1);
            % Interpolate vy
            % Define i,j indexes for the upper left node
            j=fix((xm(m)-xvy(1))/dx)+1;
            i=fix((ym(m)-yvy(1))/dy)+1;
            if(j<1)
                j=1;
            elseif(j>Nx)
                j=Nx;
            end
            if(i<1)
                i=1;
            elseif(i>Ny-1)
                i=Ny-1;
            end
            % Compute distances
            dis_x=xm(m)-xvy(j);
            dis_y=ym(m)-yvy(i);
            % Compute weights
            wtmij=(1-dis_x/dx)*(1-dis_y/dy);
            wtmi1j=(1-dis_x/dx)*(dis_y/dy);
            wtmij1=(dis_x/dx)*(1-dis_y/dy);
            wtmi1j1=(dis_x/dx)*(dis_y/dy);
            % Compute vx velocity
            vym(rk) = (1/3)*vym(rk) + (2/3)*(vy(i,j)*wtmij+vy(i+1,j)*wtmi1j...
                +vy(i,j+1)*wtmij1+vy(i+1,j+1)*wtmi1j1);
            
            if(rk == 1 || rk == 2)
                xm(m) = vxm(rk)*dtm/2 + xa;
                ym(m) = vym(rk)*dtm/2 + ya;
            elseif(rk == 3)
                xm(m) = vxm(rk)*dtm + xa;
                ym(m) = vym(rk)*dtm + ya;
            end
        end
        % Return original coordinate.
        xm(m) = xa;
        ym(m) = ya;
        % Move markers with effective velocity field.
        vxefft = (1/6)*(vxm(1)+2*vxm(2)+2*vxm(3)+vxm(4));
        vyefft = (1/6)*(vym(1)+2*vym(2)+2*vym(3)+vym(4));
        xm(m)=xm(m)+dtm*vxefft;
        ym(m)=ym(m)+dtm*vyefft;
    end
    
    % Compute stress, pressure, velocity state after advection.
    SXYSUM=zeros(Ny,Nx);
    OM0SUM=zeros(Ny,Nx);
    WTBSUM=zeros(Ny,Nx);
    VXSUM=zeros(Ny1,Nx1);
    WTXSUM=zeros(Ny1,Nx1);
    VYSUM=zeros(Ny1,Nx1);
    WTYSUM=zeros(Ny1,Nx1);
    SXXSUM=zeros(Ny1,Nx1);
    PSUM=zeros(Ny1,Nx1);
    WTPSUM=zeros(Ny1,Nx1);
    for m=1:1:marknum
        % SIGMA'xx, P
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xp(1))/dx)+1;
        i=fix((ym(m)-yp(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dxmj=xm(m)-xp(j);
        dymi=ym(m)-yp(i);
        % Compute weights
        wtmij=(1-dxmj/dx)*(1-dymi/dy);
        wtmi1j=(1-dxmj/dx)*(dymi/dy);
        wtmij1=(dxmj/dx)*(1-dymi/dy);
        wtmi1j1=(dxmj/dx)*(dymi/dy);
        % Update values on nodes
        % i,j Node
        SXXSUM(i,j)=SXXSUM(i,j)+sxxm(m)*wtmij;
        PSUM(i,j)=PSUM(i,j)+p0m(m)*wtmij;
        WTPSUM(i,j)=WTPSUM(i,j)+wtmij;
        % i+1,j Node
        SXXSUM(i+1,j)=SXXSUM(i+1,j)+sxxm(m)*wtmi1j;
        PSUM(i+1,j)=PSUM(i+1,j)+p0m(m)*wtmi1j;
        WTPSUM(i+1,j)=WTPSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        SXXSUM(i,j+1)=SXXSUM(i,j+1)+sxxm(m)*wtmij1;
        PSUM(i,j+1)=PSUM(i,j+1)+p0m(m)*wtmij1;
        WTPSUM(i,j+1)=WTPSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        SXXSUM(i+1,j+1)=SXXSUM(i+1,j+1)+sxxm(m)*wtmi1j1;
        PSUM(i+1,j+1)=PSUM(i+1,j+1)+p0m(m)*wtmi1j1;
        WTPSUM(i+1,j+1)=WTPSUM(i+1,j+1)+wtmi1j1;
        
        % SIGMAxy
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-x(1))/dx)+1;
        i=fix((ym(m)-y(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dxmj=xm(m)-x(j);
        dymi=ym(m)-y(i);
        % Compute weights
        wtmij=(1-dxmj/dx)*(1-dymi/dy);
        wtmi1j=(1-dxmj/dx)*(dymi/dy);
        wtmij1=(dxmj/dx)*(1-dymi/dy);
        wtmi1j1=(dxmj/dx)*(dymi/dy);
        % Update value on nodes
        % i,j Node
        SXYSUM(i,j)=SXYSUM(i,j)+sxym(m)*wtmij;
        OM0SUM(i,j)=OM0SUM(i,j)+om0m(m)*wtmij;
        WTBSUM(i,j)=WTBSUM(i,j)+wtmij;
        % i+1,j Node
        SXYSUM(i+1,j)=SXYSUM(i+1,j)+sxym(m)*wtmi1j;
        OM0SUM(i+1,j)=OM0SUM(i+1,j)+om0m(m)*wtmi1j;
        WTBSUM(i+1,j)=WTBSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        SXYSUM(i,j+1)=SXYSUM(i,j+1)+sxym(m)*wtmij1;
        OM0SUM(i,j+1)=OM0SUM(i,j+1)+om0m(m)*wtmij1;
        WTBSUM(i,j+1)=WTBSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        SXYSUM(i+1,j+1)=SXYSUM(i+1,j+1)+sxym(m)*wtmi1j1;
        OM0SUM(i+1,j+1)=OM0SUM(i+1,j+1)+om0m(m)*wtmi1j1;
        WTBSUM(i+1,j+1)=WTBSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation from vx-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvx(1))/dx)+1;
        i=fix((ym(m)-yvx(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx-1)
            j=Nx-1;
        end
        if(i<1)
            i=1;
        elseif(i>Ny)
            i=Ny;
        end
        % Compute distances
        dxmj=xm(m)-xvx(j);
        dymi=ym(m)-yvx(i);
        % Compute weights
        wtmij=(1-dxmj/dx)*(1-dymi/dy);
        wtmi1j=(1-dxmj/dx)*(dymi/dy);
        wtmij1=(dxmj/dx)*(1-dymi/dy);
        wtmi1j1=(dxmj/dx)*(dymi/dy);
        % Update properties
        % i,j Node
        VXSUM(i,j)=VXSUM(i,j)+vx0m(m)*wtmij;
        WTXSUM(i,j)=WTXSUM(i,j)+wtmij;
        % i+1,j Node
        VXSUM(i+1,j)=VXSUM(i+1,j)+vx0m(m)*wtmi1j;
        WTXSUM(i+1,j)=WTXSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        VXSUM(i,j+1)=VXSUM(i,j+1)+vx0m(m)*wtmij1;
        WTXSUM(i,j+1)=WTXSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        VXSUM(i+1,j+1)=VXSUM(i+1,j+1)+vx0m(m)*wtmi1j1;
        WTXSUM(i+1,j+1)=WTXSUM(i+1,j+1)+wtmi1j1;
        
        % Interpolation from vy-nodes
        % Define i,j indexes for the upper left node
        j=fix((xm(m)-xvy(1))/dx)+1;
        i=fix((ym(m)-yvy(1))/dy)+1;
        if(j<1)
            j=1;
        elseif(j>Nx)
            j=Nx;
        end
        if(i<1)
            i=1;
        elseif(i>Ny-1)
            i=Ny-1;
        end
        % Compute distances
        dxmj=xm(m)-xvy(j);
        dymi=ym(m)-yvy(i);
        % Compute weights
        wtmij=(1-dxmj/dx)*(1-dymi/dy);
        wtmi1j=(1-dxmj/dx)*(dymi/dy);
        wtmij1=(dxmj/dx)*(1-dymi/dy);
        wtmi1j1=(dxmj/dx)*(dymi/dy);
        % Update properties
        % i,j Node
        VYSUM(i,j)=VYSUM(i,j)+vy0m(m)*wtmij;
        WTYSUM(i,j)=WTYSUM(i,j)+wtmij;
        % i+1,j Node
        VYSUM(i+1,j)=VYSUM(i+1,j)+vy0m(m)*wtmi1j;
        WTYSUM(i+1,j)=WTYSUM(i+1,j)+wtmi1j;
        % i,j+1 Node
        VYSUM(i,j+1)=VYSUM(i,j+1)+vy0m(m)*wtmij1;
        WTYSUM(i,j+1)=WTYSUM(i,j+1)+wtmij1;
        % i+1,j+1 Node
        VYSUM(i+1,j+1)=VYSUM(i+1,j+1)+vy0m(m)*wtmi1j1;
        WTYSUM(i+1,j+1)=WTYSUM(i+1,j+1)+wtmi1j1;
    end
    % Basic nodes
    SXY02=zeros(Ny,Nx);
    OM02 = zeros(Ny,Nx);
    for j=1:1:Nx
        for i=1:1:Ny
            if(WTBSUM(i,j)>0)
                SXY02(i,j)=SXYSUM(i,j)/WTBSUM(i,j);
                OM02(i,j)=OM0SUM(i,j)/WTBSUM(i,j);
            end
        end
    end
    % Vx-nodes
    VX02=zeros(Ny1,Nx1);
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTXSUM(i,j)>0)
                VX02(i,j)=VXSUM(i,j)/WTXSUM(i,j);
            end
        end
    end
    % Vy-nodes
    VY02=zeros(Ny1,Nx1);
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTYSUM(i,j)>0)
                VY02(i,j)=VYSUM(i,j)/WTYSUM(i,j);
            end
        end
    end
    % P-nodes
    SXX02=zeros(Ny1,Nx1);
    P02=zeros(Ny1,Nx1);
    for j=1:1:Nx1
        for i=1:1:Ny1
            if(WTPSUM(i,j)>0)
                SXX02(i,j)=SXXSUM(i,j)/WTPSUM(i,j);
                P02(i,j)=PSUM(i,j)/WTPSUM(i,j);
            end
        end
    end
    % Correct nodal stresses, pressure, velocity for advection and rotation
    SXX0=SXX+SXX02-SXX01;
    P0=P+P02-P01;
    SXY0=SXY+SXY02-SXY01;
    OM0=OM+OM02-OM01;
    vx0=vx+VX02-VX01;
    vy0=vy+VY02-VY01;
    


    % Sum of time.
    timesum=timesum+dtm;
    % Trace velocity
    % Trace slip
    if(t==1)
        SLIP(t,1:Nx)=VPRSF(Ny1/2,1:Nx)*dtm;
    else
        SLIP(t,1:Nx)=SLIP(t-1,1:Nx)+VPRSF(Ny1/2,1:Nx)*dtm;
    end

    velosmax(t)=max(max(VPRSF));
    timetrac(t)=timesum;

    % Figure at every 20 timesteps.
    if(t==1 || fix(t/visstep)*visstep==t)
        figure(1);colormap('Jet');clf
        subplot(3,4,1)
        pcolor(x/1000,y/1000,log10(ETAVP));% caxis([17 21])
        shading flat;
        axis ij image;
        colorbar
        title(['log10ETA, Pa*s timestep=',num2str(t)])
        
        subplot(3,4,2)
        pcolor(xp/1000,yp/1000,P)
        shading interp;
        axis ij image;
        colorbar
        title('Pressure, Pa')
        
        subplot(3,4,3)
        pcolor(xp/1000,yp/1000,pvx)
        shading interp;
        axis ij image;
        colorbar
        title(['Vx, m/s time=',num2str(timesum/(365.25*24*3600)),' Yr'])
        hold on
        quiver(xp(3:5:Nx1)/1000,yp(3:5:Ny1)/1000,pvx(3:5:Ny,3:5:Nx1),pvy(3:5:Ny1,3:5:Nx1),'k')
        
        subplot(3,4,4)
        pcolor(xp/1000,yp/1000,pvy)
        shading interp;
        axis ij image;
        colorbar
        title('Vy, m/s')
        hold on
        quiver(xp(3:5:Nx1)/1000,yp(3:5:Ny1)/1000,pvx(3:5:Ny,3:5:Nx1),pvy(3:5:Ny1,3:5:Nx1),'k')
        
        subplot(3,4,5)
        pcolor(x/1000,y/1000,OM)
        shading interp;
        axis ij image;
        colorbar
        title('State')
        
        subplot(3,4,6)
        pcolor(xp/1000,yp/1000,EXX)
        shading interp;
        axis ij image;
        colorbar
        title('EPSILONxx, 1/s')
        
        subplot(3,4,7)
        pcolor(x/1000,y/1000,EXY)
        shading interp;
        axis ij image;
        colorbar
        title('EPSILONxy, 1/s')
        
        subplot(3,4,8)
        pcolor(xp/1000,yp/1000,log10(EII))
        shading interp;
        axis ij image;
        colorbar
        title('logEPSILONii, 1/s')
        
        subplot(3,4,9)
        pcolor(x/1000,y/1000,log10(VPRSF))
        shading interp;
        axis ij image;
        colorbar
        title('Vp, m/s')
        
        subplot(3,4,10)
        pcolor(xp/1000,yp/1000,SXX)
        shading interp;
        axis ij image;
        colorbar
        title('SIGMAxx, Pa')
        
        subplot(3,4,11)
        pcolor(x/1000,y/1000,SXY)
        shading interp;
        axis ij image;
        colorbar
        title('SIGMAxy, Pa')
        
        subplot(3,4,12)
        pcolor(xp(2:Nx)/1000,yp(2:Ny)/1000,SII(2:Ny,2:Nx))
        shading interp;
        axis ij image;
        colorbar
        title('SIGMAii, Pa')
        
        figure(4);colormap('Jet');clf
        subplot(2,1,1)
        plot(log10(velosmax))
        subplot(2,1,2)
        plot(timetrac/(365.25*24*3600),log10(velosmax))
        
        
        figure(2);colormap('Jet');clf
        hold on
        plot(x/1000,SLIP(1,:))
        for itr=visstep:visstep:t
            plot(x/1000,SLIP(itr,:))
        end
        title("Tracking Slip Distance with time.");
        pause(0.1);
    end
    
    
end
